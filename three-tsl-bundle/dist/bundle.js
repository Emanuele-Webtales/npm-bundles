/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const t=1001,e=1003,s=1006,i=1016,r=1026,n="srgb",a="srgb-linear",o="linear",h="srgb",l=7680,u=35044,c=35048,d=2e3,p=2001;class m{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const s=this._listeners;void 0===s[t]&&(s[t]=[]),-1===s[t].indexOf(e)&&s[t].push(e)}hasEventListener(t,e){const s=this._listeners;return void 0!==s&&(void 0!==s[t]&&-1!==s[t].indexOf(e))}removeEventListener(t,e){const s=this._listeners;if(void 0===s)return;const i=s[t];if(void 0!==i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}dispatchEvent(t){const e=this._listeners;if(void 0===e)return;const s=e[t.type];if(void 0!==s){t.target=this;const e=s.slice(0);for(let s=0,i=e.length;s<i;s++)e[s].call(this,t);t.target=null}}}const g=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let y=1234567;const f=Math.PI/180,x=180/Math.PI;function b(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,s=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(g[255&t]+g[t>>8&255]+g[t>>16&255]+g[t>>24&255]+"-"+g[255&e]+g[e>>8&255]+"-"+g[e>>16&15|64]+g[e>>24&255]+"-"+g[63&s|128]+g[s>>8&255]+"-"+g[s>>16&255]+g[s>>24&255]+g[255&i]+g[i>>8&255]+g[i>>16&255]+g[i>>24&255]).toLowerCase()}function v(t,e,s){return Math.max(e,Math.min(s,t))}function w(t,e){return(t%e+e)%e}function T(t,e,s){return(1-s)*t+s*e}function N(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function M(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const _={DEG2RAD:f,RAD2DEG:x,generateUUID:b,clamp:v,euclideanModulo:w,mapLinear:function(t,e,s,i,r){return i+(t-e)*(r-i)/(s-e)},inverseLerp:function(t,e,s){return t!==e?(s-t)/(e-t):0},lerp:T,damp:function(t,e,s,i){return T(t,e,1-Math.exp(-s*i))},pingpong:function(t,e=1){return e-Math.abs(w(t,2*e)-e)},smoothstep:function(t,e,s){return t<=e?0:t>=s?1:(t=(t-e)/(s-e))*t*(3-2*t)},smootherstep:function(t,e,s){return t<=e?0:t>=s?1:(t=(t-e)/(s-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(y=t);let e=y+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*f},radToDeg:function(t){return t*x},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,s,i,r){const n=Math.cos,a=Math.sin,o=n(s/2),h=a(s/2),l=n((e+i)/2),u=a((e+i)/2),c=n((e-i)/2),d=a((e-i)/2),p=n((i-e)/2),m=a((i-e)/2);switch(r){case"XYX":t.set(o*u,h*c,h*d,o*l);break;case"YZY":t.set(h*d,o*u,h*c,o*l);break;case"ZXZ":t.set(h*c,h*d,o*u,o*l);break;case"XZX":t.set(o*u,h*m,h*p,o*l);break;case"YXY":t.set(h*p,o*u,h*m,o*l);break;case"ZYZ":t.set(h*m,h*p,o*u,o*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:M,denormalize:N};class S{constructor(t=0,e=0){S.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,i=t.elements;return this.x=i[0]*e+i[3]*s+i[6],this.y=i[1]*e+i[4]*s+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=v(this.x,t.x,e.x),this.y=v(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=v(this.x,t,e),this.y=v(this.y,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(v(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(v(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),i=Math.sin(e),r=this.x-t.x,n=this.y-t.y;return this.x=r*s-n*i+t.x,this.y=r*i+n*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class A{constructor(t,e,s,i,r,n,a,o,h){A.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,s,i,r,n,a,o,h)}set(t,e,s,i,r,n,a,o,h){const l=this.elements;return l[0]=t,l[1]=i,l[2]=a,l[3]=e,l[4]=r,l[5]=o,l[6]=s,l[7]=n,l[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],a=s[3],o=s[6],h=s[1],l=s[4],u=s[7],c=s[2],d=s[5],p=s[8],m=i[0],g=i[3],y=i[6],f=i[1],x=i[4],b=i[7],v=i[2],w=i[5],T=i[8];return r[0]=n*m+a*f+o*v,r[3]=n*g+a*x+o*w,r[6]=n*y+a*b+o*T,r[1]=h*m+l*f+u*v,r[4]=h*g+l*x+u*w,r[7]=h*y+l*b+u*T,r[2]=c*m+d*f+p*v,r[5]=c*g+d*x+p*w,r[8]=c*y+d*b+p*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],n=t[4],a=t[5],o=t[6],h=t[7],l=t[8];return e*n*l-e*a*h-s*r*l+s*a*o+i*r*h-i*n*o}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],n=t[4],a=t[5],o=t[6],h=t[7],l=t[8],u=l*n-a*h,c=a*o-l*r,d=h*r-n*o,p=e*u+s*c+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=u*m,t[1]=(i*h-l*s)*m,t[2]=(a*s-i*n)*m,t[3]=c*m,t[4]=(l*e-i*o)*m,t[5]=(i*r-a*e)*m,t[6]=d*m,t[7]=(s*o-h*e)*m,t[8]=(n*e-s*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,i,r,n,a){const o=Math.cos(r),h=Math.sin(r);return this.set(s*o,s*h,-s*(o*n+h*a)+n+t,-i*h,i*o,-i*(-h*n+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(V.makeScale(t,e)),this}rotate(t){return this.premultiply(V.makeRotation(-t)),this}translate(t,e){return this.premultiply(V.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<9;t++)if(e[t]!==s[t])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const V=new A;function z(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}const C=(new A).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),R=(new A).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function E(){const t={enabled:!0,workingColorSpace:a,spaces:{},convert:function(t,e,s){return!1!==this.enabled&&e!==s&&e&&s?(this.spaces[e].transfer===h&&(t.r=O(t.r),t.g=O(t.g),t.b=O(t.b)),this.spaces[e].primaries!==this.spaces[s].primaries&&(t.applyMatrix3(this.spaces[e].toXYZ),t.applyMatrix3(this.spaces[s].fromXYZ)),this.spaces[s].transfer===h&&(t.r=L(t.r),t.g=L(t.g),t.b=L(t.b)),t):t},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return""===t?o:this.spaces[t].transfer},getLuminanceCoefficients:function(t,e=this.workingColorSpace){return t.fromArray(this.spaces[e].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,e,s){return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[s].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace}},e=[.64,.33,.3,.6,.15,.06],s=[.2126,.7152,.0722],i=[.3127,.329];return t.define({[a]:{primaries:e,whitePoint:i,transfer:o,toXYZ:C,fromXYZ:R,luminanceCoefficients:s,workingColorSpaceConfig:{unpackColorSpace:n},outputColorSpaceConfig:{drawingBufferColorSpace:n}},[n]:{primaries:e,whitePoint:i,transfer:h,toXYZ:C,fromXYZ:R,luminanceCoefficients:s,outputColorSpaceConfig:{drawingBufferColorSpace:n}}}),t}const I=E();function O(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function L(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}let B;class F{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===B&&(B=z("canvas")),B.width=t.width,B.height=t.height;const s=B.getContext("2d");t instanceof ImageData?s.putImageData(t,0,0):s.drawImage(t,0,0,t.width,t.height),e=B}return e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=z("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");s.drawImage(t,0,0,t.width,t.height);const i=s.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t<r.length;t++)r[t]=255*O(r[t]/255);return s.putImageData(i,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*O(e[t]/255)):e[t]=O(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let P=0;class D{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:P++}),this.uuid=b(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(null!==i){let t;if(Array.isArray(i)){t=[];for(let e=0,s=i.length;e<s;e++)i[e].isDataTexture?t.push(k(i[e].image)):t.push(k(i[e]))}else t=k(i);s.url=t}return e||(t.images[this.uuid]=s),s}}function k(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?F.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let U=0;class W extends m{constructor(t=W.DEFAULT_IMAGE,e=W.DEFAULT_MAPPING,s=1001,i=1001,r=1006,n=1008,a=1023,o=1009,h=W.DEFAULT_ANISOTROPY,l=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:U++}),this.uuid=b(),this.name="",this.source=new D(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=n,this.anisotropy=h,this.format=a,this.internalFormat=null,this.type=o,this.offset=new S(0,0),this.repeat=new S(1,1),this.center=new S(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new A,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=l,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case t:e.x=e.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case t:e.y=e.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}W.DEFAULT_IMAGE=null,W.DEFAULT_MAPPING=300,W.DEFAULT_ANISOTROPY=1;class j{constructor(t=0,e=0,s=0,i=1){j.prototype.isVector4=!0,this.x=t,this.y=e,this.z=s,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=this.w,n=t.elements;return this.x=n[0]*e+n[4]*s+n[8]*i+n[12]*r,this.y=n[1]*e+n[5]*s+n[9]*i+n[13]*r,this.z=n[2]*e+n[6]*s+n[10]*i+n[14]*r,this.w=n[3]*e+n[7]*s+n[11]*i+n[15]*r,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,s,i,r;const n=.01,a=.1,o=t.elements,h=o[0],l=o[4],u=o[8],c=o[1],d=o[5],p=o[9],m=o[2],g=o[6],y=o[10];if(Math.abs(l-c)<n&&Math.abs(u-m)<n&&Math.abs(p-g)<n){if(Math.abs(l+c)<a&&Math.abs(u+m)<a&&Math.abs(p+g)<a&&Math.abs(h+d+y-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(h+1)/2,o=(d+1)/2,f=(y+1)/2,x=(l+c)/4,b=(u+m)/4,v=(p+g)/4;return t>o&&t>f?t<n?(s=0,i=.707106781,r=.707106781):(s=Math.sqrt(t),i=x/s,r=b/s):o>f?o<n?(s=.707106781,i=0,r=.707106781):(i=Math.sqrt(o),s=x/i,r=v/i):f<n?(s=.707106781,i=.707106781,r=0):(r=Math.sqrt(f),s=b/r,i=v/r),this.set(s,i,r,e),this}let f=Math.sqrt((g-p)*(g-p)+(u-m)*(u-m)+(c-l)*(c-l));return Math.abs(f)<.001&&(f=1),this.x=(g-p)/f,this.y=(u-m)/f,this.z=(c-l)/f,this.w=Math.acos((h+d+y-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=v(this.x,t.x,e.x),this.y=v(this.y,t.y,e.y),this.z=v(this.z,t.z,e.z),this.w=v(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=v(this.x,t,e),this.y=v(this.y,t,e),this.z=v(this.z,t,e),this.w=v(this.w,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(v(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this.w=t.w+(e.w-t.w)*s,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class q extends m{constructor(t=1,e=1,i={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new j(0,0,t,e),this.scissorTest=!1,this.viewport=new j(0,0,t,e);const r={width:t,height:e,depth:1};i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:s,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},i);const n=new W(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);n.flipY=!1,n.generateMipmaps=i.generateMipmaps,n.internalFormat=i.internalFormat,this.textures=[];const a=i.count;for(let t=0;t<a;t++)this.textures[t]=n.clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=i.depthTexture,this.samples=i.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}set depthTexture(t){null!==this._depthTexture&&(this._depthTexture.renderTarget=null),null!==t&&(t.renderTarget=this),this._depthTexture=t}get depthTexture(){return this._depthTexture}setSize(t,e,s=1){if(this.width!==t||this.height!==e||this.depth!==s){this.width=t,this.height=e,this.depth=s;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=s;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let e=0,s=t.textures.length;e<s;e++){this.textures[e]=t.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;const s=Object.assign({},t.textures[e].image);this.textures[e].source=new D(s)}return this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class H extends W{constructor(s=null,i=1,r=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:s,width:i,height:r,depth:n},this.magFilter=e,this.minFilter=e,this.wrapR=t,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class G{constructor(t=0,e=0,s=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=s,this._w=i}static slerpFlat(t,e,s,i,r,n,a){let o=s[i+0],h=s[i+1],l=s[i+2],u=s[i+3];const c=r[n+0],d=r[n+1],p=r[n+2],m=r[n+3];if(0===a)return t[e+0]=o,t[e+1]=h,t[e+2]=l,void(t[e+3]=u);if(1===a)return t[e+0]=c,t[e+1]=d,t[e+2]=p,void(t[e+3]=m);if(u!==m||o!==c||h!==d||l!==p){let t=1-a;const e=o*c+h*d+l*p+u*m,s=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),n=Math.atan2(r,e*s);t=Math.sin(t*n)/r,a=Math.sin(a*n)/r}const r=a*s;if(o=o*t+c*r,h=h*t+d*r,l=l*t+p*r,u=u*t+m*r,t===1-a){const t=1/Math.sqrt(o*o+h*h+l*l+u*u);o*=t,h*=t,l*=t,u*=t}}t[e]=o,t[e+1]=h,t[e+2]=l,t[e+3]=u}static multiplyQuaternionsFlat(t,e,s,i,r,n){const a=s[i],o=s[i+1],h=s[i+2],l=s[i+3],u=r[n],c=r[n+1],d=r[n+2],p=r[n+3];return t[e]=a*p+l*u+o*d-h*c,t[e+1]=o*p+l*c+h*u-a*d,t[e+2]=h*p+l*d+a*c-o*u,t[e+3]=l*p-a*u-o*c-h*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,i){return this._x=t,this._y=e,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const s=t._x,i=t._y,r=t._z,n=t._order,a=Math.cos,o=Math.sin,h=a(s/2),l=a(i/2),u=a(r/2),c=o(s/2),d=o(i/2),p=o(r/2);switch(n){case"XYZ":this._x=c*l*u+h*d*p,this._y=h*d*u-c*l*p,this._z=h*l*p+c*d*u,this._w=h*l*u-c*d*p;break;case"YXZ":this._x=c*l*u+h*d*p,this._y=h*d*u-c*l*p,this._z=h*l*p-c*d*u,this._w=h*l*u+c*d*p;break;case"ZXY":this._x=c*l*u-h*d*p,this._y=h*d*u+c*l*p,this._z=h*l*p+c*d*u,this._w=h*l*u-c*d*p;break;case"ZYX":this._x=c*l*u-h*d*p,this._y=h*d*u+c*l*p,this._z=h*l*p-c*d*u,this._w=h*l*u+c*d*p;break;case"YZX":this._x=c*l*u+h*d*p,this._y=h*d*u+c*l*p,this._z=h*l*p-c*d*u,this._w=h*l*u-c*d*p;break;case"XZY":this._x=c*l*u-h*d*p,this._y=h*d*u-c*l*p,this._z=h*l*p+c*d*u,this._w=h*l*u+c*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+n)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,i=Math.sin(s);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],i=e[4],r=e[8],n=e[1],a=e[5],o=e[9],h=e[2],l=e[6],u=e[10],c=s+a+u;if(c>0){const t=.5/Math.sqrt(c+1);this._w=.25/t,this._x=(l-o)*t,this._y=(r-h)*t,this._z=(n-i)*t}else if(s>a&&s>u){const t=2*Math.sqrt(1+s-a-u);this._w=(l-o)/t,this._x=.25*t,this._y=(i+n)/t,this._z=(r+h)/t}else if(a>u){const t=2*Math.sqrt(1+a-s-u);this._w=(r-h)/t,this._x=(i+n)/t,this._y=.25*t,this._z=(o+l)/t}else{const t=2*Math.sqrt(1+u-s-a);this._w=(n-i)/t,this._x=(r+h)/t,this._y=(o+l)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<Number.EPSILON?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(v(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(0===s)return this;const i=Math.min(1,e/s);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,i=t._y,r=t._z,n=t._w,a=e._x,o=e._y,h=e._z,l=e._w;return this._x=s*l+n*a+i*h-r*o,this._y=i*l+n*o+r*a-s*h,this._z=r*l+n*h+s*o-i*a,this._w=n*l-s*a-i*o-r*h,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const s=this._x,i=this._y,r=this._z,n=this._w;let a=n*t._w+s*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=n,this._x=s,this._y=i,this._z=r,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*n+e*this._w,this._x=t*s+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this}const h=Math.sqrt(o),l=Math.atan2(h,a),u=Math.sin((1-e)*l)/h,c=Math.sin(e*l)/h;return this._w=n*u+this._w*c,this._x=s*u+this._x*c,this._y=i*u+this._y*c,this._z=r*u+this._z*c,this._onChangeCallback(),this}slerpQuaternions(t,e,s){return this.copy(t).slerp(e,s)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),s=Math.random(),i=Math.sqrt(1-s),r=Math.sqrt(s);return this.set(i*Math.sin(t),i*Math.cos(t),r*Math.sin(e),r*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class X{constructor(t=0,e=0,s=0){X.prototype.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return void 0===s&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Y.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Y.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*s+r[6]*i,this.y=r[1]*e+r[4]*s+r[7]*i,this.z=r[2]*e+r[5]*s+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=t.elements,n=1/(r[3]*e+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*i+r[12])*n,this.y=(r[1]*e+r[5]*s+r[9]*i+r[13])*n,this.z=(r[2]*e+r[6]*s+r[10]*i+r[14])*n,this}applyQuaternion(t){const e=this.x,s=this.y,i=this.z,r=t.x,n=t.y,a=t.z,o=t.w,h=2*(n*i-a*s),l=2*(a*e-r*i),u=2*(r*s-n*e);return this.x=e+o*h+n*u-a*l,this.y=s+o*l+a*h-r*u,this.z=i+o*u+r*l-n*h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i,this.y=r[1]*e+r[5]*s+r[9]*i,this.z=r[2]*e+r[6]*s+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=v(this.x,t.x,e.x),this.y=v(this.y,t.y,e.y),this.z=v(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=v(this.x,t,e),this.y=v(this.y,t,e),this.z=v(this.z,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(v(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,i=t.y,r=t.z,n=e.x,a=e.y,o=e.z;return this.x=i*o-r*a,this.y=r*n-s*o,this.z=s*a-i*n,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return $.copy(this).projectOnVector(t),this.sub($)}reflect(t){return this.sub($.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(v(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,s=Math.sqrt(1-e*e);return this.x=s*Math.cos(t),this.y=e,this.z=s*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const $=new X,Y=new G;class Z{constructor(t=new X(1/0,1/0,1/0),e=new X(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e+=3)this.expandByPoint(Q.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,s=t.count;e<s;e++)this.expandByPoint(Q.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=Q.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(void 0!==s){const i=s.getAttribute("position");if(!0===e&&void 0!==i&&!0!==t.isInstancedMesh)for(let e=0,s=i.count;e<s;e++)!0===t.isMesh?t.getVertexPosition(e,Q):Q.fromBufferAttribute(i,e),Q.applyMatrix4(t.matrixWorld),this.expandByPoint(Q);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),K.copy(t.boundingBox)):(null===s.boundingBox&&s.computeBoundingBox(),K.copy(s.boundingBox)),K.applyMatrix4(t.matrixWorld),this.union(K)}const i=t.children;for(let t=0,s=i.length;t<s;t++)this.expandByObject(i[t],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,Q),Q.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(at),ot.subVectors(this.max,at),tt.subVectors(t.a,at),et.subVectors(t.b,at),st.subVectors(t.c,at),it.subVectors(et,tt),rt.subVectors(st,et),nt.subVectors(tt,st);let e=[0,-it.z,it.y,0,-rt.z,rt.y,0,-nt.z,nt.y,it.z,0,-it.x,rt.z,0,-rt.x,nt.z,0,-nt.x,-it.y,it.x,0,-rt.y,rt.x,0,-nt.y,nt.x,0];return!!ut(e,tt,et,st,ot)&&(e=[1,0,0,0,1,0,0,0,1],!!ut(e,tt,et,st,ot)&&(ht.crossVectors(it,rt),e=[ht.x,ht.y,ht.z],ut(e,tt,et,st,ot)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Q).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(Q).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(J[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),J[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),J[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),J[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),J[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),J[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),J[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),J[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(J)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const J=[new X,new X,new X,new X,new X,new X,new X,new X],Q=new X,K=new Z,tt=new X,et=new X,st=new X,it=new X,rt=new X,nt=new X,at=new X,ot=new X,ht=new X,lt=new X;function ut(t,e,s,i,r){for(let n=0,a=t.length-3;n<=a;n+=3){lt.fromArray(t,n);const a=r.x*Math.abs(lt.x)+r.y*Math.abs(lt.y)+r.z*Math.abs(lt.z),o=e.dot(lt),h=s.dot(lt),l=i.dot(lt);if(Math.max(-Math.max(o,h,l),Math.min(o,h,l))>a)return!1}return!0}const ct=new Z,dt=new X,pt=new X;class mt{constructor(t=new X,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;void 0!==e?s.copy(e):ct.setFromPoints(t).getCenter(s);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,s.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;dt.subVectors(t,this.center);const e=dt.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),s=.5*(t-this.radius);this.center.addScaledVector(dt,s/t),this.radius+=s}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(pt.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(dt.copy(t.center).add(pt)),this.expandByPoint(dt.copy(t.center).sub(pt))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const gt=new X,yt=new X,ft=new X,xt=new X,bt=new X,vt=new X,wt=new X;class Tt{constructor(t=new X,e=new X(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,gt)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const s=e.dot(this.direction);return s<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=gt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(gt.copy(this.origin).addScaledVector(this.direction,e),gt.distanceToSquared(t))}distanceSqToSegment(t,e,s,i){yt.copy(t).add(e).multiplyScalar(.5),ft.copy(e).sub(t).normalize(),xt.copy(this.origin).sub(yt);const r=.5*t.distanceTo(e),n=-this.direction.dot(ft),a=xt.dot(this.direction),o=-xt.dot(ft),h=xt.lengthSq(),l=Math.abs(1-n*n);let u,c,d,p;if(l>0)if(u=n*o-a,c=n*a-o,p=r*l,u>=0)if(c>=-p)if(c<=p){const t=1/l;u*=t,c*=t,d=u*(u+n*c+2*a)+c*(n*u+c+2*o)+h}else c=r,u=Math.max(0,-(n*c+a)),d=-u*u+c*(c+2*o)+h;else c=-r,u=Math.max(0,-(n*c+a)),d=-u*u+c*(c+2*o)+h;else c<=-p?(u=Math.max(0,-(-n*r+a)),c=u>0?-r:Math.min(Math.max(-r,-o),r),d=-u*u+c*(c+2*o)+h):c<=p?(u=0,c=Math.min(Math.max(-r,-o),r),d=c*(c+2*o)+h):(u=Math.max(0,-(n*r+a)),c=u>0?r:Math.min(Math.max(-r,-o),r),d=-u*u+c*(c+2*o)+h);else c=n>0?-r:r,u=Math.max(0,-(n*c+a)),d=-u*u+c*(c+2*o)+h;return s&&s.copy(this.origin).addScaledVector(this.direction,u),i&&i.copy(yt).addScaledVector(ft,c),d}intersectSphere(t,e){gt.subVectors(t.center,this.origin);const s=gt.dot(this.direction),i=gt.dot(gt)-s*s,r=t.radius*t.radius;if(i>r)return null;const n=Math.sqrt(r-i),a=s-n,o=s+n;return o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const s=-(this.origin.dot(t.normal)+t.constant)/e;return s>=0?s:null}intersectPlane(t,e){const s=this.distanceToPlane(t);return null===s?null:this.at(s,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let s,i,r,n,a,o;const h=1/this.direction.x,l=1/this.direction.y,u=1/this.direction.z,c=this.origin;return h>=0?(s=(t.min.x-c.x)*h,i=(t.max.x-c.x)*h):(s=(t.max.x-c.x)*h,i=(t.min.x-c.x)*h),l>=0?(r=(t.min.y-c.y)*l,n=(t.max.y-c.y)*l):(r=(t.max.y-c.y)*l,n=(t.min.y-c.y)*l),s>n||r>i?null:((r>s||isNaN(s))&&(s=r),(n<i||isNaN(i))&&(i=n),u>=0?(a=(t.min.z-c.z)*u,o=(t.max.z-c.z)*u):(a=(t.max.z-c.z)*u,o=(t.min.z-c.z)*u),s>o||a>i?null:((a>s||s!=s)&&(s=a),(o<i||i!=i)&&(i=o),i<0?null:this.at(s>=0?s:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,gt)}intersectTriangle(t,e,s,i,r){bt.subVectors(e,t),vt.subVectors(s,t),wt.crossVectors(bt,vt);let n,a=this.direction.dot(wt);if(a>0){if(i)return null;n=1}else{if(!(a<0))return null;n=-1,a=-a}xt.subVectors(this.origin,t);const o=n*this.direction.dot(vt.crossVectors(xt,vt));if(o<0)return null;const h=n*this.direction.dot(bt.cross(xt));if(h<0)return null;if(o+h>a)return null;const l=-n*xt.dot(wt);return l<0?null:this.at(l/a,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Nt{constructor(t,e,s,i,r,n,a,o,h,l,u,c,d,p,m,g){Nt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,s,i,r,n,a,o,h,l,u,c,d,p,m,g)}set(t,e,s,i,r,n,a,o,h,l,u,c,d,p,m,g){const y=this.elements;return y[0]=t,y[4]=e,y[8]=s,y[12]=i,y[1]=r,y[5]=n,y[9]=a,y[13]=o,y[2]=h,y[6]=l,y[10]=u,y[14]=c,y[3]=d,y[7]=p,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Nt).fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,i=1/Mt.setFromMatrixColumn(t,0).length(),r=1/Mt.setFromMatrixColumn(t,1).length(),n=1/Mt.setFromMatrixColumn(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=0,e[4]=s[4]*r,e[5]=s[5]*r,e[6]=s[6]*r,e[7]=0,e[8]=s[8]*n,e[9]=s[9]*n,e[10]=s[10]*n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,s=t.x,i=t.y,r=t.z,n=Math.cos(s),a=Math.sin(s),o=Math.cos(i),h=Math.sin(i),l=Math.cos(r),u=Math.sin(r);if("XYZ"===t.order){const t=n*l,s=n*u,i=a*l,r=a*u;e[0]=o*l,e[4]=-o*u,e[8]=h,e[1]=s+i*h,e[5]=t-r*h,e[9]=-a*o,e[2]=r-t*h,e[6]=i+s*h,e[10]=n*o}else if("YXZ"===t.order){const t=o*l,s=o*u,i=h*l,r=h*u;e[0]=t+r*a,e[4]=i*a-s,e[8]=n*h,e[1]=n*u,e[5]=n*l,e[9]=-a,e[2]=s*a-i,e[6]=r+t*a,e[10]=n*o}else if("ZXY"===t.order){const t=o*l,s=o*u,i=h*l,r=h*u;e[0]=t-r*a,e[4]=-n*u,e[8]=i+s*a,e[1]=s+i*a,e[5]=n*l,e[9]=r-t*a,e[2]=-n*h,e[6]=a,e[10]=n*o}else if("ZYX"===t.order){const t=n*l,s=n*u,i=a*l,r=a*u;e[0]=o*l,e[4]=i*h-s,e[8]=t*h+r,e[1]=o*u,e[5]=r*h+t,e[9]=s*h-i,e[2]=-h,e[6]=a*o,e[10]=n*o}else if("YZX"===t.order){const t=n*o,s=n*h,i=a*o,r=a*h;e[0]=o*l,e[4]=r-t*u,e[8]=i*u+s,e[1]=u,e[5]=n*l,e[9]=-a*l,e[2]=-h*l,e[6]=s*u+i,e[10]=t-r*u}else if("XZY"===t.order){const t=n*o,s=n*h,i=a*o,r=a*h;e[0]=o*l,e[4]=-u,e[8]=h*l,e[1]=t*u+r,e[5]=n*l,e[9]=s*u-i,e[2]=i*u-s,e[6]=a*l,e[10]=r*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(St,t,At)}lookAt(t,e,s){const i=this.elements;return Ct.subVectors(t,e),0===Ct.lengthSq()&&(Ct.z=1),Ct.normalize(),Vt.crossVectors(s,Ct),0===Vt.lengthSq()&&(1===Math.abs(s.z)?Ct.x+=1e-4:Ct.z+=1e-4,Ct.normalize(),Vt.crossVectors(s,Ct)),Vt.normalize(),zt.crossVectors(Ct,Vt),i[0]=Vt.x,i[4]=zt.x,i[8]=Ct.x,i[1]=Vt.y,i[5]=zt.y,i[9]=Ct.y,i[2]=Vt.z,i[6]=zt.z,i[10]=Ct.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],a=s[4],o=s[8],h=s[12],l=s[1],u=s[5],c=s[9],d=s[13],p=s[2],m=s[6],g=s[10],y=s[14],f=s[3],x=s[7],b=s[11],v=s[15],w=i[0],T=i[4],N=i[8],M=i[12],_=i[1],S=i[5],A=i[9],V=i[13],z=i[2],C=i[6],R=i[10],E=i[14],I=i[3],O=i[7],L=i[11],B=i[15];return r[0]=n*w+a*_+o*z+h*I,r[4]=n*T+a*S+o*C+h*O,r[8]=n*N+a*A+o*R+h*L,r[12]=n*M+a*V+o*E+h*B,r[1]=l*w+u*_+c*z+d*I,r[5]=l*T+u*S+c*C+d*O,r[9]=l*N+u*A+c*R+d*L,r[13]=l*M+u*V+c*E+d*B,r[2]=p*w+m*_+g*z+y*I,r[6]=p*T+m*S+g*C+y*O,r[10]=p*N+m*A+g*R+y*L,r[14]=p*M+m*V+g*E+y*B,r[3]=f*w+x*_+b*z+v*I,r[7]=f*T+x*S+b*C+v*O,r[11]=f*N+x*A+b*R+v*L,r[15]=f*M+x*V+b*E+v*B,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],i=t[8],r=t[12],n=t[1],a=t[5],o=t[9],h=t[13],l=t[2],u=t[6],c=t[10],d=t[14];return t[3]*(+r*o*u-i*h*u-r*a*c+s*h*c+i*a*d-s*o*d)+t[7]*(+e*o*d-e*h*c+r*n*c-i*n*d+i*h*l-r*o*l)+t[11]*(+e*h*u-e*a*d-r*n*u+s*n*d+r*a*l-s*h*l)+t[15]*(-i*a*l-e*o*u+e*a*c+i*n*u-s*n*c+s*o*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],n=t[4],a=t[5],o=t[6],h=t[7],l=t[8],u=t[9],c=t[10],d=t[11],p=t[12],m=t[13],g=t[14],y=t[15],f=u*g*h-m*c*h+m*o*d-a*g*d-u*o*y+a*c*y,x=p*c*h-l*g*h-p*o*d+n*g*d+l*o*y-n*c*y,b=l*m*h-p*u*h+p*a*d-n*m*d-l*a*y+n*u*y,v=p*u*o-l*m*o-p*a*c+n*m*c+l*a*g-n*u*g,w=e*f+s*x+i*b+r*v;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/w;return t[0]=f*T,t[1]=(m*c*r-u*g*r-m*i*d+s*g*d+u*i*y-s*c*y)*T,t[2]=(a*g*r-m*o*r+m*i*h-s*g*h-a*i*y+s*o*y)*T,t[3]=(u*o*r-a*c*r-u*i*h+s*c*h+a*i*d-s*o*d)*T,t[4]=x*T,t[5]=(l*g*r-p*c*r+p*i*d-e*g*d-l*i*y+e*c*y)*T,t[6]=(p*o*r-n*g*r-p*i*h+e*g*h+n*i*y-e*o*y)*T,t[7]=(n*c*r-l*o*r+l*i*h-e*c*h-n*i*d+e*o*d)*T,t[8]=b*T,t[9]=(p*u*r-l*m*r-p*s*d+e*m*d+l*s*y-e*u*y)*T,t[10]=(n*m*r-p*a*r+p*s*h-e*m*h-n*s*y+e*a*y)*T,t[11]=(l*a*r-n*u*r-l*s*h+e*u*h+n*s*d-e*a*d)*T,t[12]=v*T,t[13]=(l*m*i-p*u*i+p*s*c-e*m*c-l*s*g+e*u*g)*T,t[14]=(p*a*i-n*m*i-p*s*o+e*m*o+n*s*g-e*a*g)*T,t[15]=(n*u*i-l*a*i+l*s*o-e*u*o-n*s*c+e*a*c)*T,this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}makeTranslation(t,e,s){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),r=1-s,n=t.x,a=t.y,o=t.z,h=r*n,l=r*a;return this.set(h*n+s,h*a-i*o,h*o+i*a,0,h*a+i*o,l*a+s,l*o-i*n,0,h*o-i*a,l*o+i*n,r*o*o+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,r,n){return this.set(1,s,r,0,t,1,n,0,e,i,1,0,0,0,0,1),this}compose(t,e,s){const i=this.elements,r=e._x,n=e._y,a=e._z,o=e._w,h=r+r,l=n+n,u=a+a,c=r*h,d=r*l,p=r*u,m=n*l,g=n*u,y=a*u,f=o*h,x=o*l,b=o*u,v=s.x,w=s.y,T=s.z;return i[0]=(1-(m+y))*v,i[1]=(d+b)*v,i[2]=(p-x)*v,i[3]=0,i[4]=(d-b)*w,i[5]=(1-(c+y))*w,i[6]=(g+f)*w,i[7]=0,i[8]=(p+x)*T,i[9]=(g-f)*T,i[10]=(1-(c+m))*T,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){const i=this.elements;let r=Mt.set(i[0],i[1],i[2]).length();const n=Mt.set(i[4],i[5],i[6]).length(),a=Mt.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],_t.copy(this);const o=1/r,h=1/n,l=1/a;return _t.elements[0]*=o,_t.elements[1]*=o,_t.elements[2]*=o,_t.elements[4]*=h,_t.elements[5]*=h,_t.elements[6]*=h,_t.elements[8]*=l,_t.elements[9]*=l,_t.elements[10]*=l,e.setFromRotationMatrix(_t),s.x=r,s.y=n,s.z=a,this}makePerspective(t,e,s,i,r,n,a=2e3){const o=this.elements,h=2*r/(e-t),l=2*r/(s-i),u=(e+t)/(e-t),c=(s+i)/(s-i);let m,g;if(a===d)m=-(n+r)/(n-r),g=-2*n*r/(n-r);else{if(a!==p)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);m=-n/(n-r),g=-n*r/(n-r)}return o[0]=h,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=l,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=m,o[14]=g,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,s,i,r,n,a=2e3){const o=this.elements,h=1/(e-t),l=1/(s-i),u=1/(n-r),c=(e+t)*h,m=(s+i)*l;let g,y;if(a===d)g=(n+r)*u,y=-2*u;else{if(a!==p)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);g=r*u,y=-1*u}return o[0]=2*h,o[4]=0,o[8]=0,o[12]=-c,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-m,o[2]=0,o[6]=0,o[10]=y,o[14]=-g,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<16;t++)if(e[t]!==s[t])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}const Mt=new X,_t=new Nt,St=new X(0,0,0),At=new X(1,1,1),Vt=new X,zt=new X,Ct=new X,Rt=new Nt,Et=new G;class It{constructor(t=0,e=0,s=0,i=It.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=s,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,i=this._order){return this._x=t,this._y=e,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const i=t.elements,r=i[0],n=i[4],a=i[8],o=i[1],h=i[5],l=i[9],u=i[2],c=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin(v(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,d),this._z=Math.atan2(-n,r)):(this._x=Math.atan2(c,h),this._z=0);break;case"YXZ":this._x=Math.asin(-v(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,h)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(v(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-n,h)):(this._y=0,this._z=Math.atan2(o,r));break;case"ZYX":this._y=Math.asin(-v(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(c,d),this._z=Math.atan2(o,r)):(this._x=0,this._z=Math.atan2(-n,h));break;case"YZX":this._z=Math.asin(v(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-l,h),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-v(n,-1,1)),Math.abs(n)<.9999999?(this._x=Math.atan2(c,h),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-l,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===s&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return Rt.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Rt,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Et.setFromEuler(this),this.setFromQuaternion(Et,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}It.DEFAULT_ORDER="XYZ";class Ot{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return 0!==(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let Lt=0;const Bt=new X,Ft=new G,Pt=new Nt,Dt=new X,kt=new X,Ut=new X,Wt=new G,jt=new X(1,0,0),qt=new X(0,1,0),Ht=new X(0,0,1),Gt={type:"added"},Xt={type:"removed"},$t={type:"childadded",child:null},Yt={type:"childremoved",child:null};class Zt extends m{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Lt++}),this.uuid=b(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Zt.DEFAULT_UP.clone();const t=new X,e=new It,s=new G,i=new X(1,1,1);e._onChange(function(){s.setFromEuler(e,!1)}),s._onChange(function(){e.setFromQuaternion(s,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Nt},normalMatrix:{value:new A}}),this.matrix=new Nt,this.matrixWorld=new Nt,this.matrixAutoUpdate=Zt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Ot,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Ft.setFromAxisAngle(t,e),this.quaternion.multiply(Ft),this}rotateOnWorldAxis(t,e){return Ft.setFromAxisAngle(t,e),this.quaternion.premultiply(Ft),this}rotateX(t){return this.rotateOnAxis(jt,t)}rotateY(t){return this.rotateOnAxis(qt,t)}rotateZ(t){return this.rotateOnAxis(Ht,t)}translateOnAxis(t,e){return Bt.copy(t).applyQuaternion(this.quaternion),this.position.add(Bt.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(jt,t)}translateY(t){return this.translateOnAxis(qt,t)}translateZ(t){return this.translateOnAxis(Ht,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Pt.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?Dt.copy(t):Dt.set(t,e,s);const i=this.parent;this.updateWorldMatrix(!0,!1),kt.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Pt.lookAt(kt,Dt,this.up):Pt.lookAt(Dt,kt,this.up),this.quaternion.setFromRotationMatrix(Pt),i&&(Pt.extractRotation(i.matrixWorld),Ft.setFromRotationMatrix(Pt),this.quaternion.premultiply(Ft.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(Gt),$t.child=t,this.dispatchEvent($t),$t.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Xt),Yt.child=t,this.dispatchEvent(Yt),Yt.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Pt.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),Pt.multiply(t.parent.matrixWorld)),t.applyMatrix4(Pt),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(Gt),$t.child=t,this.dispatchEvent($t),$t.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,i=this.children.length;s<i;s++){const i=this.children[s].getObjectByProperty(t,e);if(void 0!==i)return i}}getObjectsByProperty(t,e,s=[]){this[t]===e&&s.push(this);const i=this.children;for(let r=0,n=i.length;r<n;r++)i[r].getObjectsByProperty(t,e,s);return s}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(kt,t,Ut),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(kt,Wt,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,i=e.length;s<i;s++){e[s].updateMatrixWorld(t)}}updateWorldMatrix(t,e){const s=this.parent;if(!0===t&&null!==s&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===e){const t=this.children;for(let e=0,s=t.length;e<s;e++){t[e].updateWorldMatrix(!1,!0)}}}toJSON(t){const e=void 0===t||"string"==typeof t,s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,s){return void 0===e[s.uuid]&&(e[s.uuid]=s.toJSON(t)),s.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(t=>({boxInitialized:t.boxInitialized,boxMin:t.box.min.toArray(),boxMax:t.box.max.toArray(),sphereInitialized:t.sphereInitialized,sphereRadius:t.sphere.radius,sphereCenter:t.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(t),null!==this._colorsTexture&&(i.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),null!==this.boundingBox&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const s=e.shapes;if(Array.isArray(s))for(let e=0,i=s.length;e<i;e++){const i=s[e];r(t.shapes,i)}else r(t.shapes,s)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let s=0,i=this.material.length;s<i;s++)e.push(r(t.materials,this.material[s]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const s=this.animations[e];i.animations.push(r(t.animations,s))}}if(e){const e=n(t.geometries),i=n(t.materials),r=n(t.textures),a=n(t.images),o=n(t.shapes),h=n(t.skeletons),l=n(t.animations),u=n(t.nodes);e.length>0&&(s.geometries=e),i.length>0&&(s.materials=i),r.length>0&&(s.textures=r),a.length>0&&(s.images=a),o.length>0&&(s.shapes=o),h.length>0&&(s.skeletons=h),l.length>0&&(s.animations=l),u.length>0&&(s.nodes=u)}return s.object=i,s;function n(t){const e=[];for(const s in t){const i=t[s];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const s=t.children[e];this.add(s.clone())}return this}}Zt.DEFAULT_UP=new X(0,1,0),Zt.DEFAULT_MATRIX_AUTO_UPDATE=!0,Zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Jt=new X,Qt=new X,Kt=new X,te=new X,ee=new X,se=new X,ie=new X,re=new X,ne=new X,ae=new X,oe=new j,he=new j,le=new j;class ue{constructor(t=new X,e=new X,s=new X){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,i){i.subVectors(s,e),Jt.subVectors(t,e),i.cross(Jt);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,s,i,r){Jt.subVectors(i,e),Qt.subVectors(s,e),Kt.subVectors(t,e);const n=Jt.dot(Jt),a=Jt.dot(Qt),o=Jt.dot(Kt),h=Qt.dot(Qt),l=Qt.dot(Kt),u=n*h-a*a;if(0===u)return r.set(0,0,0),null;const c=1/u,d=(h*o-a*l)*c,p=(n*l-a*o)*c;return r.set(1-d-p,p,d)}static containsPoint(t,e,s,i){return null!==this.getBarycoord(t,e,s,i,te)&&(te.x>=0&&te.y>=0&&te.x+te.y<=1)}static getInterpolation(t,e,s,i,r,n,a,o){return null===this.getBarycoord(t,e,s,i,te)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(r,te.x),o.addScaledVector(n,te.y),o.addScaledVector(a,te.z),o)}static getInterpolatedAttribute(t,e,s,i,r,n){return oe.setScalar(0),he.setScalar(0),le.setScalar(0),oe.fromBufferAttribute(t,e),he.fromBufferAttribute(t,s),le.fromBufferAttribute(t,i),n.setScalar(0),n.addScaledVector(oe,r.x),n.addScaledVector(he,r.y),n.addScaledVector(le,r.z),n}static isFrontFacing(t,e,s,i){return Jt.subVectors(s,e),Qt.subVectors(t,e),Jt.cross(Qt).dot(i)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,i){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,s,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Jt.subVectors(this.c,this.b),Qt.subVectors(this.a,this.b),.5*Jt.cross(Qt).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ue.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ue.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,s,i,r){return ue.getInterpolation(t,this.a,this.b,this.c,e,s,i,r)}containsPoint(t){return ue.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ue.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,i=this.b,r=this.c;let n,a;ee.subVectors(i,s),se.subVectors(r,s),re.subVectors(t,s);const o=ee.dot(re),h=se.dot(re);if(o<=0&&h<=0)return e.copy(s);ne.subVectors(t,i);const l=ee.dot(ne),u=se.dot(ne);if(l>=0&&u<=l)return e.copy(i);const c=o*u-l*h;if(c<=0&&o>=0&&l<=0)return n=o/(o-l),e.copy(s).addScaledVector(ee,n);ae.subVectors(t,r);const d=ee.dot(ae),p=se.dot(ae);if(p>=0&&d<=p)return e.copy(r);const m=d*h-o*p;if(m<=0&&h>=0&&p<=0)return a=h/(h-p),e.copy(s).addScaledVector(se,a);const g=l*p-d*u;if(g<=0&&u-l>=0&&d-p>=0)return ie.subVectors(r,i),a=(u-l)/(u-l+(d-p)),e.copy(i).addScaledVector(ie,a);const y=1/(g+m+c);return n=m*y,a=c*y,e.copy(s).addScaledVector(ee,n).addScaledVector(se,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const ce={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},de={h:0,s:0,l:0},pe={h:0,s:0,l:0};function me(t,e,s){return s<0&&(s+=1),s>1&&(s-=1),s<1/6?t+6*(e-t)*s:s<.5?e:s<2/3?t+6*(e-t)*(2/3-s):t}class ge{constructor(t,e,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,s)}set(t,e,s){if(void 0===e&&void 0===s){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,s);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=n){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,I.toWorkingColorSpace(this,e),this}setRGB(t,e,s,i=I.workingColorSpace){return this.r=t,this.g=e,this.b=s,I.toWorkingColorSpace(this,i),this}setHSL(t,e,s,i=I.workingColorSpace){if(t=w(t,1),e=v(e,0,1),s=v(s,0,1),0===e)this.r=this.g=this.b=s;else{const i=s<=.5?s*(1+e):s+e-s*e,r=2*s-i;this.r=me(r,i,t+1/3),this.g=me(r,i,t),this.b=me(r,i,t-1/3)}return I.toWorkingColorSpace(this,i),this}setStyle(t,e=n){function s(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const n=i[1],a=i[2];switch(n){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=i[1],r=s.length;if(3===r)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,e);if(6===r)return this.setHex(parseInt(s,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=n){const s=ce[t.toLowerCase()];return void 0!==s?this.setHex(s,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=O(t.r),this.g=O(t.g),this.b=O(t.b),this}copyLinearToSRGB(t){return this.r=L(t.r),this.g=L(t.g),this.b=L(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=n){return I.fromWorkingColorSpace(ye.copy(this),t),65536*Math.round(v(255*ye.r,0,255))+256*Math.round(v(255*ye.g,0,255))+Math.round(v(255*ye.b,0,255))}getHexString(t=n){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=I.workingColorSpace){I.fromWorkingColorSpace(ye.copy(this),e);const s=ye.r,i=ye.g,r=ye.b,n=Math.max(s,i,r),a=Math.min(s,i,r);let o,h;const l=(a+n)/2;if(a===n)o=0,h=0;else{const t=n-a;switch(h=l<=.5?t/(n+a):t/(2-n-a),n){case s:o=(i-r)/t+(i<r?6:0);break;case i:o=(r-s)/t+2;break;case r:o=(s-i)/t+4}o/=6}return t.h=o,t.s=h,t.l=l,t}getRGB(t,e=I.workingColorSpace){return I.fromWorkingColorSpace(ye.copy(this),e),t.r=ye.r,t.g=ye.g,t.b=ye.b,t}getStyle(t=n){I.fromWorkingColorSpace(ye.copy(this),t);const e=ye.r,s=ye.g,i=ye.b;return t!==n?`color(${t} ${e.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*s)},${Math.round(255*i)})`}offsetHSL(t,e,s){return this.getHSL(de),this.setHSL(de.h+t,de.s+e,de.l+s)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,s){return this.r=t.r+(e.r-t.r)*s,this.g=t.g+(e.g-t.g)*s,this.b=t.b+(e.b-t.b)*s,this}lerpHSL(t,e){this.getHSL(de),t.getHSL(pe);const s=T(de.h,pe.h,e),i=T(de.s,pe.s,e),r=T(de.l,pe.l,e);return this.setHSL(s,i,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,s=this.g,i=this.b,r=t.elements;return this.r=r[0]*e+r[3]*s+r[6]*i,this.g=r[1]*e+r[4]*s+r[7]*i,this.b=r[2]*e+r[5]*s+r[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ye=new ge;ge.NAMES=ce;let fe=0;class xe extends m{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:fe++}),this.uuid=b(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ge(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=l,this.stencilZFail=l,this.stencilZPass=l,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const s=t[e];if(void 0===s){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[e]=s:console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const s in t){const i=t[s];delete i.metadata,e.push(i)}return e}if(s.uuid=this.uuid,s.type=this.type,""!==this.name&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),void 0!==this.roughness&&(s.roughness=this.roughness),void 0!==this.metalness&&(s.metalness=this.metalness),void 0!==this.sheen&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(s.shininess=this.shininess),void 0!==this.clearcoat&&(s.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(s.dispersion=this.dispersion),void 0!==this.iridescence&&(s.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(s.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(s.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(t).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(t).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(t).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(t).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(t).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(s.combine=this.combine)),void 0!==this.envMapRotation&&(s.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(s.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(s.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(s.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(s.size=this.size),null!==this.shadowSide&&(s.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(s.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(s.blending=this.blending),0!==this.side&&(s.side=this.side),!0===this.vertexColors&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),!0===this.transparent&&(s.transparent=!0),204!==this.blendSrc&&(s.blendSrc=this.blendSrc),205!==this.blendDst&&(s.blendDst=this.blendDst),100!==this.blendEquation&&(s.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(s.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(s.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(s.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(s.depthFunc=this.depthFunc),!1===this.depthTest&&(s.depthTest=this.depthTest),!1===this.depthWrite&&(s.depthWrite=this.depthWrite),!1===this.colorWrite&&(s.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(s.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(s.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(s.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==l&&(s.stencilFail=this.stencilFail),this.stencilZFail!==l&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==l&&(s.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(s.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(s.rotation=this.rotation),!0===this.polygonOffset&&(s.polygonOffset=!0),0!==this.polygonOffsetFactor&&(s.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(s.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(s.linewidth=this.linewidth),void 0!==this.dashSize&&(s.dashSize=this.dashSize),void 0!==this.gapSize&&(s.gapSize=this.gapSize),void 0!==this.scale&&(s.scale=this.scale),!0===this.dithering&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),!0===this.alphaHash&&(s.alphaHash=!0),!0===this.alphaToCoverage&&(s.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(s.premultipliedAlpha=!0),!0===this.forceSinglePass&&(s.forceSinglePass=!0),!0===this.wireframe&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(s.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(s.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(s.flatShading=!0),!1===this.visible&&(s.visible=!1),!1===this.toneMapped&&(s.toneMapped=!1),!1===this.fog&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(s.textures=e),r.length>0&&(s.images=r)}return s}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let s=null;if(null!==e){const t=e.length;s=new Array(t);for(let i=0;i!==t;++i)s[i]=e[i].clone()}return this.clippingPlanes=s,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class be extends xe{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ge(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new It,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const ve=new X,we=new S;let Te=0;class Ne{constructor(t,e,s=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:Te++}),this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=s,this.usage=u,this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[s+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,s=this.count;e<s;e++)we.fromBufferAttribute(this,e),we.applyMatrix3(t),this.setXY(e,we.x,we.y);else if(3===this.itemSize)for(let e=0,s=this.count;e<s;e++)ve.fromBufferAttribute(this,e),ve.applyMatrix3(t),this.setXYZ(e,ve.x,ve.y,ve.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)ve.fromBufferAttribute(this,e),ve.applyMatrix4(t),this.setXYZ(e,ve.x,ve.y,ve.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)ve.fromBufferAttribute(this,e),ve.applyNormalMatrix(t),this.setXYZ(e,ve.x,ve.y,ve.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)ve.fromBufferAttribute(this,e),ve.transformDirection(t),this.setXYZ(e,ve.x,ve.y,ve.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let s=this.array[t*this.itemSize+e];return this.normalized&&(s=N(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=M(s,this.array)),this.array[t*this.itemSize+e]=s,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=N(e,this.array)),e}setX(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=N(e,this.array)),e}setY(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=N(e,this.array)),e}setZ(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=N(e,this.array)),e}setW(t,e){return this.normalized&&(e=M(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=M(e,this.array),s=M(s,this.array)),this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,i){return t*=this.itemSize,this.normalized&&(e=M(e,this.array),s=M(s,this.array),i=M(i,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this}setXYZW(t,e,s,i,r){return t*=this.itemSize,this.normalized&&(e=M(e,this.array),s=M(s,this.array),i=M(i,this.array),r=M(r,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==u&&(t.usage=this.usage),t}}class Me extends Ne{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class _e extends Ne{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class Se extends Ne{constructor(t,e,s){super(new Float32Array(t),e,s)}}let Ae=0;const Ve=new Nt,ze=new Zt,Ce=new X,Re=new Z,Ee=new Z,Ie=new X;class Oe extends m{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ae++}),this.uuid=b(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(function(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}(t)?_e:Me)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(void 0!==s){const e=(new A).getNormalMatrix(t);s.applyNormalMatrix(e),s.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Ve.makeRotationFromQuaternion(t),this.applyMatrix4(Ve),this}rotateX(t){return Ve.makeRotationX(t),this.applyMatrix4(Ve),this}rotateY(t){return Ve.makeRotationY(t),this.applyMatrix4(Ve),this}rotateZ(t){return Ve.makeRotationZ(t),this.applyMatrix4(Ve),this}translate(t,e,s){return Ve.makeTranslation(t,e,s),this.applyMatrix4(Ve),this}scale(t,e,s){return Ve.makeScale(t,e,s),this.applyMatrix4(Ve),this}lookAt(t){return ze.lookAt(t),ze.updateMatrix(),this.applyMatrix4(ze.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ce).negate(),this.translate(Ce.x,Ce.y,Ce.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let s=0,i=t.length;s<i;s++){const i=t[s];e.push(i.x,i.y,i.z||0)}this.setAttribute("position",new Se(e,3))}else{const s=Math.min(t.length,e.count);for(let i=0;i<s;i++){const s=t[i];e.setXYZ(i,s.x,s.y,s.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Z);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new X(-1/0,-1/0,-1/0),new X(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,s=e.length;t<s;t++){const s=e[t];Re.setFromBufferAttribute(s),this.morphTargetsRelative?(Ie.addVectors(this.boundingBox.min,Re.min),this.boundingBox.expandByPoint(Ie),Ie.addVectors(this.boundingBox.max,Re.max),this.boundingBox.expandByPoint(Ie)):(this.boundingBox.expandByPoint(Re.min),this.boundingBox.expandByPoint(Re.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new mt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new X,1/0);if(t){const s=this.boundingSphere.center;if(Re.setFromBufferAttribute(t),e)for(let t=0,s=e.length;t<s;t++){const s=e[t];Ee.setFromBufferAttribute(s),this.morphTargetsRelative?(Ie.addVectors(Re.min,Ee.min),Re.expandByPoint(Ie),Ie.addVectors(Re.max,Ee.max),Re.expandByPoint(Ie)):(Re.expandByPoint(Ee.min),Re.expandByPoint(Ee.max))}Re.getCenter(s);let i=0;for(let e=0,r=t.count;e<r;e++)Ie.fromBufferAttribute(t,e),i=Math.max(i,s.distanceToSquared(Ie));if(e)for(let r=0,n=e.length;r<n;r++){const n=e[r],a=this.morphTargetsRelative;for(let e=0,r=n.count;e<r;e++)Ie.fromBufferAttribute(n,e),a&&(Ce.fromBufferAttribute(t,e),Ie.add(Ce)),i=Math.max(i,s.distanceToSquared(Ie))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const s=e.position,i=e.normal,r=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Ne(new Float32Array(4*s.count),4));const n=this.getAttribute("tangent"),a=[],o=[];for(let t=0;t<s.count;t++)a[t]=new X,o[t]=new X;const h=new X,l=new X,u=new X,c=new S,d=new S,p=new S,m=new X,g=new X;function y(t,e,i){h.fromBufferAttribute(s,t),l.fromBufferAttribute(s,e),u.fromBufferAttribute(s,i),c.fromBufferAttribute(r,t),d.fromBufferAttribute(r,e),p.fromBufferAttribute(r,i),l.sub(h),u.sub(h),d.sub(c),p.sub(c);const n=1/(d.x*p.y-p.x*d.y);isFinite(n)&&(m.copy(l).multiplyScalar(p.y).addScaledVector(u,-d.y).multiplyScalar(n),g.copy(u).multiplyScalar(d.x).addScaledVector(l,-p.x).multiplyScalar(n),a[t].add(m),a[e].add(m),a[i].add(m),o[t].add(g),o[e].add(g),o[i].add(g))}let f=this.groups;0===f.length&&(f=[{start:0,count:t.count}]);for(let e=0,s=f.length;e<s;++e){const s=f[e],i=s.start;for(let e=i,r=i+s.count;e<r;e+=3)y(t.getX(e+0),t.getX(e+1),t.getX(e+2))}const x=new X,b=new X,v=new X,w=new X;function T(t){v.fromBufferAttribute(i,t),w.copy(v);const e=a[t];x.copy(e),x.sub(v.multiplyScalar(v.dot(e))).normalize(),b.crossVectors(w,e);const s=b.dot(o[t])<0?-1:1;n.setXYZW(t,x.x,x.y,x.z,s)}for(let e=0,s=f.length;e<s;++e){const s=f[e],i=s.start;for(let e=i,r=i+s.count;e<r;e+=3)T(t.getX(e+0)),T(t.getX(e+1)),T(t.getX(e+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let s=this.getAttribute("normal");if(void 0===s)s=new Ne(new Float32Array(3*e.count),3),this.setAttribute("normal",s);else for(let t=0,e=s.count;t<e;t++)s.setXYZ(t,0,0,0);const i=new X,r=new X,n=new X,a=new X,o=new X,h=new X,l=new X,u=new X;if(t)for(let c=0,d=t.count;c<d;c+=3){const d=t.getX(c+0),p=t.getX(c+1),m=t.getX(c+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),n.fromBufferAttribute(e,m),l.subVectors(n,r),u.subVectors(i,r),l.cross(u),a.fromBufferAttribute(s,d),o.fromBufferAttribute(s,p),h.fromBufferAttribute(s,m),a.add(l),o.add(l),h.add(l),s.setXYZ(d,a.x,a.y,a.z),s.setXYZ(p,o.x,o.y,o.z),s.setXYZ(m,h.x,h.y,h.z)}else for(let t=0,a=e.count;t<a;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),n.fromBufferAttribute(e,t+2),l.subVectors(n,r),u.subVectors(i,r),l.cross(u),s.setXYZ(t+0,l.x,l.y,l.z),s.setXYZ(t+1,l.x,l.y,l.z),s.setXYZ(t+2,l.x,l.y,l.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)Ie.fromBufferAttribute(t,e),Ie.normalize(),t.setXYZ(e,Ie.x,Ie.y,Ie.z)}toNonIndexed(){function t(t,e){const s=t.array,i=t.itemSize,r=t.normalized,n=new s.constructor(e.length*i);let a=0,o=0;for(let r=0,h=e.length;r<h;r++){a=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)n[o++]=s[a++]}return new Ne(n,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Oe,s=this.index.array,i=this.attributes;for(const r in i){const n=t(i[r],s);e.setAttribute(r,n)}const r=this.morphAttributes;for(const i in r){const n=[],a=r[i];for(let e=0,i=a.length;e<i;e++){const i=t(a[e],s);n.push(i)}e.morphAttributes[i]=n}e.morphTargetsRelative=this.morphTargetsRelative;const n=this.groups;for(let t=0,s=n.length;t<s;t++){const s=n[t];e.addGroup(s.start,s.count,s.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const s in e)void 0!==e[s]&&(t[s]=e[s]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const e in s){const i=s[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const s=this.morphAttributes[e],n=[];for(let e=0,i=s.length;e<i;e++){const i=s[e];n.push(i.toJSON(t.data))}n.length>0&&(i[e]=n,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const n=this.groups;n.length>0&&(t.data.groups=JSON.parse(JSON.stringify(n)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;null!==s&&this.setIndex(s.clone(e));const i=t.attributes;for(const t in i){const s=i[t];this.setAttribute(t,s.clone(e))}const r=t.morphAttributes;for(const t in r){const s=[],i=r[t];for(let t=0,r=i.length;t<r;t++)s.push(i[t].clone(e));this.morphAttributes[t]=s}this.morphTargetsRelative=t.morphTargetsRelative;const n=t.groups;for(let t=0,e=n.length;t<e;t++){const e=n[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Le=new Nt,Be=new Tt,Fe=new mt,Pe=new X,De=new X,ke=new X,Ue=new X,We=new X,je=new X,qe=new X,He=new X;class Ge extends Zt{constructor(t=new Oe,e=new be){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const s=t[e[0]];if(void 0!==s){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=s.length;t<e;t++){const e=s[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const s=this.geometry,i=s.attributes.position,r=s.morphAttributes.position,n=s.morphTargetsRelative;e.fromBufferAttribute(i,t);const a=this.morphTargetInfluences;if(r&&a){je.set(0,0,0);for(let s=0,i=r.length;s<i;s++){const i=a[s],o=r[s];0!==i&&(We.fromBufferAttribute(o,t),n?je.addScaledVector(We,i):je.addScaledVector(We.sub(e),i))}e.add(je)}return e}raycast(t,e){const s=this.geometry,i=this.material,r=this.matrixWorld;if(void 0!==i){if(null===s.boundingSphere&&s.computeBoundingSphere(),Fe.copy(s.boundingSphere),Fe.applyMatrix4(r),Be.copy(t.ray).recast(t.near),!1===Fe.containsPoint(Be.origin)){if(null===Be.intersectSphere(Fe,Pe))return;if(Be.origin.distanceToSquared(Pe)>(t.far-t.near)**2)return}Le.copy(r).invert(),Be.copy(t.ray).applyMatrix4(Le),null!==s.boundingBox&&!1===Be.intersectsBox(s.boundingBox)||this._computeIntersections(t,e,Be)}}_computeIntersections(t,e,s){let i;const r=this.geometry,n=this.material,a=r.index,o=r.attributes.position,h=r.attributes.uv,l=r.attributes.uv1,u=r.attributes.normal,c=r.groups,d=r.drawRange;if(null!==a)if(Array.isArray(n))for(let r=0,o=c.length;r<o;r++){const o=c[r],p=n[o.materialIndex];for(let r=Math.max(o.start,d.start),n=Math.min(a.count,Math.min(o.start+o.count,d.start+d.count));r<n;r+=3){i=Xe(this,p,t,s,h,l,u,a.getX(r),a.getX(r+1),a.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=o.materialIndex,e.push(i))}}else{for(let r=Math.max(0,d.start),o=Math.min(a.count,d.start+d.count);r<o;r+=3){i=Xe(this,n,t,s,h,l,u,a.getX(r),a.getX(r+1),a.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}else if(void 0!==o)if(Array.isArray(n))for(let r=0,a=c.length;r<a;r++){const a=c[r],p=n[a.materialIndex];for(let r=Math.max(a.start,d.start),n=Math.min(o.count,Math.min(a.start+a.count,d.start+d.count));r<n;r+=3){i=Xe(this,p,t,s,h,l,u,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=a.materialIndex,e.push(i))}}else{for(let r=Math.max(0,d.start),a=Math.min(o.count,d.start+d.count);r<a;r+=3){i=Xe(this,n,t,s,h,l,u,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}}}function Xe(t,e,s,i,r,n,a,o,h,l){t.getVertexPosition(o,De),t.getVertexPosition(h,ke),t.getVertexPosition(l,Ue);const u=function(t,e,s,i,r,n,a,o){let h;if(h=1===e.side?i.intersectTriangle(a,n,r,!0,o):i.intersectTriangle(r,n,a,0===e.side,o),null===h)return null;He.copy(o),He.applyMatrix4(t.matrixWorld);const l=s.ray.origin.distanceTo(He);return l<s.near||l>s.far?null:{distance:l,point:He.clone(),object:t}}(t,e,s,i,De,ke,Ue,qe);if(u){const t=new X;ue.getBarycoord(qe,De,ke,Ue,t),r&&(u.uv=ue.getInterpolatedAttribute(r,o,h,l,t,new S)),n&&(u.uv1=ue.getInterpolatedAttribute(n,o,h,l,t,new S)),a&&(u.normal=ue.getInterpolatedAttribute(a,o,h,l,t,new X),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const e={a:o,b:h,c:l,normal:new X,materialIndex:0};ue.getNormal(De,ke,Ue,e.normal),u.face=e,u.barycoord=t}return u}class $e extends Oe{constructor(t=1,e=1,s=1,i=1,r=1,n=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:s,widthSegments:i,heightSegments:r,depthSegments:n};const a=this;i=Math.floor(i),r=Math.floor(r),n=Math.floor(n);const o=[],h=[],l=[],u=[];let c=0,d=0;function p(t,e,s,i,r,n,p,m,g,y,f){const x=n/g,b=p/y,v=n/2,w=p/2,T=m/2,N=g+1,M=y+1;let _=0,S=0;const A=new X;for(let n=0;n<M;n++){const a=n*b-w;for(let o=0;o<N;o++){const c=o*x-v;A[t]=c*i,A[e]=a*r,A[s]=T,h.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[s]=m>0?1:-1,l.push(A.x,A.y,A.z),u.push(o/g),u.push(1-n/y),_+=1}}for(let t=0;t<y;t++)for(let e=0;e<g;e++){const s=c+e+N*t,i=c+e+N*(t+1),r=c+(e+1)+N*(t+1),n=c+(e+1)+N*t;o.push(s,i,n),o.push(i,r,n),S+=6}a.addGroup(d,S,f),d+=S,c+=_}p("z","y","x",-1,-1,s,e,t,n,r,0),p("z","y","x",1,-1,s,e,-t,n,r,1),p("x","z","y",1,1,t,s,e,i,n,2),p("x","z","y",1,-1,t,s,-e,i,n,3),p("x","y","z",1,-1,t,e,s,i,r,4),p("x","y","z",-1,-1,t,e,-s,i,r,5),this.setIndex(o),this.setAttribute("position",new Se(h,3)),this.setAttribute("normal",new Se(l,3)),this.setAttribute("uv",new Se(u,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new $e(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}class Ye extends Zt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Nt,this.projectionMatrix=new Nt,this.projectionMatrixInverse=new Nt,this.coordinateSystem=d}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const Ze=new X,Je=new S,Qe=new S;class Ke extends Ye{constructor(t=50,e=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*x*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*f*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*x*Math.atan(Math.tan(.5*f*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,s){Ze.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Ze.x,Ze.y).multiplyScalar(-t/Ze.z),Ze.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(Ze.x,Ze.y).multiplyScalar(-t/Ze.z)}getViewSize(t,e){return this.getViewBounds(t,Je,Qe),e.subVectors(Qe,Je)}setViewOffset(t,e,s,i,r,n){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=n,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*f*this.fov)/this.zoom,s=2*e,i=this.aspect*s,r=-.5*i;const n=this.view;if(null!==this.view&&this.view.enabled){const t=n.fullWidth,a=n.fullHeight;r+=n.offsetX*i/t,e-=n.offsetY*s/a,i*=n.width/t,s*=n.height/a}const a=this.filmOffset;0!==a&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-s,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}class ts{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=u,this.updateRanges=[],this.version=0,this.uuid=b()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,s){t*=this.stride,s*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[s+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=b()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(e,this.stride);return s.setUsage(this.usage),s}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=b()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const es=new X;class ss{constructor(t,e,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=s,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,s=this.data.count;e<s;e++)es.fromBufferAttribute(this,e),es.applyMatrix4(t),this.setXYZ(e,es.x,es.y,es.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)es.fromBufferAttribute(this,e),es.applyNormalMatrix(t),this.setXYZ(e,es.x,es.y,es.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)es.fromBufferAttribute(this,e),es.transformDirection(t),this.setXYZ(e,es.x,es.y,es.z);return this}getComponent(t,e){let s=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(s=N(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=M(s,this.array)),this.data.array[t*this.data.stride+this.offset+e]=s,this}setX(t,e){return this.normalized&&(e=M(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=M(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=M(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=M(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=N(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=N(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=N(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=N(e,this.array)),e}setXY(t,e,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=M(e,this.array),s=M(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this}setXYZ(t,e,s,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=M(e,this.array),s=M(s,this.array),i=M(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=i,this}setXYZW(t,e,s,i,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=M(e,this.array),s=M(s,this.array),i=M(i,this.array),r=M(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const s=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[s+e])}return new Ne(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ss(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const s=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[s+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class is extends Ne{constructor(t,e,s,i=1){super(t,e,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const rs=new X,ns=new X,as=new A;class os extends W{constructor(t,s){super({width:t,height:s}),this.isFramebufferTexture=!0,this.magFilter=e,this.minFilter=e,this.generateMipmaps=!1,this.needsUpdate=!0}}class hs extends W{constructor(t,s,i,n,a,o,h,l,u,c=1026){if(c!==r&&1027!==c)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&c===r&&(i=1014),void 0===i&&1027===c&&(i=1020),super(null,n,a,o,h,l,c,i,u),this.isDepthTexture=!0,this.image={width:t,height:s},this.magFilter=void 0!==h?h:e,this.minFilter=void 0!==l?l:e,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.source=new D(Object.assign({},t.image)),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}class ls extends Ye{constructor(t=-1,e=1,s=1,i=-1,r=.1,n=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=s,this.bottom=i,this.near=r,this.far=n,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,s,i,r,n){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=n,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=s-t,n=s+t,a=i+e,o=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,n=r+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(r,n,a,o,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}class us extends ts{constructor(t,e,s=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class cs{constructor(t,e,s,i){cs.prototype.isMatrix2=!0,this.elements=[1,0,0,1],void 0!==t&&this.set(t,e,s,i)}identity(){return this.set(1,0,0,1),this}fromArray(t,e=0){for(let s=0;s<4;s++)this.elements[s]=t[s+e];return this}set(t,e,s,i){const r=this.elements;return r[0]=t,r[2]=e,r[1]=s,r[3]=i,this}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"174"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="174");const ds=["alphaMap","alphaTest","anisotropy","anisotropyMap","anisotropyRotation","aoMap","attenuationColor","attenuationDistance","bumpMap","clearcoat","clearcoatMap","clearcoatNormalMap","clearcoatNormalScale","clearcoatRoughness","color","dispersion","displacementMap","emissive","emissiveMap","envMap","gradientMap","ior","iridescence","iridescenceIOR","iridescenceMap","iridescenceThicknessMap","lightMap","map","matcap","metalness","metalnessMap","normalMap","normalScale","opacity","roughness","roughnessMap","sheen","sheenColor","sheenColorMap","sheenRoughnessMap","shininess","specular","specularColor","specularColorMap","specularIntensity","specularIntensityMap","specularMap","thickness","transmission","transmissionMap"];class ps{constructor(t){this.renderObjects=new WeakMap,this.hasNode=this.containsNode(t),this.hasAnimation=!0===t.object.isSkinnedMesh,this.refreshUniforms=ds,this.renderId=0}firstInitialization(t){return!1===this.renderObjects.has(t)&&(this.getRenderObjectData(t),!0)}getRenderObjectData(t){let e=this.renderObjects.get(t);if(void 0===e){const{geometry:s,material:i,object:r}=t;if(e={material:this.getMaterialData(i),geometry:{id:s.id,attributes:this.getAttributesData(s.attributes),indexVersion:s.index?s.index.version:null,drawRange:{start:s.drawRange.start,count:s.drawRange.count}},worldMatrix:r.matrixWorld.clone()},r.center&&(e.center=r.center.clone()),r.morphTargetInfluences&&(e.morphTargetInfluences=r.morphTargetInfluences.slice()),null!==t.bundle&&(e.version=t.bundle.version),e.material.transmission>0){const{width:s,height:i}=t.context;e.bufferWidth=s,e.bufferHeight=i}this.renderObjects.set(t,e)}return e}getAttributesData(t){const e={};for(const s in t){const i=t[s];e[s]={version:i.version}}return e}containsNode(t){const e=t.material;for(const t in e)if(e[t]&&e[t].isNode)return!0;return null!==t.renderer.nodes.modelViewMatrix||null!==t.renderer.nodes.modelNormalViewMatrix}getMaterialData(t){const e={};for(const s of this.refreshUniforms){const i=t[s];null!=i&&("object"==typeof i&&void 0!==i.clone?!0===i.isTexture?e[s]={id:i.id,version:i.version}:e[s]=i.clone():e[s]=i)}return e}equals(t){const{object:e,material:s,geometry:i}=t,r=this.getRenderObjectData(t);if(!0!==r.worldMatrix.equals(e.matrixWorld))return r.worldMatrix.copy(e.matrixWorld),!1;const n=r.material;for(const t in n){const e=n[t],i=s[t];if(void 0!==e.equals){if(!1===e.equals(i))return e.copy(i),!1}else if(!0===i.isTexture){if(e.id!==i.id||e.version!==i.version)return e.id=i.id,e.version=i.version,!1}else if(e!==i)return n[t]=i,!1}if(n.transmission>0){const{width:e,height:s}=t.context;if(r.bufferWidth!==e||r.bufferHeight!==s)return r.bufferWidth=e,r.bufferHeight=s,!1}const a=r.geometry,o=i.attributes,h=a.attributes,l=Object.keys(h),u=Object.keys(o);if(a.id!==i.id)return a.id=i.id,!1;if(l.length!==u.length)return r.geometry.attributes=this.getAttributesData(o),!1;for(const t of l){const e=h[t],s=o[t];if(void 0===s)return delete h[t],!1;if(e.version!==s.version)return e.version=s.version,!1}const c=i.index,d=a.indexVersion,p=c?c.version:null;if(d!==p)return a.indexVersion=p,!1;if(a.drawRange.start!==i.drawRange.start||a.drawRange.count!==i.drawRange.count)return a.drawRange.start=i.drawRange.start,a.drawRange.count=i.drawRange.count,!1;if(r.morphTargetInfluences){let t=!1;for(let s=0;s<r.morphTargetInfluences.length;s++)r.morphTargetInfluences[s]!==e.morphTargetInfluences[s]&&(t=!0);if(t)return!0}return r.center&&!1===r.center.equals(e.center)?(r.center.copy(e.center),!0):(null!==t.bundle&&(r.version=t.bundle.version),!0)}needsRefresh(t,e){if(this.hasNode||this.hasAnimation||this.firstInitialization(t))return!0;const{renderId:s}=e;if(this.renderId!==s)return this.renderId=s,!0;const i=!0===t.object.static,r=null!==t.bundle&&!0===t.bundle.static&&this.getRenderObjectData(t).version===t.bundle.version;if(i||r)return!1;return!0!==this.equals(t)}}function ms(t,e=0){let s=3735928559^e,i=1103547991^e;if(t instanceof Array)for(let e,r=0;r<t.length;r++)e=t[r],s=Math.imul(s^e,2654435761),i=Math.imul(i^e,1597334677);else for(let e,r=0;r<t.length;r++)e=t.charCodeAt(r),s=Math.imul(s^e,2654435761),i=Math.imul(i^e,1597334677);return s=Math.imul(s^s>>>16,2246822507),s^=Math.imul(i^i>>>13,3266489909),i=Math.imul(i^i>>>16,2246822507),i^=Math.imul(s^s>>>13,3266489909),4294967296*(2097151&i)+(s>>>0)}const gs=t=>ms(t),ys=(...t)=>ms(t);function fs(t,e=!1){const s=[];!0===t.isNode&&(s.push(t.id),t=t.getSelf());for(const{property:i,childNode:r}of xs(t))s.push(ms(i.slice(0,-4)),r.getCacheKey(e));return ms(s)}function*xs(t,e=!1){for(const s in t){if(!0===s.startsWith("_"))continue;const i=t[s];if(!0===Array.isArray(i))for(let t=0;t<i.length;t++){const r=i[t];r&&(!0===r.isNode||e&&"function"==typeof r.toJSON)&&(yield{property:s,index:t,childNode:r})}else if(i&&!0===i.isNode)yield{property:s,childNode:i};else if("object"==typeof i)for(const t in i){const r=i[t];r&&(!0===r.isNode||e&&"function"==typeof r.toJSON)&&(yield{property:s,index:t,childNode:r})}}}const bs=new Map([[1,"float"],[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),vs=new WeakMap;function ws(t){if(/[iu]?vec\d/.test(t))return t.startsWith("ivec")?Int32Array:t.startsWith("uvec")?Uint32Array:Float32Array;if(/mat\d/.test(t))return Float32Array;if(/float/.test(t))return Float32Array;if(/uint/.test(t))return Uint32Array;if(/int/.test(t))return Int32Array;throw new Error(`THREE.NodeUtils: Unsupported type: ${t}`)}function Ts(t){return/float|int|uint/.test(t)?1:/vec2/.test(t)?2:/vec3/.test(t)?3:/vec4/.test(t)||/mat2/.test(t)?4:/mat3/.test(t)?9:/mat4/.test(t)?16:void console.error("THREE.TSL: Unsupported type:",t)}function Ns(t){if(null==t)return null;const e=typeof t;return!0===t.isNode?"node":"number"===e?"float":"boolean"===e?"bool":"string"===e?"string":"function"===e?"shader":!0===t.isVector2?"vec2":!0===t.isVector3?"vec3":!0===t.isVector4?"vec4":!0===t.isMatrix2?"mat2":!0===t.isMatrix3?"mat3":!0===t.isMatrix4?"mat4":!0===t.isColor?"color":t instanceof ArrayBuffer?"ArrayBuffer":null}function Ms(t,...e){const s=t?t.slice(-4):void 0;return 1===e.length&&("vec2"===s?e=[e[0],e[0]]:"vec3"===s?e=[e[0],e[0],e[0]]:"vec4"===s&&(e=[e[0],e[0],e[0],e[0]])),"color"===t?new ge(...e):"vec2"===s?new S(...e):"vec3"===s?new X(...e):"vec4"===s?new j(...e):"mat2"===s?new cs(...e):"mat3"===s?new A(...e):"mat4"===s?new Nt(...e):"bool"===t?e[0]||!1:"float"===t||"int"===t||"uint"===t?e[0]||0:"string"===t?e[0]||"":"ArrayBuffer"===t?As(e[0]):null}function _s(t){let e=vs.get(t);return void 0===e&&(e={},vs.set(t,e)),e}function Ss(t){let e="";const s=new Uint8Array(t);for(let t=0;t<s.length;t++)e+=String.fromCharCode(s[t]);return btoa(e)}function As(t){return Uint8Array.from(atob(t),t=>t.charCodeAt(0)).buffer}const Vs={VERTEX:"vertex",FRAGMENT:"fragment"},zs={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},Cs={READ_ONLY:"readOnly",WRITE_ONLY:"writeOnly",READ_WRITE:"readWrite"},Rs=["fragment","vertex"],Es=[...Rs,"compute"],Is=["x","y","z","w"];let Os=0;class Ls extends m{static get type(){return"Node"}constructor(t=null){super(),this.nodeType=t,this.updateType=zs.NONE,this.updateBeforeType=zs.NONE,this.updateAfterType=zs.NONE,this.uuid=_.generateUUID(),this.version=0,this.global=!1,this.isNode=!0,this._cacheKey=null,this._cacheKeyVersion=0,Object.defineProperty(this,"id",{value:Os++})}set needsUpdate(t){!0===t&&this.version++}get type(){return this.constructor.type}onUpdate(t,e){return this.updateType=e,this.update=t.bind(this.getSelf()),this}onFrameUpdate(t){return this.onUpdate(t,zs.FRAME)}onRenderUpdate(t){return this.onUpdate(t,zs.RENDER)}onObjectUpdate(t){return this.onUpdate(t,zs.OBJECT)}onReference(t){return this.updateReference=t.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:t}of xs(this))yield t}dispose(){this.dispatchEvent({type:"dispose"})}traverse(t){t(this);for(const e of this.getChildren())e.traverse(t)}getCacheKey(t=!1){return!0!==(t=t||this.version!==this._cacheKeyVersion)&&null!==this._cacheKey||(this._cacheKey=ys(fs(this,t),this.customCacheKey()),this._cacheKeyVersion=this.version),this._cacheKey}customCacheKey(){return 0}getScope(){return this}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(t){const e=this.getNodeType(t);return t.getElementType(e)}getMemberType(){return"void"}getNodeType(t){const e=t.getNodeProperties(this);return e.outputNode?e.outputNode.getNodeType(t):this.nodeType}getShared(t){const e=this.getHash(t);return t.getNodeFromHash(e)||this}setup(t){const e=t.getNodeProperties(this);let s=0;for(const t of this.getChildren())e["node"+s++]=t;return e.outputNode||null}analyze(t){if(1===t.increaseUsage(this)){const e=t.getNodeProperties(this);for(const s of Object.values(e))s&&!0===s.isNode&&s.build(t)}}generate(t,e){const{outputNode:s}=t.getNodeProperties(this);if(s&&!0===s.isNode)return s.build(t,e)}updateBefore(){console.warn("Abstract function.")}updateAfter(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(t,e=null){const s=this.getShared(t);if(this!==s)return s.build(t,e);t.addNode(this),t.addChain(this);let i=null;const r=t.getBuildStage();if("setup"===r){this.updateReference(t);const e=t.getNodeProperties(this);if(!0!==e.initialized){e.initialized=!0;const s=this.setup(t),i=s&&!0===s.isNode;for(const s of Object.values(e))s&&!0===s.isNode&&s.build(t);i&&s.build(t),e.outputNode=s}}else if("analyze"===r)this.analyze(t);else if("generate"===r){if(1===this.generate.length){const s=this.getNodeType(t),r=t.getDataFromNode(this);i=r.snippet,void 0===i?(i=this.generate(t)||"",r.snippet=i):void 0!==r.flowCodes&&void 0!==t.context.nodeBlock&&t.addFlowCodeHierarchy(this,t.context.nodeBlock),i=t.format(i,s,e)}else i=this.generate(t,e)||""}return t.removeChain(this),t.addSequentialNode(this),i}getSerializeChildren(){return xs(this)}serialize(t){const e=this.getSerializeChildren(),s={};for(const{property:i,index:r,childNode:n}of e)void 0!==r?(void 0===s[i]&&(s[i]=Number.isInteger(r)?[]:{}),s[i][r]=n.toJSON(t.meta).uuid):s[i]=n.toJSON(t.meta).uuid;Object.keys(s).length>0&&(t.inputNodes=s)}deserialize(t){if(void 0!==t.inputNodes){const e=t.meta.nodes;for(const s in t.inputNodes)if(Array.isArray(t.inputNodes[s])){const i=[];for(const r of t.inputNodes[s])i.push(e[r]);this[s]=i}else if("object"==typeof t.inputNodes[s]){const i={};for(const r in t.inputNodes[s]){const n=t.inputNodes[s][r];i[r]=e[n]}this[s]=i}else{const i=t.inputNodes[s];this[s]=e[i]}}}toJSON(t){const{uuid:e,type:s}=this,i=void 0===t||"string"==typeof t;i&&(t={textures:{},images:{},nodes:{}});let r=t.nodes[e];function n(t){const e=[];for(const s in t){const i=t[s];delete i.metadata,e.push(i)}return e}if(void 0===r&&(r={uuid:e,type:s,meta:t,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},!0!==i&&(t.nodes[r.uuid]=r),this.serialize(r),delete r.meta),i){const e=n(t.textures),s=n(t.images),i=n(t.nodes);e.length>0&&(r.textures=e),s.length>0&&(r.images=s),i.length>0&&(r.nodes=i)}return r}}class Bs extends Ls{static get type(){return"ArrayElementNode"}constructor(t,e){super(),this.node=t,this.indexNode=e,this.isArrayElementNode=!0}getNodeType(t){return this.node.getElementType(t)}generate(t){return`${this.node.build(t)}[ ${this.indexNode.build(t,"uint")} ]`}}class Fs extends Ls{static get type(){return"ConvertNode"}constructor(t,e){super(),this.node=t,this.convertTo=e}getNodeType(t){const e=this.node.getNodeType(t);let s=null;for(const i of this.convertTo.split("|"))null!==s&&t.getTypeLength(e)!==t.getTypeLength(i)||(s=i);return s}serialize(t){super.serialize(t),t.convertTo=this.convertTo}deserialize(t){super.deserialize(t),this.convertTo=t.convertTo}generate(t,e){const s=this.node,i=this.getNodeType(t),r=s.build(t,i);return t.format(r,i,e)}}class Ps extends Ls{static get type(){return"TempNode"}constructor(t=null){super(t),this.isTempNode=!0}hasDependencies(t){return t.getDataFromNode(this).usageCount>1}build(t,e){if("generate"===t.getBuildStage()){const s=t.getVectorType(this.getNodeType(t,e)),i=t.getDataFromNode(this);if(void 0!==i.propertyName)return t.format(i.propertyName,s,e);if("void"!==s&&"void"!==e&&this.hasDependencies(t)){const r=super.build(t,s),n=t.getVarFromNode(this,null,s),a=t.getPropertyName(n);return t.addLineFlowCode(`${a} = ${r}`,this),i.snippet=r,i.propertyName=a,t.format(i.propertyName,s,e)}}return super.build(t,e)}}class Ds extends Ps{static get type(){return"JoinNode"}constructor(t=[],e=null){super(e),this.nodes=t}getNodeType(t){return null!==this.nodeType?t.getVectorType(this.nodeType):t.getTypeFromLength(this.nodes.reduce((e,s)=>e+t.getTypeLength(s.getNodeType(t)),0))}generate(t,e){const s=this.getNodeType(t),i=this.nodes,r=t.getComponentType(s),n=[];for(const e of i){let s=e.build(t);const i=t.getComponentType(e.getNodeType(t));i!==r&&(s=t.format(s,i,r)),n.push(s)}const a=`${t.getType(s)}( ${n.join(", ")} )`;return t.format(a,s,e)}}const ks=Is.join("");class Us extends Ls{static get type(){return"SplitNode"}constructor(t,e="x"){super(),this.node=t,this.components=e,this.isSplitNode=!0}getVectorLength(){let t=this.components.length;for(const e of this.components)t=Math.max(Is.indexOf(e)+1,t);return t}getComponentType(t){return t.getComponentType(this.node.getNodeType(t))}getNodeType(t){return t.getTypeFromLength(this.components.length,this.getComponentType(t))}generate(t,e){const s=this.node,i=t.getTypeLength(s.getNodeType(t));let r=null;if(i>1){let n=null;this.getVectorLength()>=i&&(n=t.getTypeFromLength(this.getVectorLength(),this.getComponentType(t)));const a=s.build(t,n);r=this.components.length===i&&this.components===ks.slice(0,this.components.length)?t.format(a,n,e):t.format(`${a}.${this.components}`,this.getNodeType(t),e)}else r=s.build(t,e);return r}serialize(t){super.serialize(t),t.components=this.components}deserialize(t){super.deserialize(t),this.components=t.components}}class Ws extends Ps{static get type(){return"SetNode"}constructor(t,e,s){super(),this.sourceNode=t,this.components=e,this.targetNode=s}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{sourceNode:e,components:s,targetNode:i}=this,r=this.getNodeType(t),n=t.getComponentType(i.getNodeType(t)),a=t.getTypeFromLength(s.length,n),o=i.build(t,a),h=e.build(t,r),l=t.getTypeLength(r),u=[];for(let t=0;t<l;t++){const e=Is[t];e===s[0]?(u.push(o),t+=s.length-1):u.push(h+"."+e)}return`${t.getType(r)}( ${u.join(", ")} )`}}class js extends Ps{static get type(){return"FlipNode"}constructor(t,e){super(),this.sourceNode=t,this.components=e}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{components:e,sourceNode:s}=this,i=this.getNodeType(t),r=s.build(t),n=t.getVarFromNode(this),a=t.getPropertyName(n);t.addLineFlowCode(a+" = "+r,this);const o=t.getTypeLength(i),h=[];let l=0;for(let t=0;t<o;t++){const s=Is[t];s===e[l]?(h.push("1.0 - "+a+"."+s),l++):h.push(a+"."+s)}return`${t.getType(i)}( ${h.join(", ")} )`}}class qs extends Ls{static get type(){return"InputNode"}constructor(t,e=null){super(e),this.isInputNode=!0,this.value=t,this.precision=null}getNodeType(){return null===this.nodeType?Ns(this.value):this.nodeType}getInputType(t){return this.getNodeType(t)}setPrecision(t){return this.precision=t,this}serialize(t){super.serialize(t),t.value=this.value,this.value&&this.value.toArray&&(t.value=this.value.toArray()),t.valueType=Ns(this.value),t.nodeType=this.nodeType,"ArrayBuffer"===t.valueType&&(t.value=Ss(t.value)),t.precision=this.precision}deserialize(t){super.deserialize(t),this.nodeType=t.nodeType,this.value=Array.isArray(t.value)?Ms(t.valueType,...t.value):t.value,this.precision=t.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(t.value))}generate(){console.warn("Abstract function.")}}const Hs=/float|u?int/;class Gs extends qs{static get type(){return"ConstNode"}constructor(t,e=null){super(t,e),this.isConstNode=!0}generateConst(t){return t.generateConst(this.getNodeType(t),this.value)}generate(t,e){const s=this.getNodeType(t);return Hs.test(s)&&Hs.test(e)?t.generateConst(e,this.value):t.format(this.generateConst(t),s,e)}}class Xs extends Ls{static get type(){return"MemberNode"}constructor(t,e){super(),this.node=t,this.property=e,this.isMemberNode=!0}getNodeType(t){return this.node.getMemberType(t,this.property)}generate(t){return this.node.build(t)+"."+this.property}}let $s=null;const Ys=new Map;function Zs(t,e){if(Ys.has(t))console.warn(`Redefinition of method chaining ${t}`);else{if("function"!=typeof e)throw new Error(`Node element ${t} is not a function`);Ys.set(t,e)}}const Js=t=>t.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),Qs=t=>Js(t).split("").sort().join(""),Ks={setup(t,e){const s=e.shift();return t(Mi(s),...e)},get(t,e,s){if("string"==typeof e&&void 0===t[e]){if(!0!==t.isStackNode&&"assign"===e)return(...t)=>($s.assign(s,...t),s);if(Ys.has(e)){const i=Ys.get(e);return t.isStackNode?(...t)=>s.add(i(...t)):(...t)=>i(s,...t)}if("self"===e)return t;if(e.endsWith("Assign")&&Ys.has(e.slice(0,e.length-6))){const i=Ys.get(e.slice(0,e.length-6));return t.isStackNode?(...t)=>s.assign(t[0],i(...t)):(...t)=>s.assign(i(s,...t))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(e))return e=Js(e),Ni(new Us(s,e));if(!0===/^set[XYZWRGBASTPQ]{1,4}$/.test(e))return e=Qs(e.slice(3).toLowerCase()),s=>Ni(new Ws(t,e,s));if(!0===/^flip[XYZWRGBASTPQ]{1,4}$/.test(e))return e=Qs(e.slice(4).toLowerCase()),()=>Ni(new js(Ni(t),e));if("width"===e||"height"===e||"depth"===e)return"width"===e?e="x":"height"===e?e="y":"depth"===e&&(e="z"),Ni(new Us(t,e));if(!0===/^\d+$/.test(e))return Ni(new Bs(s,new Gs(Number(e),"uint")));if(!0===/^get$/.test(e))return t=>Ni(new Xs(s,t))}return Reflect.get(t,e,s)},set:(t,e,s,i)=>"string"!=typeof e||void 0!==t[e]||!0!==/^[xyzwrgbastpq]{1,4}$/.test(e)&&"width"!==e&&"height"!==e&&"depth"!==e&&!0!==/^\d+$/.test(e)?Reflect.set(t,e,s,i):(i[e].assign(s),!0)},ti=new WeakMap,ei=new WeakMap,si=function(t,e=null){for(const s in t)t[s]=Ni(t[s],e);return t},ii=function(t,e=null){const s=t.length;for(let i=0;i<s;i++)t[i]=Ni(t[i],e);return t},ri=function(t,e=null,s=null,i=null){const r=t=>Ni(null!==i?Object.assign(t,i):t);return null===e?(...e)=>r(new t(..._i(e))):null!==s?(s=Ni(s),(...i)=>r(new t(e,..._i(i),s))):(...s)=>r(new t(e,..._i(s)))},ni=function(t,...e){return Ni(new t(..._i(e)))};class ai extends Ls{constructor(t,e){super(),this.shaderNode=t,this.inputNodes=e}getNodeType(t){return this.shaderNode.nodeType||this.getOutputNode(t).getNodeType(t)}getMemberType(t,e){return this.getOutputNode(t).getMemberType(t,e)}call(t){const{shaderNode:e,inputNodes:s}=this,i=t.getNodeProperties(e);if(i.onceOutput)return i.onceOutput;let r=null;if(e.layout){let i=ei.get(t.constructor);void 0===i&&(i=new WeakMap,ei.set(t.constructor,i));let n=i.get(e);void 0===n&&(n=Ni(t.buildFunctionNode(e)),i.set(e,n)),t.addInclude(n),r=Ni(n.call(s))}else{const i=e.jsFunc,n=null!==s||i.length>1?i(s||[],t):i(t);r=Ni(n)}return e.once&&(i.onceOutput=r),r}getOutputNode(t){const e=t.getNodeProperties(this);return null===e.outputNode&&(e.outputNode=this.setupOutput(t)),e.outputNode}setup(t){return this.getOutputNode(t)}setupOutput(t){return t.addStack(),t.stack.outputNode=this.call(t),t.removeStack()}generate(t,e){return this.getOutputNode(t).build(t,e)}}class oi extends Ls{constructor(t,e){super(e),this.jsFunc=t,this.layout=null,this.global=!0,this.once=!1}setLayout(t){return this.layout=t,this}call(t=null){return Mi(t),Ni(new ai(this,t))}setup(){return this.call()}}const hi=[!1,!0],li=[0,1,2,3],ui=[-1,-2],ci=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],di=new Map;for(const t of hi)di.set(t,new Gs(t));const pi=new Map;for(const t of li)pi.set(t,new Gs(t,"uint"));const mi=new Map([...pi].map(t=>new Gs(t.value,"int")));for(const t of ui)mi.set(t,new Gs(t,"int"));const gi=new Map([...mi].map(t=>new Gs(t.value)));for(const t of ci)gi.set(t,new Gs(t));for(const t of ci)gi.set(-t,new Gs(-t));const yi={bool:di,uint:pi,ints:mi,float:gi},fi=new Map([...di,...gi]),xi=(t,e)=>fi.has(t)?fi.get(t):!0===t.isNode?t:new Gs(t,e),bi=function(t,e=null){return(...s)=>{if((0===s.length||!["bool","float","int","uint"].includes(t)&&s.every(t=>"object"!=typeof t))&&(s=[Ms(t,...s)]),1===s.length&&null!==e&&e.has(s[0]))return Ni(e.get(s[0]));if(1===s.length){const e=xi(s[0],t);return(t=>{try{return t.getNodeType()}catch(t){return}})(e)===t?Ni(e):Ni(new Fs(e,t))}const i=s.map(t=>xi(t));return Ni(new Ds(i,t))}},vi=t=>"object"==typeof t&&null!==t?t.value:t,wi=t=>null!=t?t.nodeType||t.convertTo||("string"==typeof t?t:null):null;function Ti(t,e){return new Proxy(new oi(t,e),Ks)}const Ni=(t,e=null)=>function(t,e=null){const s=Ns(t);if("node"===s){let e=ti.get(t);return void 0===e&&(e=new Proxy(t,Ks),ti.set(t,e),ti.set(e,e)),e}return null===e&&("float"===s||"boolean"===s)||s&&"shader"!==s&&"string"!==s?Ni(xi(t,e)):"shader"===s?Vi(t):t}(t,e),Mi=(t,e=null)=>new si(t,e),_i=(t,e=null)=>new ii(t,e),Si=(...t)=>new ri(...t),Ai=(...t)=>new ni(...t),Vi=(t,e)=>{const s=new Ti(t,e),i=(...t)=>{let e;return Mi(t),e=t[0]&&t[0].isNode?[...t]:t[0],s.call(e)};return i.shaderNode=s,i.setLayout=t=>(s.setLayout(t),i),i.once=()=>(s.once=!0,i),i};Zs("toGlobal",t=>(t.global=!0,t));const zi=t=>{$s=t},Ci=()=>$s,Ri=(...t)=>$s.If(...t);function Ei(t){return $s&&$s.add(t),t}Zs("append",Ei);const Ii=new bi("color"),Oi=new bi("float",yi.float),Li=new bi("int",yi.ints),Bi=new bi("uint",yi.uint),Fi=new bi("bool",yi.bool),Pi=new bi("vec2"),Di=new bi("ivec2"),ki=new bi("uvec2"),Ui=new bi("bvec2"),Wi=new bi("vec3"),ji=new bi("ivec3"),qi=new bi("uvec3"),Hi=new bi("bvec3"),Gi=new bi("vec4"),Xi=new bi("ivec4"),$i=new bi("uvec4"),Yi=new bi("bvec4"),Zi=new bi("mat2"),Ji=new bi("mat3"),Qi=new bi("mat4");Zs("toColor",Ii),Zs("toFloat",Oi),Zs("toInt",Li),Zs("toUint",Bi),Zs("toBool",Fi),Zs("toVec2",Pi),Zs("toIVec2",Di),Zs("toUVec2",ki),Zs("toBVec2",Ui),Zs("toVec3",Wi),Zs("toIVec3",ji),Zs("toUVec3",qi),Zs("toBVec3",Hi),Zs("toVec4",Gi),Zs("toIVec4",Xi),Zs("toUVec4",$i),Zs("toBVec4",Yi),Zs("toMat2",Zi),Zs("toMat3",Ji),Zs("toMat4",Qi);const Ki=Si(Bs),tr=(t,e)=>Ni(new Fs(Ni(t),e));Zs("element",Ki),Zs("convert",tr);class er extends Ps{static get type(){return"ArrayNode"}constructor(t,e,s=null){super(t),this.count=e,this.values=s,this.isArrayNode=!0}getNodeType(t){return null===this.nodeType&&(this.nodeType=this.values[0].getNodeType(t)),this.nodeType}getElementType(t){return this.getNodeType(t)}generate(t){const e=this.getNodeType(t);return t.generateArray(e,this.count,this.values)}}const sr=(...t)=>{let e;if(1===t.length){const s=t[0];e=new er(null,s.length,s)}else{const s=t[0],i=t[1];e=new er(s,i)}return Ni(e)};Zs("toArray",(t,e)=>sr(Array(e).fill(t)));class ir extends Ls{static get type(){return"UniformGroupNode"}constructor(t,e=!1,s=1){super("string"),this.name=t,this.shared=e,this.order=s,this.isUniformGroup=!0}serialize(t){super.serialize(t),t.name=this.name,t.version=this.version,t.shared=this.shared}deserialize(t){super.deserialize(t),this.name=t.name,this.version=t.version,this.shared=t.shared}}const rr=t=>new ir(t),nr=(t,e=0)=>new ir(t,!0,e),ar=nr("frame"),or=nr("render"),hr=rr("object");class lr extends qs{static get type(){return"UniformNode"}constructor(t,e=null){super(t,e),this.isUniformNode=!0,this.name="",this.groupNode=hr}label(t){return this.name=t,this}setGroup(t){return this.groupNode=t,this}getGroup(){return this.groupNode}getUniformHash(t){return this.getHash(t)}onUpdate(t,e){const s=this.getSelf();return t=t.bind(s),super.onUpdate(e=>{const i=t(e,s);void 0!==i&&(this.value=i)},e)}generate(t,e){const s=this.getNodeType(t),i=this.getUniformHash(t);let r=t.getNodeFromHash(i);void 0===r&&(t.setHashNode(this,i),r=this);const n=r.getInputType(t),a=t.getUniformFromNode(r,n,t.shaderStage,this.name||t.context.label),o=t.getPropertyName(a);return void 0!==t.context.label&&delete t.context.label,t.format(o,s,e)}}const ur=(t,e)=>{const s=wi(e||t),i=t&&!0===t.isNode?t.node&&t.node.value||t.value:t;return Ni(new lr(i,s))};class cr extends Ls{static get type(){return"PropertyNode"}constructor(t,e=null,s=!1){super(t),this.name=e,this.varying=s,this.isPropertyNode=!0}getHash(t){return this.name||super.getHash(t)}isGlobal(){return!0}generate(t){let e;return!0===this.varying?(e=t.getVaryingFromNode(this,this.name),e.needsInterpolation=!0):e=t.getVarFromNode(this,this.name),t.getPropertyName(e)}}const dr=(t,e)=>Ni(new cr(t,e)),pr=(t,e)=>Ni(new cr(t,e,!0)),mr=Ai(cr,"vec4","DiffuseColor"),gr=Ai(cr,"vec3","EmissiveColor"),yr=Ai(cr,"float","Roughness"),fr=Ai(cr,"float","Metalness"),xr=Ai(cr,"float","Clearcoat"),br=Ai(cr,"float","ClearcoatRoughness"),vr=Ai(cr,"vec3","Sheen"),wr=Ai(cr,"float","SheenRoughness"),Tr=Ai(cr,"float","Iridescence"),Nr=Ai(cr,"float","IridescenceIOR"),Mr=Ai(cr,"float","IridescenceThickness"),_r=Ai(cr,"float","AlphaT"),Sr=Ai(cr,"float","Anisotropy"),Ar=Ai(cr,"vec3","AnisotropyT"),Vr=Ai(cr,"vec3","AnisotropyB"),zr=Ai(cr,"color","SpecularColor"),Cr=Ai(cr,"float","SpecularF90"),Rr=Ai(cr,"float","Shininess"),Er=Ai(cr,"vec4","Output"),Ir=Ai(cr,"float","dashSize"),Or=Ai(cr,"float","gapSize"),Lr=Ai(cr,"float","pointWidth"),Br=Ai(cr,"float","IOR"),Fr=Ai(cr,"float","Transmission"),Pr=Ai(cr,"float","Thickness"),Dr=Ai(cr,"float","AttenuationDistance"),kr=Ai(cr,"color","AttenuationColor"),Ur=Ai(cr,"float","Dispersion");class Wr extends Ps{static get type(){return"AssignNode"}constructor(t,e){super(),this.targetNode=t,this.sourceNode=e}hasDependencies(){return!1}getNodeType(t,e){return"void"!==e?this.targetNode.getNodeType(t):"void"}needsSplitAssign(t){const{targetNode:e}=this;if(!1===t.isAvailable("swizzleAssign")&&e.isSplitNode&&e.components.length>1){const s=t.getTypeLength(e.node.getNodeType(t));return Is.join("").slice(0,s)!==e.components}return!1}generate(t,e){const{targetNode:s,sourceNode:i}=this,r=this.needsSplitAssign(t),n=s.getNodeType(t),a=s.context({assign:!0}).build(t),o=i.build(t,n),h=i.getNodeType(t),l=t.getDataFromNode(this);let u;if(!0===l.initialized)"void"!==e&&(u=a);else if(r){const i=t.getVarFromNode(this,null,n),r=t.getPropertyName(i);t.addLineFlowCode(`${r} = ${o}`,this);const h=s.node.context({assign:!0}).build(t);for(let e=0;e<s.components.length;e++){const i=s.components[e];t.addLineFlowCode(`${h}.${i} = ${r}[ ${e} ]`,this)}"void"!==e&&(u=a)}else u=`${a} = ${o}`,"void"!==e&&"void"!==h||(t.addLineFlowCode(u,this),"void"!==e&&(u=a));return l.initialized=!0,t.format(u,n,e)}}const jr=Si(Wr);Zs("assign",jr);class qr extends Ps{static get type(){return"FunctionCallNode"}constructor(t=null,e={}){super(),this.functionNode=t,this.parameters=e}setParameters(t){return this.parameters=t,this}getParameters(){return this.parameters}getNodeType(t){return this.functionNode.getNodeType(t)}generate(t){const e=[],s=this.functionNode,i=s.getInputs(t),r=this.parameters,n=(e,s)=>{const i=s.type;let r;return r="pointer"===i?"&"+e.build(t):e.build(t,i),r};if(Array.isArray(r))for(let t=0;t<r.length;t++)e.push(n(r[t],i[t]));else for(const t of i){const s=r[t.name];if(void 0===s)throw new Error(`FunctionCallNode: Input '${t.name}' not found in FunctionNode.`);e.push(n(s,t))}return`${s.build(t,"property")}( ${e.join(", ")} )`}}const Hr=(t,...e)=>(e=e.length>1||e[0]&&!0===e[0].isNode?_i(e):Mi(e[0]),Ni(new qr(Ni(t),e)));Zs("call",Hr);class Gr extends Ps{static get type(){return"OperatorNode"}constructor(t,e,s,...i){if(super(),i.length>0){let r=new Gr(t,e,s);for(let e=0;e<i.length-1;e++)r=new Gr(t,r,i[e]);e=r,s=i[i.length-1]}this.op=t,this.aNode=e,this.bNode=s,this.isOperatorNode=!0}getNodeType(t,e){const s=this.op,i=this.aNode,r=this.bNode,n=i.getNodeType(t),a=void 0!==r?r.getNodeType(t):null;if("void"===n||"void"===a)return"void";if("%"===s)return n;if("~"===s||"&"===s||"|"===s||"^"===s||">>"===s||"<<"===s)return t.getIntegerType(n);if("!"===s||"=="===s||"&&"===s||"||"===s||"^^"===s)return"bool";if("<"===s||">"===s||"<="===s||">="===s){const s=e?t.getTypeLength(e):Math.max(t.getTypeLength(n),t.getTypeLength(a));return s>1?`bvec${s}`:"bool"}if(t.isMatrix(n)){if("float"===a)return n;if(t.isVector(a))return t.getVectorFromMatrix(n);if(t.isMatrix(a))return n}else if(t.isMatrix(a)){if("float"===n)return a;if(t.isVector(n))return t.getVectorFromMatrix(a)}return t.getTypeLength(a)>t.getTypeLength(n)?a:n}generate(t,e){const s=this.op,i=this.aNode,r=this.bNode,n=this.getNodeType(t,e);let a=null,o=null;"void"!==n?(a=i.getNodeType(t),o=void 0!==r?r.getNodeType(t):null,"<"===s||">"===s||"<="===s||">="===s||"=="===s?t.isVector(a)?o=a:a!==o&&(a=o="float"):">>"===s||"<<"===s?(a=n,o=t.changeComponentType(o,"uint")):t.isMatrix(a)?"float"===o?o="float":t.isVector(o)?o=t.getVectorFromMatrix(a):t.isMatrix(o)||(a=o=n):a=t.isMatrix(o)?"float"===a?"float":t.isVector(a)?t.getVectorFromMatrix(o):o=n:o=n):a=o=n;const h=i.build(t,a),l=void 0!==r?r.build(t,o):null,u=t.getTypeLength(e),c=t.getFunctionOperator(s);return"void"!==e?"<"===s&&u>1?t.useComparisonMethod?t.format(`${t.getMethod("lessThan",e)}( ${h}, ${l} )`,n,e):t.format(`( ${h} < ${l} )`,n,e):"<="===s&&u>1?t.useComparisonMethod?t.format(`${t.getMethod("lessThanEqual",e)}( ${h}, ${l} )`,n,e):t.format(`( ${h} <= ${l} )`,n,e):">"===s&&u>1?t.useComparisonMethod?t.format(`${t.getMethod("greaterThan",e)}( ${h}, ${l} )`,n,e):t.format(`( ${h} > ${l} )`,n,e):">="===s&&u>1?t.useComparisonMethod?t.format(`${t.getMethod("greaterThanEqual",e)}( ${h}, ${l} )`,n,e):t.format(`( ${h} >= ${l} )`,n,e):"!"===s||"~"===s?t.format(`(${s}${h})`,a,e):c?t.format(`${c}( ${h}, ${l} )`,n,e):t.isMatrix(a)&&"float"===o?t.format(`( ${l} ${s} ${h} )`,n,e):"float"===a&&t.isMatrix(o)?t.format(`${h} ${s} ${l}`,n,e):t.format(`( ${h} ${s} ${l} )`,n,e):"void"!==a?c?t.format(`${c}( ${h}, ${l} )`,n,e):t.isMatrix(a)&&"float"===o?t.format(`${l} ${s} ${h}`,n,e):t.format(`${h} ${s} ${l}`,n,e):void 0}serialize(t){super.serialize(t),t.op=this.op}deserialize(t){super.deserialize(t),this.op=t.op}}const Xr=Si(Gr,"+"),$r=Si(Gr,"-"),Yr=Si(Gr,"*"),Zr=Si(Gr,"/"),Jr=Si(Gr,"%"),Qr=Si(Gr,"=="),Kr=Si(Gr,"!="),tn=Si(Gr,"<"),en=Si(Gr,">"),sn=Si(Gr,"<="),rn=Si(Gr,">="),nn=Si(Gr,"&&"),an=Si(Gr,"||"),on=Si(Gr,"!"),hn=Si(Gr,"^^"),ln=Si(Gr,"&"),un=Si(Gr,"~"),cn=Si(Gr,"|"),dn=Si(Gr,"^"),pn=Si(Gr,"<<"),mn=Si(Gr,">>");Zs("add",Xr),Zs("sub",$r),Zs("mul",Yr),Zs("div",Zr),Zs("modInt",Jr),Zs("equal",Qr),Zs("notEqual",Kr),Zs("lessThan",tn),Zs("greaterThan",en),Zs("lessThanEqual",sn),Zs("greaterThanEqual",rn),Zs("and",nn),Zs("or",an),Zs("not",on),Zs("xor",hn),Zs("bitAnd",ln),Zs("bitNot",un),Zs("bitOr",cn),Zs("bitXor",dn),Zs("shiftLeft",pn),Zs("shiftRight",mn);const gn=(...t)=>(console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."),Jr(...t));Zs("remainder",gn);class yn extends Ps{static get type(){return"MathNode"}constructor(t,e,s=null,i=null){super(),this.method=t,this.aNode=e,this.bNode=s,this.cNode=i,this.isMathNode=!0}getInputType(t){const e=this.aNode.getNodeType(t),s=this.bNode?this.bNode.getNodeType(t):null,i=this.cNode?this.cNode.getNodeType(t):null,r=t.isMatrix(e)?0:t.getTypeLength(e),n=t.isMatrix(s)?0:t.getTypeLength(s),a=t.isMatrix(i)?0:t.getTypeLength(i);return r>n&&r>a?e:n>a?s:a>r?i:e}getNodeType(t){const e=this.method;return e===yn.LENGTH||e===yn.DISTANCE||e===yn.DOT?"float":e===yn.CROSS?"vec3":e===yn.ALL?"bool":e===yn.EQUALS?t.changeComponentType(this.aNode.getNodeType(t),"bool"):e===yn.MOD?this.aNode.getNodeType(t):this.getInputType(t)}generate(t,e){let s=this.method;const i=this.getNodeType(t),r=this.getInputType(t),n=this.aNode,a=this.bNode,o=this.cNode,h=t.renderer.coordinateSystem;if(s===yn.TRANSFORM_DIRECTION){let s=n,i=a;t.isMatrix(s.getNodeType(t))?i=Gi(Wi(i),0):s=Gi(Wi(s),0);const r=Yr(s,i).xyz;return In(r).build(t,e)}if(s===yn.NEGATE)return t.format("( - "+n.build(t,r)+" )",i,e);if(s===yn.ONE_MINUS)return $r(1,n).build(t,e);if(s===yn.RECIPROCAL)return Zr(1,n).build(t,e);if(s===yn.DIFFERENCE)return Un($r(n,a)).build(t,e);{const l=[];return s===yn.CROSS||s===yn.MOD?l.push(n.build(t,i),a.build(t,i)):h===d&&s===yn.STEP?l.push(n.build(t,1===t.getTypeLength(n.getNodeType(t))?"float":r),a.build(t,r)):h===d&&(s===yn.MIN||s===yn.MAX)||s===yn.MOD?l.push(n.build(t,r),a.build(t,1===t.getTypeLength(a.getNodeType(t))?"float":r)):s===yn.REFRACT?l.push(n.build(t,r),a.build(t,r),o.build(t,"float")):s===yn.MIX?l.push(n.build(t,r),a.build(t,r),o.build(t,1===t.getTypeLength(o.getNodeType(t))?"float":r)):(h===p&&s===yn.ATAN&&null!==a&&(s="atan2"),l.push(n.build(t,r)),null!==a&&l.push(a.build(t,r)),null!==o&&l.push(o.build(t,r))),t.format(`${t.getMethod(s,i)}( ${l.join(", ")} )`,i,e)}}serialize(t){super.serialize(t),t.method=this.method}deserialize(t){super.deserialize(t),this.method=t.method}}yn.ALL="all",yn.ANY="any",yn.RADIANS="radians",yn.DEGREES="degrees",yn.EXP="exp",yn.EXP2="exp2",yn.LOG="log",yn.LOG2="log2",yn.SQRT="sqrt",yn.INVERSE_SQRT="inversesqrt",yn.FLOOR="floor",yn.CEIL="ceil",yn.NORMALIZE="normalize",yn.FRACT="fract",yn.SIN="sin",yn.COS="cos",yn.TAN="tan",yn.ASIN="asin",yn.ACOS="acos",yn.ATAN="atan",yn.ABS="abs",yn.SIGN="sign",yn.LENGTH="length",yn.NEGATE="negate",yn.ONE_MINUS="oneMinus",yn.DFDX="dFdx",yn.DFDY="dFdy",yn.ROUND="round",yn.RECIPROCAL="reciprocal",yn.TRUNC="trunc",yn.FWIDTH="fwidth",yn.TRANSPOSE="transpose",yn.BITCAST="bitcast",yn.EQUALS="equals",yn.MIN="min",yn.MAX="max",yn.MOD="mod",yn.STEP="step",yn.REFLECT="reflect",yn.DISTANCE="distance",yn.DIFFERENCE="difference",yn.DOT="dot",yn.CROSS="cross",yn.POW="pow",yn.TRANSFORM_DIRECTION="transformDirection",yn.MIX="mix",yn.CLAMP="clamp",yn.REFRACT="refract",yn.SMOOTHSTEP="smoothstep",yn.FACEFORWARD="faceforward";const fn=Oi(1e-6),xn=Oi(1e6),bn=Oi(Math.PI),vn=Oi(2*Math.PI),wn=Si(yn,yn.ALL),Tn=Si(yn,yn.ANY),Nn=Si(yn,yn.RADIANS),Mn=Si(yn,yn.DEGREES),_n=Si(yn,yn.EXP),Sn=Si(yn,yn.EXP2),An=Si(yn,yn.LOG),Vn=Si(yn,yn.LOG2),zn=Si(yn,yn.SQRT),Cn=Si(yn,yn.INVERSE_SQRT),Rn=Si(yn,yn.FLOOR),En=Si(yn,yn.CEIL),In=Si(yn,yn.NORMALIZE),On=Si(yn,yn.FRACT),Ln=Si(yn,yn.SIN),Bn=Si(yn,yn.COS),Fn=Si(yn,yn.TAN),Pn=Si(yn,yn.ASIN),Dn=Si(yn,yn.ACOS),kn=Si(yn,yn.ATAN),Un=Si(yn,yn.ABS),Wn=Si(yn,yn.SIGN),jn=Si(yn,yn.LENGTH),qn=Si(yn,yn.NEGATE),Hn=Si(yn,yn.ONE_MINUS),Gn=Si(yn,yn.DFDX),Xn=Si(yn,yn.DFDY),$n=Si(yn,yn.ROUND),Yn=Si(yn,yn.RECIPROCAL),Zn=Si(yn,yn.TRUNC),Jn=Si(yn,yn.FWIDTH),Qn=Si(yn,yn.TRANSPOSE),Kn=Si(yn,yn.BITCAST),ta=Si(yn,yn.EQUALS),ea=Si(yn,yn.MIN),sa=Si(yn,yn.MAX),ia=Si(yn,yn.MOD),ra=Si(yn,yn.STEP),na=Si(yn,yn.REFLECT),aa=Si(yn,yn.DISTANCE),oa=Si(yn,yn.DIFFERENCE),ha=Si(yn,yn.DOT),la=Si(yn,yn.CROSS),ua=Si(yn,yn.POW),ca=Si(yn,yn.POW,2),da=Si(yn,yn.POW,3),pa=Si(yn,yn.POW,4),ma=Si(yn,yn.TRANSFORM_DIRECTION),ga=t=>Yr(Wn(t),ua(Un(t),1/3)),ya=t=>ha(t,t),fa=Si(yn,yn.MIX),xa=(t,e=0,s=1)=>Ni(new yn(yn.CLAMP,Ni(t),Ni(e),Ni(s))),ba=t=>xa(t),va=Si(yn,yn.REFRACT),wa=Si(yn,yn.SMOOTHSTEP),Ta=Si(yn,yn.FACEFORWARD),Na=Vi(([t])=>{const e=ha(t.xy,Pi(12.9898,78.233)),s=ia(e,bn);return On(Ln(s).mul(43758.5453))}),Ma=(t,e,s)=>fa(e,s,t),_a=(t,e,s)=>wa(e,s,t),Sa=(t,e)=>(console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'),kn(t,e)),Aa=Ta,Va=Cn;Zs("all",wn),Zs("any",Tn),Zs("equals",ta),Zs("radians",Nn),Zs("degrees",Mn),Zs("exp",_n),Zs("exp2",Sn),Zs("log",An),Zs("log2",Vn),Zs("sqrt",zn),Zs("inverseSqrt",Cn),Zs("floor",Rn),Zs("ceil",En),Zs("normalize",In),Zs("fract",On),Zs("sin",Ln),Zs("cos",Bn),Zs("tan",Fn),Zs("asin",Pn),Zs("acos",Dn),Zs("atan",kn),Zs("abs",Un),Zs("sign",Wn),Zs("length",jn),Zs("lengthSq",ya),Zs("negate",qn),Zs("oneMinus",Hn),Zs("dFdx",Gn),Zs("dFdy",Xn),Zs("round",$n),Zs("reciprocal",Yn),Zs("trunc",Zn),Zs("fwidth",Jn),Zs("atan2",Sa),Zs("min",ea),Zs("max",sa),Zs("mod",ia),Zs("step",ra),Zs("reflect",na),Zs("distance",aa),Zs("dot",ha),Zs("cross",la),Zs("pow",ua),Zs("pow2",ca),Zs("pow3",da),Zs("pow4",pa),Zs("transformDirection",ma),Zs("mix",Ma),Zs("clamp",xa),Zs("refract",va),Zs("smoothstep",_a),Zs("faceForward",Ta),Zs("difference",oa),Zs("saturate",ba),Zs("cbrt",ga),Zs("transpose",Qn),Zs("rand",Na);class za extends Ls{static get type(){return"ConditionalNode"}constructor(t,e,s=null){super(),this.condNode=t,this.ifNode=e,this.elseNode=s}getNodeType(t){const{ifNode:e,elseNode:s}=t.getNodeProperties(this);if(void 0===e)return this.setup(t),this.getNodeType(t);const i=e.getNodeType(t);if(null!==s){const e=s.getNodeType(t);if(t.getTypeLength(e)>t.getTypeLength(i))return e}return i}setup(t){const e=this.condNode.cache(),s=this.ifNode.cache(),i=this.elseNode?this.elseNode.cache():null,r=t.context.nodeBlock;t.getDataFromNode(s).parentNodeBlock=r,null!==i&&(t.getDataFromNode(i).parentNodeBlock=r);const n=t.getNodeProperties(this);n.condNode=e,n.ifNode=s.context({nodeBlock:s}),n.elseNode=i?i.context({nodeBlock:i}):null}generate(t,e){const s=this.getNodeType(t),i=t.getDataFromNode(this);if(void 0!==i.nodeProperty)return i.nodeProperty;const{condNode:r,ifNode:n,elseNode:a}=t.getNodeProperties(this),o="void"!==e,h=o?dr(s).build(t):"";i.nodeProperty=h;const l=r.build(t,"bool");t.addFlowCode(`\n${t.tab}if ( ${l} ) {\n\n`).addFlowTab();let u=n.build(t,s);if(u&&(u=o?h+" = "+u+";":"return "+u+";"),t.removeFlowTab().addFlowCode(t.tab+"\t"+u+"\n\n"+t.tab+"}"),null!==a){t.addFlowCode(" else {\n\n").addFlowTab();let e=a.build(t,s);e&&(e=o?h+" = "+e+";":"return "+e+";"),t.removeFlowTab().addFlowCode(t.tab+"\t"+e+"\n\n"+t.tab+"}\n\n")}else t.addFlowCode("\n\n");return t.format(h,s,e)}}const Ca=Si(za);Zs("select",Ca);const Ra=(...t)=>(console.warn("TSL.ConditionalNode: cond() has been renamed to select()."),Ca(...t));Zs("cond",Ra);class Ea extends Ls{static get type(){return"ContextNode"}constructor(t,e={}){super(),this.isContextNode=!0,this.node=t,this.value=e}getScope(){return this.node.getScope()}getNodeType(t){return this.node.getNodeType(t)}analyze(t){this.node.build(t)}setup(t){const e=t.getContext();t.setContext({...t.context,...this.value});const s=this.node.build(t);return t.setContext(e),s}generate(t,e){const s=t.getContext();t.setContext({...t.context,...this.value});const i=this.node.build(t,e);return t.setContext(s),i}}const Ia=Si(Ea),Oa=(t,e)=>Ia(t,{label:e});Zs("context",Ia),Zs("label",Oa);class La extends Ls{static get type(){return"VarNode"}constructor(t,e=null,s=!1){super(),this.node=t,this.name=e,this.global=!0,this.isVarNode=!0,this.readOnly=s}getHash(t){return this.name||super.getHash(t)}getMemberType(t,e){return this.node.getMemberType(t,e)}getElementType(t){return this.node.getElementType(t)}getNodeType(t){return this.node.getNodeType(t)}generate(t){const{node:e,name:s,readOnly:i}=this,{renderer:r}=t,n=!0===r.backend.isWebGPUBackend;let a=!1,o=!1;i&&(a=t.isDeterministic(e),o=n?i:a);const h=t.getVectorType(this.getNodeType(t)),l=e.build(t,h),u=t.getVarFromNode(this,s,h,void 0,o),c=t.getPropertyName(u);let d=c;if(o)if(n)d=a?`const ${c}`:`let ${c}`;else{const s=t.getArrayCount(e);d=`const ${t.getVar(u.type,c,s)}`}return t.addLineFlowCode(`${d} = ${l}`,this),c}}const Ba=Si(La),Fa=(t,e=null)=>Ba(t,e).append(),Pa=(t,e=null)=>Ba(t,e,!0).append();Zs("toVar",Fa),Zs("toConst",Pa);const Da=t=>(console.warn('TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.'),Ba(t));Zs("temp",Da);class ka extends Ls{static get type(){return"VaryingNode"}constructor(t,e=null){super(),this.node=t,this.name=e,this.isVaryingNode=!0}isGlobal(){return!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}setupVarying(t){const e=t.getNodeProperties(this);let s=e.varying;if(void 0===s){const i=this.name,r=this.getNodeType(t);e.varying=s=t.getVaryingFromNode(this,i,r),e.node=this.node}return s.needsInterpolation||(s.needsInterpolation="fragment"===t.shaderStage),s}setup(t){this.setupVarying(t)}analyze(t){return this.setupVarying(t),this.node.analyze(t)}generate(t){const e=t.getNodeProperties(this),s=this.setupVarying(t),i="fragment"===t.shaderStage&&!0===e.reassignPosition&&t.context.needsPositionReassign;if(void 0===e.propertyName||i){const r=this.getNodeType(t),n=t.getPropertyName(s,Vs.VERTEX);t.flowNodeFromShaderStage(Vs.VERTEX,this.node,r,n),e.propertyName=n,i?e.reassignPosition=!1:void 0===e.reassignPosition&&t.context.isPositionNodeInput&&(e.reassignPosition=!0)}return t.getPropertyName(s)}}const Ua=Si(ka),Wa=t=>Ua(t);Zs("toVarying",Ua),Zs("toVertexStage",Wa),Zs("varying",(...t)=>(console.warn("TSL.VaryingNode: .varying() has been renamed to .toVarying()."),Ua(...t))),Zs("vertexStage",(...t)=>(console.warn("TSL.VaryingNode: .vertexStage() has been renamed to .toVertexStage()."),Ua(...t)));const ja=Vi(([t])=>{const e=t.mul(.9478672986).add(.0521327014).pow(2.4),s=t.mul(.0773993808),i=t.lessThanEqual(.04045);return fa(e,s,i)}).setLayout({name:"sRGBTransferEOTF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),qa=Vi(([t])=>{const e=t.pow(.41666).mul(1.055).sub(.055),s=t.mul(12.92),i=t.lessThanEqual(.0031308);return fa(e,s,i)}).setLayout({name:"sRGBTransferOETF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),Ha="WorkingColorSpace",Ga="OutputColorSpace";class Xa extends Ps{static get type(){return"ColorSpaceNode"}constructor(t,e,s){super("vec4"),this.colorNode=t,this.source=e,this.target=s}resolveColorSpace(t,e){return e===Ha?I.workingColorSpace:e===Ga?t.context.outputColorSpace||t.renderer.outputColorSpace:e}setup(t){const{colorNode:e}=this,s=this.resolveColorSpace(t,this.source),i=this.resolveColorSpace(t,this.target);let r=e;return!1!==I.enabled&&s!==i&&s&&i?(I.getTransfer(s)===h&&(r=Gi(ja(r.rgb),r.a)),I.getPrimaries(s)!==I.getPrimaries(i)&&(r=Gi(Ji(I._getMatrix(new A,s,i)).mul(r.rgb),r.a)),I.getTransfer(i)===h&&(r=Gi(qa(r.rgb),r.a)),r):r}}const $a=t=>Ni(new Xa(Ni(t),Ha,Ga)),Ya=t=>Ni(new Xa(Ni(t),Ga,Ha)),Za=(t,e)=>Ni(new Xa(Ni(t),Ha,e)),Ja=(t,e)=>Ni(new Xa(Ni(t),e,Ha));Zs("toOutputColorSpace",$a),Zs("toWorkingColorSpace",Ya),Zs("workingToColorSpace",Za),Zs("colorSpaceToWorking",Ja);let Qa=class extends Bs{static get type(){return"ReferenceElementNode"}constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),s=this.referenceNode.getNodeType(),i=this.getNodeType();return t.format(e,s,i)}};class Ka extends Ls{static get type(){return"ReferenceBaseNode"}constructor(t,e,s=null,i=null){super(),this.property=t,this.uniformType=e,this.object=s,this.count=i,this.properties=t.split("."),this.reference=s,this.node=null,this.group=null,this.updateType=zs.OBJECT}setGroup(t){return this.group=t,this}element(t){return Ni(new Qa(this,Ni(t)))}setNodeType(t){const e=ur(null,t).getSelf();null!==this.group&&e.setGroup(this.group),this.node=e}getNodeType(t){return null===this.node&&(this.updateReference(t),this.updateValue()),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let s=t[e[0]];for(let t=1;t<e.length;t++)s=s[e[t]];return s}updateReference(t){return this.reference=null!==this.object?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}class to extends Ka{static get type(){return"RendererReferenceNode"}constructor(t,e,s=null){super(t,e,s),this.renderer=s,this.setGroup(or)}updateReference(t){return this.reference=null!==this.renderer?this.renderer:t.renderer,this.reference}}const eo=(t,e,s=null)=>Ni(new to(t,e,s));class so extends Ps{static get type(){return"ToneMappingNode"}constructor(t,e=ro,s=null){super("vec3"),this.toneMapping=t,this.exposureNode=e,this.colorNode=s}customCacheKey(){return ys(this.toneMapping)}setup(t){const e=this.colorNode||t.context.color,s=this.toneMapping;if(0===s)return e;let i=null;const r=t.renderer.library.getToneMappingFunction(s);return null!==r?i=Gi(r(e.rgb,this.exposureNode),e.a):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),i=e),i}}const io=(t,e,s)=>Ni(new so(t,Ni(e),Ni(s))),ro=eo("toneMappingExposure","float");Zs("toneMapping",(t,e,s)=>io(e,s,t));class no extends qs{static get type(){return"BufferAttributeNode"}constructor(t,e=null,s=0,i=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferStride=s,this.bufferOffset=i,this.usage=u,this.instanced=!1,this.attribute=null,this.global=!0,t&&!0===t.isBufferAttribute&&(this.attribute=t,this.usage=t.usage,this.instanced=t.isInstancedBufferAttribute)}getHash(t){if(0===this.bufferStride&&0===this.bufferOffset){let e=t.globalCache.getData(this.value);return void 0===e&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getNodeType(t){return null===this.bufferType&&(this.bufferType=t.getTypeFromAttribute(this.attribute)),this.bufferType}setup(t){if(null!==this.attribute)return;const e=this.getNodeType(t),s=this.value,i=t.getTypeLength(e),r=this.bufferStride||i,n=this.bufferOffset,a=!0===s.isInterleavedBuffer?s:new ts(s,r),o=new ss(a,i,n);a.setUsage(this.usage),this.attribute=o,this.attribute.isInstancedBufferAttribute=this.instanced}generate(t){const e=this.getNodeType(t),s=t.getBufferAttributeFromNode(this,e),i=t.getPropertyName(s);let r=null;if("vertex"===t.shaderStage||"compute"===t.shaderStage)this.name=i,r=i;else{r=Ua(this).build(t,e)}return r}getInputType(){return"bufferAttribute"}setUsage(t){return this.usage=t,this.attribute&&!0===this.attribute.isBufferAttribute&&(this.attribute.usage=t),this}setInstanced(t){return this.instanced=t,this}}const ao=(t,e=null,s=0,i=0)=>Ni(new no(t,e,s,i)),oo=(t,e=null,s=0,i=0)=>ao(t,e,s,i).setUsage(c),ho=(t,e=null,s=0,i=0)=>ao(t,e,s,i).setInstanced(!0),lo=(t,e=null,s=0,i=0)=>oo(t,e,s,i).setInstanced(!0);Zs("toAttribute",t=>ao(t.value));class uo extends Ls{static get type(){return"ComputeNode"}constructor(t,e,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=t,this.count=e,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.name="",this.updateBeforeType=zs.OBJECT,this.onInitFunction=null,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}label(t){return this.name=t,this}updateDispatchCount(){const{count:t,workgroupSize:e}=this;let s=e[0];for(let t=1;t<e.length;t++)s*=e[t];this.dispatchCount=Math.ceil(t/s)}onInit(t){return this.onInitFunction=t,this}updateBefore({renderer:t}){t.compute(this)}generate(t){const{shaderStage:e}=t;if("compute"===e){const e=this.computeNode.build(t,"void");""!==e&&t.addLineFlowCode(e,this)}}}const co=(t,e,s)=>Ni(new uo(Ni(t),e,s));Zs("compute",co);class po extends Ls{static get type(){return"CacheNode"}constructor(t,e=!0){super(),this.node=t,this.parent=e,this.isCacheNode=!0}getNodeType(t){const e=t.getCache(),s=t.getCacheFromNode(this,this.parent);t.setCache(s);const i=this.node.getNodeType(t);return t.setCache(e),i}build(t,...e){const s=t.getCache(),i=t.getCacheFromNode(this,this.parent);t.setCache(i);const r=this.node.build(t,...e);return t.setCache(s),r}}const mo=(t,e)=>Ni(new po(Ni(t),e));Zs("cache",mo);class go extends Ls{static get type(){return"BypassNode"}constructor(t,e){super(),this.isBypassNode=!0,this.outputNode=t,this.callNode=e}getNodeType(t){return this.outputNode.getNodeType(t)}generate(t){const e=this.callNode.build(t,"void");return""!==e&&t.addLineFlowCode(e,this),this.outputNode.build(t)}}const yo=Si(go);Zs("bypass",yo);class fo extends Ls{static get type(){return"RemapNode"}constructor(t,e,s,i=Oi(0),r=Oi(1)){super(),this.node=t,this.inLowNode=e,this.inHighNode=s,this.outLowNode=i,this.outHighNode=r,this.doClamp=!0}setup(){const{node:t,inLowNode:e,inHighNode:s,outLowNode:i,outHighNode:r,doClamp:n}=this;let a=t.sub(e).div(s.sub(e));return!0===n&&(a=a.clamp()),a.mul(r.sub(i)).add(i)}}const xo=Si(fo,null,null,{doClamp:!1}),bo=Si(fo);Zs("remap",xo),Zs("remapClamp",bo);class vo extends Ls{static get type(){return"ExpressionNode"}constructor(t="",e="void"){super(e),this.snippet=t}generate(t,e){const s=this.getNodeType(t),i=this.snippet;if("void"!==s)return t.format(`( ${i} )`,s,e);t.addLineFlowCode(i,this)}}const wo=Si(vo),To=t=>(t?Ca(t,wo("discard")):wo("discard")).append();Zs("discard",To);class No extends Ps{static get type(){return"RenderOutputNode"}constructor(t,e,s){super("vec4"),this.colorNode=t,this.toneMapping=e,this.outputColorSpace=s,this.isRenderOutputNode=!0}setup({context:t}){let e=this.colorNode||t.color;const s=(null!==this.toneMapping?this.toneMapping:t.toneMapping)||0,i=(null!==this.outputColorSpace?this.outputColorSpace:t.outputColorSpace)||"";return 0!==s&&(e=e.toneMapping(s)),""!==i&&i!==I.workingColorSpace&&(e=e.workingToColorSpace(i)),e}}const Mo=(t,e=null,s=null)=>Ni(new No(Ni(t),e,s));Zs("renderOutput",Mo);class _o extends Ls{static get type(){return"AttributeNode"}constructor(t,e=null){super(e),this.global=!0,this._attributeName=t}getHash(t){return this.getAttributeName(t)}getNodeType(t){let e=this.nodeType;if(null===e){const s=this.getAttributeName(t);if(t.hasGeometryAttribute(s)){const i=t.geometry.getAttribute(s);e=t.getTypeFromAttribute(i)}else e="float"}return e}setAttributeName(t){return this._attributeName=t,this}getAttributeName(){return this._attributeName}generate(t){const e=this.getAttributeName(t),s=this.getNodeType(t);if(!0===t.hasGeometryAttribute(e)){const i=t.geometry.getAttribute(e),r=t.getTypeFromAttribute(i),n=t.getAttribute(e,r);if("vertex"===t.shaderStage)return t.format(n.name,r,s);return Ua(this).build(t,s)}return console.warn(`AttributeNode: Vertex attribute "${e}" not found on geometry.`),t.generateConst(s)}serialize(t){super.serialize(t),t.global=this.global,t._attributeName=this._attributeName}deserialize(t){super.deserialize(t),this.global=t.global,this._attributeName=t._attributeName}}const So=(t,e)=>Ni(new _o(t,e)),Ao=(t=0)=>So("uv"+(t>0?t:""),"vec2");class Vo extends Ls{static get type(){return"TextureSizeNode"}constructor(t,e=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=t,this.levelNode=e}generate(t,e){const s=this.textureNode.build(t,"property"),i=null===this.levelNode?"0":this.levelNode.build(t,"int");return t.format(`${t.getMethod("textureDimensions")}( ${s}, ${i} )`,this.getNodeType(t),e)}}const zo=Si(Vo);class Co extends lr{static get type(){return"MaxMipLevelNode"}constructor(t){super(0),this._textureNode=t,this.updateType=zs.FRAME}get textureNode(){return this._textureNode}get texture(){return this._textureNode.value}update(){const t=this.texture,e=t.images,s=e&&e.length>0?e[0]&&e[0].image||e[0]:t.image;if(s&&void 0!==s.width){const{width:t,height:e}=s;this.value=Math.log2(Math.max(t,e))}}}const Ro=Si(Co);class Eo extends lr{static get type(){return"TextureNode"}constructor(t,e=null,s=null,i=null){super(t),this.isTextureNode=!0,this.uvNode=e,this.levelNode=s,this.biasNode=i,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=zs.NONE,this.referenceNode=null,this._value=t,this._matrixUniform=null,this.setUpdateMatrix(null===e)}set value(t){this.referenceNode?this.referenceNode.value=t:this._value=t}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":1014===this.value.type?"uvec4":1013===this.value.type?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return Ao(this.value.channel)}updateReference(){return this.value}getTransformedUV(t){return null===this._matrixUniform&&(this._matrixUniform=ur(this.value.matrix)),this._matrixUniform.mul(Wi(t,1)).xy}setUpdateMatrix(t){return this.updateMatrix=t,this.updateType=t?zs.RENDER:zs.NONE,this}setupUV(t,e){const s=this.value;return t.isFlipY()&&(s.image instanceof ImageBitmap&&!0===s.flipY||!0===s.isRenderTargetTexture||!0===s.isFramebufferTexture||!0===s.isDepthTexture)&&(e=this.sampler?e.flipY():e.setY(Li(zo(this,this.levelNode).y).sub(e.y).sub(1))),e}setup(t){const e=t.getNodeProperties(this);e.referenceNode=this.referenceNode;const s=this.value;if(!s||!0!==s.isTexture)throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");let i=this.uvNode;null!==i&&!0!==t.context.forceUVContext||!t.context.getUV||(i=t.context.getUV(this)),i||(i=this.getDefaultUV()),!0===this.updateMatrix&&(i=this.getTransformedUV(i)),i=this.setupUV(t,i);let r=this.levelNode;null===r&&t.context.getTextureLevel&&(r=t.context.getTextureLevel(this)),e.uvNode=i,e.levelNode=r,e.biasNode=this.biasNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e.depthNode=this.depthNode}generateUV(t,e){return e.build(t,!0===this.sampler?"vec2":"ivec2")}generateSnippet(t,e,s,i,r,n,a,o){const h=this.value;let l;return l=i?t.generateTextureLevel(h,e,s,i,n):r?t.generateTextureBias(h,e,s,r,n):o?t.generateTextureGrad(h,e,s,o,n):a?t.generateTextureCompare(h,e,s,a,n):!1===this.sampler?t.generateTextureLoad(h,e,s,n):t.generateTexture(h,e,s,n),l}generate(t,e){const s=this.value,i=t.getNodeProperties(this),r=super.generate(t,"property");if("sampler"===e)return r+"_sampler";if(t.isReference(e))return r;{const n=t.getDataFromNode(this);let a=n.propertyName;if(void 0===a){const{uvNode:e,levelNode:s,biasNode:o,compareNode:h,depthNode:l,gradNode:u}=i,c=this.generateUV(t,e),d=s?s.build(t,"float"):null,p=o?o.build(t,"float"):null,m=l?l.build(t,"int"):null,g=h?h.build(t,"float"):null,y=u?[u[0].build(t,"vec2"),u[1].build(t,"vec2")]:null,f=t.getVarFromNode(this);a=t.getPropertyName(f);const x=this.generateSnippet(t,r,c,d,p,m,g,y);t.addLineFlowCode(`${a} = ${x}`,this),n.snippet=x,n.propertyName=a}let o=a;const h=this.getNodeType(t);return t.needsToWorkingColorSpace(s)&&(o=Ja(wo(o,h),s.colorSpace).setup(t).build(t,h)),t.format(o,h,e)}}setSampler(t){return this.sampler=t,this}getSampler(){return this.sampler}uv(t){return console.warn("THREE.TextureNode: .uv() has been renamed. Use .sample() instead."),this.sample(t)}sample(t){const e=this.clone();return e.uvNode=Ni(t),e.referenceNode=this.getSelf(),Ni(e)}blur(t){const e=this.clone();return e.biasNode=Ni(t).mul(Ro(e)),e.referenceNode=this.getSelf(),Ni(e)}level(t){const e=this.clone();return e.levelNode=Ni(t),e.referenceNode=this.getSelf(),Ni(e)}size(t){return zo(this,t)}bias(t){const e=this.clone();return e.biasNode=Ni(t),e.referenceNode=this.getSelf(),Ni(e)}compare(t){const e=this.clone();return e.compareNode=Ni(t),e.referenceNode=this.getSelf(),Ni(e)}grad(t,e){const s=this.clone();return s.gradNode=[Ni(t),Ni(e)],s.referenceNode=this.getSelf(),Ni(s)}depth(t){const e=this.clone();return e.depthNode=Ni(t),e.referenceNode=this.getSelf(),Ni(e)}serialize(t){super.serialize(t),t.value=this.value.toJSON(t.meta).uuid,t.sampler=this.sampler,t.updateMatrix=this.updateMatrix,t.updateType=this.updateType}deserialize(t){super.deserialize(t),this.value=t.meta.textures[t.value],this.sampler=t.sampler,this.updateMatrix=t.updateMatrix,this.updateType=t.updateType}update(){const t=this.value,e=this._matrixUniform;null!==e&&(e.value=t.matrix),!0===t.matrixAutoUpdate&&t.updateMatrix()}clone(){const t=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return t.sampler=this.sampler,t}}const Io=Si(Eo),Oo=(...t)=>Io(...t).setSampler(!1);class Lo extends lr{static get type(){return"BufferNode"}constructor(t,e,s=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferCount=s}getElementType(t){return this.getNodeType(t)}getInputType(){return"buffer"}}const Bo=(t,e,s)=>Ni(new Lo(t,e,s));class Fo extends Bs{static get type(){return"UniformArrayElementNode"}constructor(t,e){super(t,e),this.isArrayBufferElementNode=!0}generate(t){const e=super.generate(t),s=this.getNodeType(),i=this.node.getPaddedType();return t.format(e,i,s)}}class Po extends Lo{static get type(){return"UniformArrayNode"}constructor(t,e=null){super(null),this.array=t,this.elementType=null===e?Ns(t[0]):e,this.paddedType=this.getPaddedType(),this.updateType=zs.RENDER,this.isArrayBufferNode=!0}getNodeType(){return this.paddedType}getElementType(){return this.elementType}getPaddedType(){const t=this.elementType;let e="vec4";return"mat2"===t?e="mat2":!0===/mat/.test(t)?e="mat4":"i"===t.charAt(0)?e="ivec4":"u"===t.charAt(0)&&(e="uvec4"),e}update(){const{array:t,value:e}=this,s=this.elementType;if("float"===s||"int"===s||"uint"===s)for(let s=0;s<t.length;s++){e[4*s]=t[s]}else if("color"===s)for(let s=0;s<t.length;s++){const i=4*s,r=t[s];e[i]=r.r,e[i+1]=r.g,e[i+2]=r.b||0}else if("mat2"===s)for(let s=0;s<t.length;s++){const i=4*s,r=t[s];e[i]=r.elements[0],e[i+1]=r.elements[1],e[i+2]=r.elements[2],e[i+3]=r.elements[3]}else if("mat3"===s)for(let s=0;s<t.length;s++){const i=16*s,r=t[s];e[i]=r.elements[0],e[i+1]=r.elements[1],e[i+2]=r.elements[2],e[i+4]=r.elements[3],e[i+5]=r.elements[4],e[i+6]=r.elements[5],e[i+8]=r.elements[6],e[i+9]=r.elements[7],e[i+10]=r.elements[8],e[i+15]=1}else if("mat4"===s)for(let s=0;s<t.length;s++){const i=16*s,r=t[s];for(let t=0;t<r.elements.length;t++)e[i+t]=r.elements[t]}else for(let s=0;s<t.length;s++){const i=4*s,r=t[s];e[i]=r.x,e[i+1]=r.y,e[i+2]=r.z||0,e[i+3]=r.w||0}}setup(t){const e=this.array.length,s=this.elementType;let i=Float32Array;const r=this.paddedType,n=t.getTypeLength(r);return"i"===s.charAt(0)&&(i=Int32Array),"u"===s.charAt(0)&&(i=Uint32Array),this.value=new i(e*n),this.bufferCount=e,this.bufferType=r,super.setup(t)}element(t){return Ni(new Fo(this,Ni(t)))}}const Do=(t,e)=>Ni(new Po(t,e)),ko=ur(0,"uint").setGroup(nr("cameraIndex")).toVarying("v_cameraIndex"),Uo=ur("float").label("cameraNear").setGroup(or).onRenderUpdate(({camera:t})=>t.near),Wo=ur("float").label("cameraFar").setGroup(or).onRenderUpdate(({camera:t})=>t.far),jo=Vi(({camera:t})=>{let e;if(t.isArrayCamera&&t.cameras.length>0){const s=[];for(const e of t.cameras)s.push(e.projectionMatrix);e=Do(s).setGroup(or).label("cameraProjectionMatrices").element(ko).toVar("cameraProjectionMatrix")}else e=ur("mat4").label("cameraProjectionMatrix").setGroup(or).onRenderUpdate(({camera:t})=>t.projectionMatrix);return e}).once()(),qo=ur("mat4").label("cameraProjectionMatrixInverse").setGroup(or).onRenderUpdate(({camera:t})=>t.projectionMatrixInverse),Ho=Vi(({camera:t})=>{let e;if(t.isArrayCamera&&t.cameras.length>0){const s=[];for(const e of t.cameras)s.push(e.matrixWorldInverse);e=Do(s).setGroup(or).label("cameraViewMatrices").element(ko).toVar("cameraViewMatrix")}else e=ur("mat4").label("cameraViewMatrix").setGroup(or).onRenderUpdate(({camera:t})=>t.matrixWorldInverse);return e}).once()(),Go=ur("mat4").label("cameraWorldMatrix").setGroup(or).onRenderUpdate(({camera:t})=>t.matrixWorld),Xo=ur("mat3").label("cameraNormalMatrix").setGroup(or).onRenderUpdate(({camera:t})=>t.normalMatrix),$o=ur(new X).label("cameraPosition").setGroup(or).onRenderUpdate(({camera:t},e)=>e.value.setFromMatrixPosition(t.matrixWorld)),Yo=new mt;class Zo extends Ls{static get type(){return"Object3DNode"}constructor(t,e=null){super(),this.scope=t,this.object3d=e,this.updateType=zs.OBJECT,this._uniformNode=new lr(null)}getNodeType(){const t=this.scope;return t===Zo.WORLD_MATRIX?"mat4":t===Zo.POSITION||t===Zo.VIEW_POSITION||t===Zo.DIRECTION||t===Zo.SCALE?"vec3":t===Zo.RADIUS?"float":void 0}update(t){const e=this.object3d,s=this._uniformNode,i=this.scope;if(i===Zo.WORLD_MATRIX)s.value=e.matrixWorld;else if(i===Zo.POSITION)s.value=s.value||new X,s.value.setFromMatrixPosition(e.matrixWorld);else if(i===Zo.SCALE)s.value=s.value||new X,s.value.setFromMatrixScale(e.matrixWorld);else if(i===Zo.DIRECTION)s.value=s.value||new X,e.getWorldDirection(s.value);else if(i===Zo.VIEW_POSITION){const i=t.camera;s.value=s.value||new X,s.value.setFromMatrixPosition(e.matrixWorld),s.value.applyMatrix4(i.matrixWorldInverse)}else if(i===Zo.RADIUS){const i=t.object.geometry;null===i.boundingSphere&&i.computeBoundingSphere(),Yo.copy(i.boundingSphere).applyMatrix4(e.matrixWorld),s.value=Yo.radius}}generate(t){const e=this.scope;return e===Zo.WORLD_MATRIX?this._uniformNode.nodeType="mat4":e===Zo.POSITION||e===Zo.VIEW_POSITION||e===Zo.DIRECTION||e===Zo.SCALE?this._uniformNode.nodeType="vec3":e===Zo.RADIUS&&(this._uniformNode.nodeType="float"),this._uniformNode.build(t)}serialize(t){super.serialize(t),t.scope=this.scope}deserialize(t){super.deserialize(t),this.scope=t.scope}}Zo.WORLD_MATRIX="worldMatrix",Zo.POSITION="position",Zo.SCALE="scale",Zo.VIEW_POSITION="viewPosition",Zo.DIRECTION="direction",Zo.RADIUS="radius";const Jo=Si(Zo,Zo.DIRECTION),Qo=Si(Zo,Zo.WORLD_MATRIX),Ko=Si(Zo,Zo.POSITION),th=Si(Zo,Zo.SCALE),eh=Si(Zo,Zo.VIEW_POSITION),sh=Si(Zo,Zo.RADIUS);class ih extends Zo{static get type(){return"ModelNode"}constructor(t){super(t)}update(t){this.object3d=t.object,super.update(t)}}const rh=Ai(ih,ih.DIRECTION),nh=Ai(ih,ih.WORLD_MATRIX),ah=Ai(ih,ih.POSITION),oh=Ai(ih,ih.SCALE),hh=Ai(ih,ih.VIEW_POSITION),lh=Ai(ih,ih.RADIUS),uh=ur(new A).onObjectUpdate(({object:t},e)=>e.value.getNormalMatrix(t.matrixWorld)),ch=ur(new Nt).onObjectUpdate(({object:t},e)=>e.value.copy(t.matrixWorld).invert()),dh=Vi(t=>t.renderer.nodes.modelViewMatrix||ph).once()().toVar("modelViewMatrix"),ph=Ho.mul(nh),mh=Vi(t=>(t.context.isHighPrecisionModelViewMatrix=!0,ur("mat4").onObjectUpdate(({object:t,camera:e})=>t.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse,t.matrixWorld)))).once()().toVar("highpModelViewMatrix"),gh=Vi(t=>{const e=t.context.isHighPrecisionModelViewMatrix;return ur("mat3").onObjectUpdate(({object:t,camera:s})=>(!0!==e&&t.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix)))}).once()().toVar("highpModelNormalViewMatrix"),yh=So("position","vec3"),fh=yh.toVarying("positionLocal"),xh=yh.toVarying("positionPrevious"),bh=nh.mul(fh).xyz.toVarying("v_positionWorld").context({needsPositionReassign:!0}),vh=fh.transformDirection(nh).toVarying("v_positionWorldDirection").normalize().toVar("positionWorldDirection").context({needsPositionReassign:!0}),wh=Vi(t=>t.context.setupPositionView(),"vec3").once()().toVarying("v_positionView").context({needsPositionReassign:!0}),Th=wh.negate().toVarying("v_positionViewDirection").normalize().toVar("positionViewDirection");class Nh extends Ls{static get type(){return"FrontFacingNode"}constructor(){super("bool"),this.isFrontFacingNode=!0}generate(t){const{renderer:e,material:s}=t;return e.coordinateSystem===d&&1===s.side?"false":t.getFrontFacing()}}const Mh=Ai(Nh),_h=Oi(Mh).mul(2).sub(1),Sh=So("normal","vec3"),Ah=Vi(t=>!1===t.geometry.hasAttribute("normal")?(console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'),Wi(0,1,0)):Sh,"vec3").once()().toVar("normalLocal"),Vh=wh.dFdx().cross(wh.dFdy()).normalize().toVar("normalFlat"),zh=Vi(t=>{let e;return e=!0===t.material.flatShading?Vh:Ua(Lh(Ah),"v_normalView").normalize(),e},"vec3").once()().toVar("normalView"),Ch=Ua(zh.transformDirection(Ho),"v_normalWorld").normalize().toVar("normalWorld"),Rh=Vi(t=>t.context.setupNormal().context({getUV:null}),"vec3").once()().mul(_h).toVar("transformedNormalView"),Eh=Rh.transformDirection(Ho).toVar("transformedNormalWorld"),Ih=Vi(t=>t.context.setupClearcoatNormal().context({getUV:null}),"vec3").once()().mul(_h).toVar("transformedClearcoatNormalView"),Oh=Vi(([t,e=nh])=>{const s=Ji(e),i=t.div(Wi(s[0].dot(s[0]),s[1].dot(s[1]),s[2].dot(s[2])));return s.mul(i).xyz}),Lh=Vi(([t],e)=>{const s=e.renderer.nodes.modelNormalViewMatrix;if(null!==s)return s.transformDirection(t);const i=uh.mul(t);return Ho.transformDirection(i)}),Bh=new It,Fh=new Nt,Ph=ur(0).onReference(({material:t})=>t).onObjectUpdate(({material:t})=>t.refractionRatio),Dh=ur(1).onReference(({material:t})=>t).onObjectUpdate(function({material:t,scene:e}){return t.envMap?t.envMapIntensity:e.environmentIntensity}),kh=ur(new Nt).onReference(function(t){return t.material}).onObjectUpdate(function({material:t,scene:e}){const s=null!==e.environment&&null===t.envMap?e.environmentRotation:t.envMapRotation;return s?(Bh.copy(s),Fh.makeRotationFromEuler(Bh)):Fh.identity(),Fh}),Uh=Th.negate().reflect(Rh),Wh=Th.negate().refract(Rh,Ph),jh=Uh.transformDirection(Ho).toVar("reflectVector"),qh=Wh.transformDirection(Ho).toVar("reflectVector");class Hh extends Eo{static get type(){return"CubeTextureNode"}constructor(t,e=null,s=null,i=null){super(t,e,s,i),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){const t=this.value;return 301===t.mapping?jh:302===t.mapping?qh:(console.error('THREE.CubeTextureNode: Mapping "%s" not supported.',t.mapping),Wi(0,0,0))}setUpdateMatrix(){}setupUV(t,e){const s=this.value;return t.renderer.coordinateSystem!==p&&s.isRenderTargetTexture||(e=Wi(e.x.negate(),e.yz)),kh.mul(e)}generateUV(t,e){return e.build(t,"vec3")}}const Gh=Si(Hh);class Xh extends Bs{static get type(){return"ReferenceElementNode"}constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),s=this.referenceNode.getNodeType(),i=this.getNodeType();return t.format(e,s,i)}}class $h extends Ls{static get type(){return"ReferenceNode"}constructor(t,e,s=null,i=null){super(),this.property=t,this.uniformType=e,this.object=s,this.count=i,this.properties=t.split("."),this.reference=s,this.node=null,this.group=null,this.name=null,this.updateType=zs.OBJECT}element(t){return Ni(new Xh(this,Ni(t)))}setGroup(t){return this.group=t,this}label(t){return this.name=t,this}setNodeType(t){let e=null;e=null!==this.count?Bo(null,t,this.count):Array.isArray(this.getValueFromReference())?Do(null,t):"texture"===t?Io(null):"cubeTexture"===t?Gh(null):ur(null,t),null!==this.group&&e.setGroup(this.group),null!==this.name&&e.label(this.name),this.node=e.getSelf()}getNodeType(t){return null===this.node&&(this.updateReference(t),this.updateValue()),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let s=t[e[0]];for(let t=1;t<e.length;t++)s=s[e[t]];return s}updateReference(t){return this.reference=null!==this.object?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}const Yh=(t,e,s)=>Ni(new $h(t,e,s)),Zh=(t,e,s,i)=>Ni(new $h(t,e,i,s));class Jh extends $h{static get type(){return"MaterialReferenceNode"}constructor(t,e,s=null){super(t,e,s),this.material=s,this.isMaterialReferenceNode=!0}updateReference(t){return this.reference=null!==this.material?this.material:t.material,this.reference}}const Qh=(t,e,s=null)=>Ni(new Jh(t,e,s)),Kh=Vi(t=>(!1===t.geometry.hasAttribute("tangent")&&t.geometry.computeTangents(),So("tangent","vec4")))(),tl=Kh.xyz.toVar("tangentLocal"),el=dh.mul(Gi(tl,0)).xyz.toVarying("v_tangentView").normalize().toVar("tangentView"),sl=el.transformDirection(Ho).toVarying("v_tangentWorld").normalize().toVar("tangentWorld"),il=el.toVar("transformedTangentView"),rl=il.transformDirection(Ho).normalize().toVar("transformedTangentWorld"),nl=t=>t.mul(Kh.w).xyz,al=Ua(nl(Sh.cross(Kh)),"v_bitangentGeometry").normalize().toVar("bitangentGeometry"),ol=Ua(nl(Ah.cross(tl)),"v_bitangentLocal").normalize().toVar("bitangentLocal"),hl=Ua(nl(zh.cross(el)),"v_bitangentView").normalize().toVar("bitangentView"),ll=Ua(nl(Ch.cross(sl)),"v_bitangentWorld").normalize().toVar("bitangentWorld"),ul=nl(Rh.cross(il)).normalize().toVar("transformedBitangentView"),cl=ul.transformDirection(Ho).normalize().toVar("transformedBitangentWorld"),dl=Ji(el,hl,zh),pl=Th.mul(dl),ml=(()=>{let t=Vr.cross(Th);return t=t.cross(Vr).normalize(),t=fa(t,Rh,Sr.mul(yr.oneMinus()).oneMinus().pow2().pow2()).normalize(),t})(),gl=Vi(t=>{const{eye_pos:e,surf_norm:s,mapN:i,uv:r}=t,n=e.dFdx(),a=e.dFdy(),o=r.dFdx(),h=r.dFdy(),l=s,u=a.cross(l),c=l.cross(n),d=u.mul(o.x).add(c.mul(h.x)),p=u.mul(o.y).add(c.mul(h.y)),m=d.dot(d).max(p.dot(p)),g=_h.mul(m.inverseSqrt());return Xr(d.mul(i.x,g),p.mul(i.y,g),l.mul(i.z)).normalize()});class yl extends Ps{static get type(){return"NormalMapNode"}constructor(t,e=null){super("vec3"),this.node=t,this.scaleNode=e,this.normalMapType=0}setup(t){const{normalMapType:e,scaleNode:s}=this;let i=this.node.mul(2).sub(1);null!==s&&(i=Wi(i.xy.mul(s),i.z));let r=null;if(1===e)r=Lh(i);else if(0===e){r=!0===t.hasGeometryAttribute("tangent")?dl.mul(i).normalize():gl({eye_pos:wh,surf_norm:zh,mapN:i,uv:Ao()})}return r}}const fl=Si(yl),xl=Vi(({textureNode:t,bumpScale:e})=>{const s=e=>t.cache().context({getUV:t=>e(t.uvNode||Ao()),forceUVContext:!0}),i=Oi(s(t=>t));return Pi(Oi(s(t=>t.add(t.dFdx()))).sub(i),Oi(s(t=>t.add(t.dFdy()))).sub(i)).mul(e)}),bl=Vi(t=>{const{surf_pos:e,surf_norm:s,dHdxy:i}=t,r=e.dFdx().normalize(),n=s,a=e.dFdy().normalize().cross(n),o=n.cross(r),h=r.dot(a).mul(_h),l=h.sign().mul(i.x.mul(a).add(i.y.mul(o)));return h.abs().mul(s).sub(l).normalize()});class vl extends Ps{static get type(){return"BumpMapNode"}constructor(t,e=null){super("vec3"),this.textureNode=t,this.scaleNode=e}setup(){const t=null!==this.scaleNode?this.scaleNode:1,e=xl({textureNode:this.textureNode,bumpScale:t});return bl({surf_pos:wh,surf_norm:zh,dHdxy:e})}}const wl=Si(vl),Tl=new Map;class Nl extends Ls{static get type(){return"MaterialNode"}constructor(t){super(),this.scope=t}getCache(t,e){let s=Tl.get(t);return void 0===s&&(s=Qh(t,e),Tl.set(t,s)),s}getFloat(t){return this.getCache(t,"float")}getColor(t){return this.getCache(t,"color")}getTexture(t){return this.getCache("map"===t?"map":t+"Map","texture")}setup(t){const e=t.context.material,s=this.scope;let i=null;if(s===Nl.COLOR){const t=void 0!==e.color?this.getColor(s):Wi();i=e.map&&!0===e.map.isTexture?t.mul(this.getTexture("map")):t}else if(s===Nl.OPACITY){const t=this.getFloat(s);i=e.alphaMap&&!0===e.alphaMap.isTexture?t.mul(this.getTexture("alpha")):t}else if(s===Nl.SPECULAR_STRENGTH)i=e.specularMap&&!0===e.specularMap.isTexture?this.getTexture("specular").r:Oi(1);else if(s===Nl.SPECULAR_INTENSITY){const t=this.getFloat(s);i=e.specularIntensityMap&&!0===e.specularIntensityMap.isTexture?t.mul(this.getTexture(s).a):t}else if(s===Nl.SPECULAR_COLOR){const t=this.getColor(s);i=e.specularColorMap&&!0===e.specularColorMap.isTexture?t.mul(this.getTexture(s).rgb):t}else if(s===Nl.ROUGHNESS){const t=this.getFloat(s);i=e.roughnessMap&&!0===e.roughnessMap.isTexture?t.mul(this.getTexture(s).g):t}else if(s===Nl.METALNESS){const t=this.getFloat(s);i=e.metalnessMap&&!0===e.metalnessMap.isTexture?t.mul(this.getTexture(s).b):t}else if(s===Nl.EMISSIVE){const t=this.getFloat("emissiveIntensity"),r=this.getColor(s).mul(t);i=e.emissiveMap&&!0===e.emissiveMap.isTexture?r.mul(this.getTexture(s)):r}else if(s===Nl.NORMAL)e.normalMap?(i=fl(this.getTexture("normal"),this.getCache("normalScale","vec2")),i.normalMapType=e.normalMapType):i=e.bumpMap?wl(this.getTexture("bump").r,this.getFloat("bumpScale")):zh;else if(s===Nl.CLEARCOAT){const t=this.getFloat(s);i=e.clearcoatMap&&!0===e.clearcoatMap.isTexture?t.mul(this.getTexture(s).r):t}else if(s===Nl.CLEARCOAT_ROUGHNESS){const t=this.getFloat(s);i=e.clearcoatRoughnessMap&&!0===e.clearcoatRoughnessMap.isTexture?t.mul(this.getTexture(s).r):t}else if(s===Nl.CLEARCOAT_NORMAL)i=e.clearcoatNormalMap?fl(this.getTexture(s),this.getCache(s+"Scale","vec2")):zh;else if(s===Nl.SHEEN){const t=this.getColor("sheenColor").mul(this.getFloat("sheen"));i=e.sheenColorMap&&!0===e.sheenColorMap.isTexture?t.mul(this.getTexture("sheenColor").rgb):t}else if(s===Nl.SHEEN_ROUGHNESS){const t=this.getFloat(s);i=e.sheenRoughnessMap&&!0===e.sheenRoughnessMap.isTexture?t.mul(this.getTexture(s).a):t,i=i.clamp(.07,1)}else if(s===Nl.ANISOTROPY)if(e.anisotropyMap&&!0===e.anisotropyMap.isTexture){const t=this.getTexture(s);i=Zi(ou.x,ou.y,ou.y.negate(),ou.x).mul(t.rg.mul(2).sub(Pi(1)).normalize().mul(t.b))}else i=ou;else if(s===Nl.IRIDESCENCE_THICKNESS){const t=Yh("1","float",e.iridescenceThicknessRange);if(e.iridescenceThicknessMap){const r=Yh("0","float",e.iridescenceThicknessRange);i=t.sub(r).mul(this.getTexture(s).g).add(r)}else i=t}else if(s===Nl.TRANSMISSION){const t=this.getFloat(s);i=e.transmissionMap?t.mul(this.getTexture(s).r):t}else if(s===Nl.THICKNESS){const t=this.getFloat(s);i=e.thicknessMap?t.mul(this.getTexture(s).g):t}else if(s===Nl.IOR)i=this.getFloat(s);else if(s===Nl.LIGHT_MAP)i=this.getTexture(s).rgb.mul(this.getFloat("lightMapIntensity"));else if(s===Nl.AO)i=this.getTexture(s).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else{const e=this.getNodeType(t);i=this.getCache(s,e)}return i}}Nl.ALPHA_TEST="alphaTest",Nl.COLOR="color",Nl.OPACITY="opacity",Nl.SHININESS="shininess",Nl.SPECULAR="specular",Nl.SPECULAR_STRENGTH="specularStrength",Nl.SPECULAR_INTENSITY="specularIntensity",Nl.SPECULAR_COLOR="specularColor",Nl.REFLECTIVITY="reflectivity",Nl.ROUGHNESS="roughness",Nl.METALNESS="metalness",Nl.NORMAL="normal",Nl.CLEARCOAT="clearcoat",Nl.CLEARCOAT_ROUGHNESS="clearcoatRoughness",Nl.CLEARCOAT_NORMAL="clearcoatNormal",Nl.EMISSIVE="emissive",Nl.ROTATION="rotation",Nl.SHEEN="sheen",Nl.SHEEN_ROUGHNESS="sheenRoughness",Nl.ANISOTROPY="anisotropy",Nl.IRIDESCENCE="iridescence",Nl.IRIDESCENCE_IOR="iridescenceIOR",Nl.IRIDESCENCE_THICKNESS="iridescenceThickness",Nl.IOR="ior",Nl.TRANSMISSION="transmission",Nl.THICKNESS="thickness",Nl.ATTENUATION_DISTANCE="attenuationDistance",Nl.ATTENUATION_COLOR="attenuationColor",Nl.LINE_SCALE="scale",Nl.LINE_DASH_SIZE="dashSize",Nl.LINE_GAP_SIZE="gapSize",Nl.LINE_WIDTH="linewidth",Nl.LINE_DASH_OFFSET="dashOffset",Nl.POINT_SIZE="size",Nl.DISPERSION="dispersion",Nl.LIGHT_MAP="light",Nl.AO="ao";const Ml=Ai(Nl,Nl.ALPHA_TEST),_l=Ai(Nl,Nl.COLOR),Sl=Ai(Nl,Nl.SHININESS),Al=Ai(Nl,Nl.EMISSIVE),Vl=Ai(Nl,Nl.OPACITY),zl=Ai(Nl,Nl.SPECULAR),Cl=Ai(Nl,Nl.SPECULAR_INTENSITY),Rl=Ai(Nl,Nl.SPECULAR_COLOR),El=Ai(Nl,Nl.SPECULAR_STRENGTH),Il=Ai(Nl,Nl.REFLECTIVITY),Ol=Ai(Nl,Nl.ROUGHNESS),Ll=Ai(Nl,Nl.METALNESS),Bl=Ai(Nl,Nl.NORMAL),Fl=Ai(Nl,Nl.CLEARCOAT),Pl=Ai(Nl,Nl.CLEARCOAT_ROUGHNESS),Dl=Ai(Nl,Nl.CLEARCOAT_NORMAL),kl=Ai(Nl,Nl.ROTATION),Ul=Ai(Nl,Nl.SHEEN),Wl=Ai(Nl,Nl.SHEEN_ROUGHNESS),jl=Ai(Nl,Nl.ANISOTROPY),ql=Ai(Nl,Nl.IRIDESCENCE),Hl=Ai(Nl,Nl.IRIDESCENCE_IOR),Gl=Ai(Nl,Nl.IRIDESCENCE_THICKNESS),Xl=Ai(Nl,Nl.TRANSMISSION),$l=Ai(Nl,Nl.THICKNESS),Yl=Ai(Nl,Nl.IOR),Zl=Ai(Nl,Nl.ATTENUATION_DISTANCE),Jl=Ai(Nl,Nl.ATTENUATION_COLOR),Ql=Ai(Nl,Nl.LINE_SCALE),Kl=Ai(Nl,Nl.LINE_DASH_SIZE),tu=Ai(Nl,Nl.LINE_GAP_SIZE),eu=Ai(Nl,Nl.LINE_WIDTH),su=Ai(Nl,Nl.LINE_DASH_OFFSET),iu=Ai(Nl,Nl.POINT_SIZE),ru=Ai(Nl,Nl.DISPERSION),nu=Ai(Nl,Nl.LIGHT_MAP),au=Ai(Nl,Nl.AO),ou=ur(new S).onReference(function(t){return t.material}).onRenderUpdate(function({material:t}){this.value.set(t.anisotropy*Math.cos(t.anisotropyRotation),t.anisotropy*Math.sin(t.anisotropyRotation))}),hu=Vi(t=>t.context.setupModelViewProjection(),"vec4").once()().toVarying("v_modelViewProjection");class lu extends Ls{static get type(){return"IndexNode"}constructor(t){super("uint"),this.scope=t,this.isIndexNode=!0}generate(t){const e=this.getNodeType(t),s=this.scope;let i,r;if(s===lu.VERTEX)i=t.getVertexIndex();else if(s===lu.INSTANCE)i=t.getInstanceIndex();else if(s===lu.DRAW)i=t.getDrawIndex();else if(s===lu.INVOCATION_LOCAL)i=t.getInvocationLocalIndex();else if(s===lu.INVOCATION_SUBGROUP)i=t.getInvocationSubgroupIndex();else{if(s!==lu.SUBGROUP)throw new Error("THREE.IndexNode: Unknown scope: "+s);i=t.getSubgroupIndex()}if("vertex"===t.shaderStage||"compute"===t.shaderStage)r=i;else{r=Ua(this).build(t,e)}return r}}lu.VERTEX="vertex",lu.INSTANCE="instance",lu.SUBGROUP="subgroup",lu.INVOCATION_LOCAL="invocationLocal",lu.INVOCATION_SUBGROUP="invocationSubgroup",lu.DRAW="draw";const uu=Ai(lu,lu.VERTEX),cu=Ai(lu,lu.INSTANCE),du=Ai(lu,lu.SUBGROUP),pu=Ai(lu,lu.INVOCATION_SUBGROUP),mu=Ai(lu,lu.INVOCATION_LOCAL),gu=Ai(lu,lu.DRAW);class yu extends Ls{static get type(){return"InstanceNode"}constructor(t,e,s){super("void"),this.count=t,this.instanceMatrix=e,this.instanceColor=s,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=zs.FRAME,this.buffer=null,this.bufferColor=null}setup(t){const{count:e,instanceMatrix:s,instanceColor:i}=this;let{instanceMatrixNode:r,instanceColorNode:n}=this;if(null===r){if(e<=1e3)r=Bo(s.array,"mat4",Math.max(e,1)).element(cu);else{const t=new us(s.array,16,1);this.buffer=t;const e=s.usage===c?lo:ho,i=[e(t,"vec4",16,0),e(t,"vec4",16,4),e(t,"vec4",16,8),e(t,"vec4",16,12)];r=Qi(...i)}this.instanceMatrixNode=r}if(i&&null===n){const t=new is(i.array,3),e=i.usage===c?lo:ho;this.bufferColor=t,n=Wi(e(t,"vec3",3,0)),this.instanceColorNode=n}const a=r.mul(fh).xyz;if(fh.assign(a),t.hasGeometryAttribute("normal")){const t=Oh(Ah,r);Ah.assign(t)}null!==this.instanceColorNode&&pr("vec3","vInstanceColor").assign(this.instanceColorNode)}update(){this.instanceMatrix.usage!==c&&null!==this.buffer&&this.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMatrix.version),this.instanceColor&&this.instanceColor.usage!==c&&null!==this.bufferColor&&this.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceColor.version)}}const fu=Si(yu);class xu extends yu{static get type(){return"InstancedMeshNode"}constructor(t){const{count:e,instanceMatrix:s,instanceColor:i}=t;super(e,s,i),this.instancedMesh=t}}const bu=Si(xu);class vu extends Ls{static get type(){return"BatchNode"}constructor(t){super("void"),this.batchMesh=t,this.batchingIdNode=null}setup(t){null===this.batchingIdNode&&(null===t.getDrawIndex()?this.batchingIdNode=cu:this.batchingIdNode=gu);const e=Vi(([t])=>{const e=Li(zo(Oo(this.batchMesh._indirectTexture),0)),s=Li(t).modInt(e),i=Li(t).div(e);return Oo(this.batchMesh._indirectTexture,Di(s,i)).x}).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]}),s=e(Li(this.batchingIdNode)),i=this.batchMesh._matricesTexture,r=zo(Oo(i),0),n=Oi(s).mul(4).toInt().toVar(),a=n.modInt(r),o=n.div(Li(r)),h=Qi(Oo(i,Di(a,o)),Oo(i,Di(a.add(1),o)),Oo(i,Di(a.add(2),o)),Oo(i,Di(a.add(3),o))),l=this.batchMesh._colorsTexture;if(null!==l){const t=Vi(([t])=>{const e=zo(Oo(l),0).x,s=t,i=s.modInt(e),r=s.div(e);return Oo(l,Di(i,r)).rgb}).setLayout({name:"getBatchingColor",type:"vec3",inputs:[{name:"id",type:"int"}]}),e=t(s);pr("vec3","vBatchColor").assign(e)}const u=Ji(h);fh.assign(h.mul(fh));const c=Ah.div(Wi(u[0].dot(u[0]),u[1].dot(u[1]),u[2].dot(u[2]))),d=u.mul(c).xyz;Ah.assign(d),t.hasGeometryAttribute("tangent")&&tl.mulAssign(u)}}const wu=Si(vu),Tu=new WeakMap;class Nu extends Ls{static get type(){return"SkinningNode"}constructor(t,e=!1){let s,i,r;super("void"),this.skinnedMesh=t,this.useReference=e,this.updateType=zs.OBJECT,this.skinIndexNode=So("skinIndex","uvec4"),this.skinWeightNode=So("skinWeight","vec4"),e?(s=Yh("bindMatrix","mat4"),i=Yh("bindMatrixInverse","mat4"),r=Zh("skeleton.boneMatrices","mat4",t.skeleton.bones.length)):(s=ur(t.bindMatrix,"mat4"),i=ur(t.bindMatrixInverse,"mat4"),r=Bo(t.skeleton.boneMatrices,"mat4",t.skeleton.bones.length)),this.bindMatrixNode=s,this.bindMatrixInverseNode=i,this.boneMatricesNode=r,this.previousBoneMatricesNode=null}getSkinnedPosition(t=this.boneMatricesNode,e=fh){const{skinIndexNode:s,skinWeightNode:i,bindMatrixNode:r,bindMatrixInverseNode:n}=this,a=t.element(s.x),o=t.element(s.y),h=t.element(s.z),l=t.element(s.w),u=r.mul(e),c=Xr(a.mul(i.x).mul(u),o.mul(i.y).mul(u),h.mul(i.z).mul(u),l.mul(i.w).mul(u));return n.mul(c).xyz}getSkinnedNormal(t=this.boneMatricesNode,e=Ah){const{skinIndexNode:s,skinWeightNode:i,bindMatrixNode:r,bindMatrixInverseNode:n}=this,a=t.element(s.x),o=t.element(s.y),h=t.element(s.z),l=t.element(s.w);let u=Xr(i.x.mul(a),i.y.mul(o),i.z.mul(h),i.w.mul(l));return u=n.mul(u).mul(r),u.transformDirection(e).xyz}getPreviousSkinnedPosition(t){const e=t.object;return null===this.previousBoneMatricesNode&&(e.skeleton.previousBoneMatrices=new Float32Array(e.skeleton.boneMatrices),this.previousBoneMatricesNode=Zh("skeleton.previousBoneMatrices","mat4",e.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,xh)}needsPreviousBoneMatrices(t){const e=t.renderer.getMRT();return e&&e.has("velocity")||!0===_s(t.object).useVelocity}setup(t){this.needsPreviousBoneMatrices(t)&&xh.assign(this.getPreviousSkinnedPosition(t));const e=this.getSkinnedPosition();if(fh.assign(e),t.hasGeometryAttribute("normal")){const e=this.getSkinnedNormal();Ah.assign(e),t.hasGeometryAttribute("tangent")&&tl.assign(e)}}generate(t,e){if("void"!==e)return fh.build(t,e)}update(t){const e=(this.useReference?t.object:this.skinnedMesh).skeleton;Tu.get(e)!==t.frameId&&(Tu.set(e,t.frameId),null!==this.previousBoneMatricesNode&&e.previousBoneMatrices.set(e.boneMatrices),e.update())}}const Mu=t=>Ni(new Nu(t,!0));class _u extends Ls{static get type(){return"LoopNode"}constructor(t=[]){super(),this.params=t}getVarName(t){return String.fromCharCode("i".charCodeAt(0)+t)}getProperties(t){const e=t.getNodeProperties(this);if(void 0!==e.stackNode)return e;const s={};for(let t=0,e=this.params.length-1;t<e;t++){const e=this.params[t],i=!0!==e.isNode&&e.name||this.getVarName(t),r=!0!==e.isNode&&e.type||"int";s[i]=wo(i,r)}const i=t.addStack();return e.returnsNode=this.params[this.params.length-1](s,i,t),e.stackNode=i,t.removeStack(),e}getNodeType(t){const{returnsNode:e}=this.getProperties(t);return e?e.getNodeType(t):"void"}setup(t){this.getProperties(t)}generate(t){const e=this.getProperties(t),s=this.params,i=e.stackNode;for(let e=0,i=s.length-1;e<i;e++){const i=s[e];let r=null,n=null,a=null,o=null,h=null,l=null;i.isNode?(o="int",a=this.getVarName(e),r="0",n=i.build(t,o),h="<"):(o=i.type||"int",a=i.name||this.getVarName(e),r=i.start,n=i.end,h=i.condition,l=i.update,"number"==typeof r?r=t.generateConst(o,r):r&&r.isNode&&(r=r.build(t,o)),"number"==typeof n?n=t.generateConst(o,n):n&&n.isNode&&(n=n.build(t,o)),void 0!==r&&void 0===n?(r+=" - 1",n="0",h=">="):void 0!==n&&void 0===r&&(r="0",h="<"),void 0===h&&(h=Number(r)>Number(n)?">=":"<"));const u={start:r,end:n},c=u.start,d=u.end;let p="",m="",g="";l||(l="int"===o||"uint"===o?h.includes("<")?"++":"--":h.includes("<")?"+= 1.":"-= 1."),p+=t.getVar(o,a)+" = "+c,m+=a+" "+h+" "+d,g+=a+" "+l;const y=`for ( ${p}; ${m}; ${g} )`;t.addFlowCode((0===e?"\n":"")+t.tab+y+" {\n\n").addFlowTab()}const r=i.build(t,"void"),n=e.returnsNode?e.returnsNode.build(t):"";t.removeFlowTab().addFlowCode("\n"+t.tab+r);for(let e=0,s=this.params.length-1;e<s;e++)t.addFlowCode((0===e?"":t.tab)+"}\n\n").removeFlowTab();return t.addFlowTab(),n}}const Su=(...t)=>Ni(new _u(_i(t,"int"))).append(),Au=()=>wo("break").append(),Vu=new WeakMap,zu=new j,Cu=Vi(({bufferMap:t,influence:e,stride:s,width:i,depth:r,offset:n})=>{const a=Li(uu).mul(s).add(n),o=a.div(i),h=a.sub(o.mul(i));return Oo(t,Di(h,o)).depth(r).mul(e)});class Ru extends Ls{static get type(){return"MorphNode"}constructor(t){super("void"),this.mesh=t,this.morphBaseInfluence=ur(1),this.updateType=zs.OBJECT}setup(t){const{geometry:e}=t,s=void 0!==e.morphAttributes.position,i=e.hasAttribute("normal")&&void 0!==e.morphAttributes.normal,r=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,n=void 0!==r?r.length:0,{texture:a,stride:o,size:h}=function(t){const e=void 0!==t.morphAttributes.position,s=void 0!==t.morphAttributes.normal,i=void 0!==t.morphAttributes.color,r=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,n=void 0!==r?r.length:0;let a=Vu.get(t);if(void 0===a||a.count!==n){void 0!==a&&a.texture.dispose();const o=t.morphAttributes.position||[],h=t.morphAttributes.normal||[],l=t.morphAttributes.color||[];let u=0;!0===e&&(u=1),!0===s&&(u=2),!0===i&&(u=3);let c=t.attributes.position.count*u,d=1;const p=4096;c>p&&(d=Math.ceil(c/p),c=p);const m=new Float32Array(c*d*4*n),g=new H(m,c,d,n);g.type=1015,g.needsUpdate=!0;const y=4*u;for(let x=0;x<n;x++){const b=o[x],v=h[x],w=l[x],T=c*d*4*x;for(let N=0;N<b.count;N++){const M=N*y;!0===e&&(zu.fromBufferAttribute(b,N),m[T+M+0]=zu.x,m[T+M+1]=zu.y,m[T+M+2]=zu.z,m[T+M+3]=0),!0===s&&(zu.fromBufferAttribute(v,N),m[T+M+4]=zu.x,m[T+M+5]=zu.y,m[T+M+6]=zu.z,m[T+M+7]=0),!0===i&&(zu.fromBufferAttribute(w,N),m[T+M+8]=zu.x,m[T+M+9]=zu.y,m[T+M+10]=zu.z,m[T+M+11]=4===w.itemSize?zu.w:1)}}function f(){g.dispose(),Vu.delete(t),t.removeEventListener("dispose",f)}a={count:n,texture:g,stride:u,size:new S(c,d)},Vu.set(t,a),t.addEventListener("dispose",f)}return a}(e);!0===s&&fh.mulAssign(this.morphBaseInfluence),!0===i&&Ah.mulAssign(this.morphBaseInfluence);const l=Li(h.width);Su(n,({i:t})=>{const e=Oi(0).toVar();this.mesh.count>1&&null!==this.mesh.morphTexture&&void 0!==this.mesh.morphTexture?e.assign(Oo(this.mesh.morphTexture,Di(Li(t).add(1),Li(cu))).r):e.assign(Yh("morphTargetInfluences","float").element(t).toVar()),!0===s&&fh.addAssign(Cu({bufferMap:a,influence:e,stride:o,width:l,depth:t,offset:Li(0)})),!0===i&&Ah.addAssign(Cu({bufferMap:a,influence:e,stride:o,width:l,depth:t,offset:Li(1)}))})}update(){const t=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?t.value=1:t.value=1-this.mesh.morphTargetInfluences.reduce((t,e)=>t+e,0)}}const Eu=Si(Ru);class Iu extends Ls{static get type(){return"LightingNode"}constructor(){super("vec3"),this.isLightingNode=!0}}class Ou extends Iu{static get type(){return"AONode"}constructor(t=null){super(),this.aoNode=t}setup(t){t.context.ambientOcclusion.mulAssign(this.aoNode)}}class Lu extends Ea{static get type(){return"LightingContextNode"}constructor(t,e=null,s=null,i=null){super(t),this.lightingModel=e,this.backdropNode=s,this.backdropAlphaNode=i,this._value=null}getContext(){const{backdropNode:t,backdropAlphaNode:e}=this,s={directDiffuse:Wi().toVar("directDiffuse"),directSpecular:Wi().toVar("directSpecular"),indirectDiffuse:Wi().toVar("indirectDiffuse"),indirectSpecular:Wi().toVar("indirectSpecular")};return{radiance:Wi().toVar("radiance"),irradiance:Wi().toVar("irradiance"),iblIrradiance:Wi().toVar("iblIrradiance"),ambientOcclusion:Oi(1).toVar("ambientOcclusion"),reflectedLight:s,backdrop:t,backdropAlpha:e}}setup(t){return this.value=this._value||(this._value=this.getContext()),this.value.lightingModel=this.lightingModel||t.context.lightingModel,super.setup(t)}}const Bu=Si(Lu);class Fu extends Iu{static get type(){return"IrradianceNode"}constructor(t){super(),this.node=t}setup(t){t.context.irradiance.addAssign(this.node)}}let Pu,Du;class ku extends Ls{static get type(){return"ScreenNode"}constructor(t){super(),this.scope=t,this.isViewportNode=!0}getNodeType(){return this.scope===ku.VIEWPORT?"vec4":"vec2"}getUpdateType(){let t=zs.NONE;return this.scope!==ku.SIZE&&this.scope!==ku.VIEWPORT||(t=zs.RENDER),this.updateType=t,t}update({renderer:t}){const e=t.getRenderTarget();this.scope===ku.VIEWPORT?null!==e?Du.copy(e.viewport):(t.getViewport(Du),Du.multiplyScalar(t.getPixelRatio())):null!==e?(Pu.width=e.width,Pu.height=e.height):t.getDrawingBufferSize(Pu)}setup(){const t=this.scope;let e=null;return e=t===ku.SIZE?ur(Pu||(Pu=new S)):t===ku.VIEWPORT?ur(Du||(Du=new j)):Pi(ju.div(Wu)),e}generate(t){if(this.scope===ku.COORDINATE){let e=t.getFragCoord();if(t.isFlipY()){const s=t.getNodeProperties(Wu).outputNode.build(t);e=`${t.getType("vec2")}( ${e}.x, ${s}.y - ${e}.y )`}return e}return super.generate(t)}}ku.COORDINATE="coordinate",ku.VIEWPORT="viewport",ku.SIZE="size",ku.UV="uv";const Uu=Ai(ku,ku.UV),Wu=Ai(ku,ku.SIZE),ju=Ai(ku,ku.COORDINATE),qu=Ai(ku,ku.VIEWPORT),Hu=qu.zw,Gu=ju.sub(qu.xy),Xu=Gu.div(Hu),$u=Vi(()=>(console.warn('TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.'),Wu),"vec2").once()(),Yu=Vi(()=>(console.warn('TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.'),Uu),"vec2").once()(),Zu=Vi(()=>(console.warn('TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.'),Uu.flipY()),"vec2").once()(),Ju=new S;class Qu extends Eo{static get type(){return"ViewportTextureNode"}constructor(t=Uu,e=null,s=null){null===s&&((s=new os).minFilter=1008),super(s,t,e),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=zs.FRAME}updateBefore(t){const e=t.renderer;e.getDrawingBufferSize(Ju);const s=this.value;s.image.width===Ju.width&&s.image.height===Ju.height||(s.image.width=Ju.width,s.image.height=Ju.height,s.needsUpdate=!0);const i=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,e.copyFramebufferToTexture(s),s.generateMipmaps=i}clone(){const t=new this.constructor(this.uvNode,this.levelNode,this.value);return t.generateMipmaps=this.generateMipmaps,t}}const Ku=Si(Qu),tc=Si(Qu,null,null,{generateMipmaps:!0});let ec=null;class sc extends Qu{static get type(){return"ViewportDepthTextureNode"}constructor(t=Uu,e=null){null===ec&&(ec=new hs),super(t,e,ec)}}const ic=Si(sc);class rc extends Ls{static get type(){return"ViewportDepthNode"}constructor(t,e=null){super("float"),this.scope=t,this.valueNode=e,this.isViewportDepthNode=!0}generate(t){const{scope:e}=this;return e===rc.DEPTH_BASE?t.getFragDepth():super.generate(t)}setup({camera:t}){const{scope:e}=this,s=this.valueNode;let i=null;if(e===rc.DEPTH_BASE)null!==s&&(i=lc().assign(s));else if(e===rc.DEPTH)i=t.isPerspectiveCamera?ac(wh.z,Uo,Wo):nc(wh.z,Uo,Wo);else if(e===rc.LINEAR_DEPTH)if(null!==s)if(t.isPerspectiveCamera){const t=oc(s,Uo,Wo);i=nc(t,Uo,Wo)}else i=s;else i=nc(wh.z,Uo,Wo);return i}}rc.DEPTH_BASE="depthBase",rc.DEPTH="depth",rc.LINEAR_DEPTH="linearDepth";const nc=(t,e,s)=>t.add(e).div(e.sub(s)),ac=(t,e,s)=>e.add(t).mul(s).div(s.sub(e).mul(t)),oc=(t,e,s)=>e.mul(s).div(s.sub(e).mul(t).sub(s)),hc=(t,e,s)=>{e=e.max(1e-6).toVar();const i=Vn(t.negate().div(e)),r=Vn(s.div(e));return i.div(r)},lc=Si(rc,rc.DEPTH_BASE),uc=Ai(rc,rc.DEPTH),cc=Si(rc,rc.LINEAR_DEPTH),dc=cc(ic());uc.assign=t=>lc(t);const pc=Si(class extends Ls{constructor(t){super("float"),this.name=t,this.isBuiltinNode=!0}generate(){return this.name}});class mc extends Ls{static get type(){return"ClippingNode"}constructor(t=mc.DEFAULT){super(),this.scope=t}setup(t){super.setup(t);const e=t.clippingContext,{intersectionPlanes:s,unionPlanes:i}=e;return this.hardwareClipping=t.material.hardwareClipping,this.scope===mc.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(s,i):this.scope===mc.HARDWARE?this.setupHardwareClipping(i,t):this.setupDefault(s,i)}setupAlphaToCoverage(t,e){return Vi(()=>{const s=Oi().toVar("distanceToPlane"),i=Oi().toVar("distanceToGradient"),r=Oi(1).toVar("clipOpacity"),n=e.length;if(!1===this.hardwareClipping&&n>0){const t=Do(e);Su(n,({i:e})=>{const n=t.element(e);s.assign(wh.dot(n.xyz).negate().add(n.w)),i.assign(s.fwidth().div(2)),r.mulAssign(wa(i.negate(),i,s))})}const a=t.length;if(a>0){const e=Do(t),n=Oi(1).toVar("intersectionClipOpacity");Su(a,({i:t})=>{const r=e.element(t);s.assign(wh.dot(r.xyz).negate().add(r.w)),i.assign(s.fwidth().div(2)),n.mulAssign(wa(i.negate(),i,s).oneMinus())}),r.mulAssign(n.oneMinus())}mr.a.mulAssign(r),mr.a.equal(0).discard()})()}setupDefault(t,e){return Vi(()=>{const s=e.length;if(!1===this.hardwareClipping&&s>0){const t=Do(e);Su(s,({i:e})=>{const s=t.element(e);wh.dot(s.xyz).greaterThan(s.w).discard()})}const i=t.length;if(i>0){const e=Do(t),s=Fi(!0).toVar("clipped");Su(i,({i:t})=>{const i=e.element(t);s.assign(wh.dot(i.xyz).greaterThan(i.w).and(s))}),s.discard()}})()}setupHardwareClipping(t,e){const s=t.length;return e.enableHardwareClipping(s),Vi(()=>{const i=Do(t),r=pc(e.getClipDistance());Su(s,({i:t})=>{const e=i.element(t),s=wh.dot(e.xyz).sub(e.w).negate();r.element(t).assign(s)})})()}}mc.ALPHA_TO_COVERAGE="alphaToCoverage",mc.DEFAULT="default",mc.HARDWARE="hardware";const gc=Vi(([t])=>On(Yr(1e4,Ln(Yr(17,t.x).add(Yr(.1,t.y)))).mul(Xr(.1,Un(Ln(Yr(13,t.y).add(t.x))))))),yc=Vi(([t])=>gc(Pi(gc(t.xy),t.z))),fc=Vi(([t])=>{const e=sa(jn(Gn(t.xyz)),jn(Xn(t.xyz))),s=Oi(1).div(Oi(.05).mul(e)).toVar("pixScale"),i=Pi(Sn(Rn(Vn(s))),Sn(En(Vn(s)))),r=Pi(yc(Rn(i.x.mul(t.xyz))),yc(Rn(i.y.mul(t.xyz)))),n=On(Vn(s)),a=Xr(Yr(n.oneMinus(),r.x),Yr(n,r.y)),o=ea(n,n.oneMinus()),h=Wi(a.mul(a).div(Yr(2,o).mul($r(1,o))),a.sub(Yr(.5,o)).div($r(1,o)),$r(1,$r(1,a).mul($r(1,a)).div(Yr(2,o).mul($r(1,o))))),l=a.lessThan(o.oneMinus()).select(a.lessThan(o).select(h.x,h.y),h.z);return xa(l,1e-6,1)}).setLayout({name:"getAlphaHashThreshold",type:"float",inputs:[{name:"position",type:"vec3"}]});class xc extends xe{static get type(){return"NodeMaterial"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isNodeMaterial=!0,this.fog=!0,this.lights=!1,this.hardwareClipping=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.shadowPositionNode=null,this.receivedShadowNode=null,this.castShadowNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+fs(this)}build(t){this.setup(t)}setupObserver(t){return new ps(t)}setup(t){t.context.setupNormal=()=>this.setupNormal(t),t.context.setupPositionView=()=>this.setupPositionView(t),t.context.setupModelViewProjection=()=>this.setupModelViewProjection(t);const e=t.renderer,s=e.getRenderTarget();t.addStack();const i=this.vertexNode||this.setupVertex(t);let r;t.stack.outputNode=i,this.setupHardwareClipping(t),null!==this.geometryNode&&(t.stack.outputNode=t.stack.outputNode.bypass(this.geometryNode)),t.addFlow("vertex",t.removeStack()),t.addStack();const n=this.setupClipping(t);if(!0!==this.depthWrite&&!0!==this.depthTest||(null!==s?!0===s.depthBuffer&&this.setupDepth(t):!0===e.depth&&this.setupDepth(t)),null===this.fragmentNode){this.setupDiffuseColor(t),this.setupVariants(t);const i=this.setupLighting(t);null!==n&&t.stack.add(n);const a=Gi(i,mr.a).max(0);if(r=this.setupOutput(t,a),Er.assign(r),null!==this.outputNode&&(r=this.outputNode),null!==s){const t=e.getMRT(),s=this.mrtNode;null!==t?(r=t,null!==s&&(r=t.merge(s))):null!==s&&(r=s)}}else{let e=this.fragmentNode;!0!==e.isOutputStructNode&&(e=Gi(e)),r=this.setupOutput(t,e)}t.stack.outputNode=r,t.addFlow("fragment",t.removeStack()),t.observer=this.setupObserver(t)}setupClipping(t){if(null===t.clippingContext)return null;const{unionPlanes:e,intersectionPlanes:s}=t.clippingContext;let i=null;if(e.length>0||s.length>0){const e=t.renderer.samples;this.alphaToCoverage&&e>1?i=Ni(new mc(mc.ALPHA_TO_COVERAGE)):t.stack.add(Ni(new mc))}return i}setupHardwareClipping(t){if(this.hardwareClipping=!1,null===t.clippingContext)return;const e=t.clippingContext.unionPlanes.length;e>0&&e<=8&&t.isAvailable("clipDistance")&&(t.stack.add(Ni(new mc(mc.HARDWARE))),this.hardwareClipping=!0)}setupDepth(t){const{renderer:e,camera:s}=t;let i=this.depthNode;if(null===i){const t=e.getMRT();t&&t.has("depth")?i=t.get("depth"):!0===e.logarithmicDepthBuffer&&(i=s.isPerspectiveCamera?hc(wh.z,Uo,Wo):nc(wh.z,Uo,Wo))}null!==i&&uc.assign(i).append()}setupPositionView(){return dh.mul(fh).xyz}setupModelViewProjection(){return jo.mul(wh)}setupVertex(t){return t.addStack(),this.setupPosition(t),t.context.vertex=t.removeStack(),hu}setupPosition(t){const{object:e,geometry:s}=t;if((s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&Eu(e).append(),!0===e.isSkinnedMesh&&Mu(e).append(),this.displacementMap){const t=Qh("displacementMap","texture"),e=Qh("displacementScale","float"),s=Qh("displacementBias","float");fh.addAssign(Ah.normalize().mul(t.x.mul(e).add(s)))}return e.isBatchedMesh&&wu(e).append(),e.isInstancedMesh&&e.instanceMatrix&&!0===e.instanceMatrix.isInstancedBufferAttribute&&bu(e).append(),null!==this.positionNode&&fh.assign(this.positionNode.context({isPositionNodeInput:!0})),fh}setupDiffuseColor({object:t,geometry:e}){let s=this.colorNode?Gi(this.colorNode):_l;if(!0===this.vertexColors&&e.hasAttribute("color")&&(s=Gi(s.xyz.mul(So("color","vec3")),s.a)),t.instanceColor){s=pr("vec3","vInstanceColor").mul(s)}if(t.isBatchedMesh&&t._colorsTexture){s=pr("vec3","vBatchColor").mul(s)}mr.assign(s);const i=this.opacityNode?Oi(this.opacityNode):Vl;if(mr.a.assign(mr.a.mul(i)),null!==this.alphaTestNode||this.alphaTest>0){const t=null!==this.alphaTestNode?Oi(this.alphaTestNode):Ml;mr.a.lessThanEqual(t).discard()}!0===this.alphaHash&&mr.a.lessThan(fc(fh)).discard(),!1===this.transparent&&1===this.blending&&!1===this.alphaToCoverage&&mr.a.assign(1)}setupVariants(){}setupOutgoingLight(){return!0===this.lights?Wi(0):mr.rgb}setupNormal(){return this.normalNode?Wi(this.normalNode):Bl}setupEnvironment(){let t=null;return this.envNode?t=this.envNode:this.envMap&&(t=this.envMap.isCubeTexture?Qh("envMap","cubeTexture"):Qh("envMap","texture")),t}setupLightMap(t){let e=null;return t.material.lightMap&&(e=new Fu(nu)),e}setupLights(t){const e=[],s=this.setupEnvironment(t);s&&s.isLightingNode&&e.push(s);const i=this.setupLightMap(t);if(i&&i.isLightingNode&&e.push(i),null!==this.aoNode||t.material.aoMap){const t=null!==this.aoNode?this.aoNode:au;e.push(new Ou(t))}let r=this.lightsNode||t.lightsNode;return e.length>0&&(r=t.renderer.lighting.createNode([...r.getLights(),...e])),r}setupLightingModel(){}setupLighting(t){const{material:e}=t,{backdropNode:s,backdropAlphaNode:i,emissiveNode:r}=this,n=!0===this.lights||null!==this.lightsNode?this.setupLights(t):null;let a=this.setupOutgoingLight(t);if(n&&n.getScope().hasLights){const e=this.setupLightingModel(t)||null;a=Bu(n,e,s,i)}else null!==s&&(a=Wi(null!==i?fa(a,s,i):s));return(r&&!0===r.isNode||e.emissive&&!0===e.emissive.isColor)&&(gr.assign(Wi(r||Al)),a=a.add(gr)),a}setupFog(t,e){const s=t.fogNode;return s&&(Er.assign(e),e=Gi(s)),e}setupOutput(t,e){return!0===this.fog&&(e=this.setupFog(t,e)),e}setDefaultValues(t){for(const e in t){const s=t[e];void 0===this[e]&&(this[e]=s,s&&s.clone&&(this[e]=s.clone()))}const e=Object.getOwnPropertyDescriptors(t.constructor.prototype);for(const t in e)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,t)&&void 0!==e[t].get&&Object.defineProperty(this.constructor.prototype,t,e[t])}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{},nodes:{}});const s=xe.prototype.toJSON.call(this,t),i=xs(this);s.inputNodes={};for(const{property:e,childNode:r}of i)s.inputNodes[e]=r.toJSON(t).uuid;function r(t){const e=[];for(const s in t){const i=t[s];delete i.metadata,e.push(i)}return e}if(e){const e=r(t.textures),i=r(t.images),n=r(t.nodes);e.length>0&&(s.textures=e),i.length>0&&(s.images=i),n.length>0&&(s.nodes=n)}return s}copy(t){return this.lightsNode=t.lightsNode,this.envNode=t.envNode,this.colorNode=t.colorNode,this.normalNode=t.normalNode,this.opacityNode=t.opacityNode,this.backdropNode=t.backdropNode,this.backdropAlphaNode=t.backdropAlphaNode,this.alphaTestNode=t.alphaTestNode,this.positionNode=t.positionNode,this.geometryNode=t.geometryNode,this.depthNode=t.depthNode,this.shadowPositionNode=t.shadowPositionNode,this.receivedShadowNode=t.receivedShadowNode,this.castShadowNode=t.castShadowNode,this.outputNode=t.outputNode,this.mrtNode=t.mrtNode,this.fragmentNode=t.fragmentNode,this.vertexNode=t.vertexNode,super.copy(t)}}let bc=null;class vc extends Qu{static get type(){return"ViewportSharedTextureNode"}constructor(t=Uu,e=null){null===bc&&(bc=new os),super(t,e,bc)}updateReference(){return this}}const wc=Si(vc);class Tc extends Ps{static get type(){return"EquirectUVNode"}constructor(t=vh){super("vec2"),this.dirNode=t}setup(){const t=this.dirNode,e=t.z.atan(t.x).mul(1/(2*Math.PI)).add(.5),s=t.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return Pi(e,s)}}const Nc=Si(Tc),Mc=Vi(({f0:t,f90:e,dotVH:s})=>{const i=s.mul(-5.55473).sub(6.98316).mul(s).exp2();return t.mul(i.oneMinus()).add(e.mul(i))}),_c=Vi(t=>t.diffuseColor.mul(1/Math.PI)),Sc=Vi(t=>{if(!1===t.geometry.hasAttribute("normal"))return Oi(0);const e=zh.dFdx().abs().max(zh.dFdy().abs());return e.x.max(e.y).max(e.z)}),Ac=Vi(t=>{const{roughness:e}=t,s=Sc();let i=e.max(.0525);return i=i.add(s),i=i.min(1),i}),Vc=Vi(({alpha:t,dotNL:e,dotNV:s})=>{const i=t.pow2(),r=e.mul(i.add(i.oneMinus().mul(s.pow2())).sqrt()),n=s.mul(i.add(i.oneMinus().mul(e.pow2())).sqrt());return Zr(.5,r.add(n).max(fn))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),zc=Vi(({alphaT:t,alphaB:e,dotTV:s,dotBV:i,dotTL:r,dotBL:n,dotNV:a,dotNL:o})=>{const h=o.mul(Wi(t.mul(s),e.mul(i),a).length()),l=a.mul(Wi(t.mul(r),e.mul(n),o).length());return Zr(.5,h.add(l)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),Cc=Vi(({alpha:t,dotNH:e})=>{const s=t.pow2(),i=e.pow2().mul(s.oneMinus()).oneMinus();return s.div(i.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),Rc=Oi(1/Math.PI),Ec=Vi(({alphaT:t,alphaB:e,dotNH:s,dotTH:i,dotBH:r})=>{const n=t.mul(e),a=Wi(e.mul(i),t.mul(r),n.mul(s)),o=a.dot(a),h=n.div(o);return Rc.mul(n.mul(h.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),Ic=Vi(t=>{const{lightDirection:e,f0:s,f90:i,roughness:r,f:n,USE_IRIDESCENCE:a,USE_ANISOTROPY:o}=t,h=t.normalView||Rh,l=r.pow2(),u=e.add(Th).normalize(),c=h.dot(e).clamp(),d=h.dot(Th).clamp(),p=h.dot(u).clamp(),m=Th.dot(u).clamp();let g,y,f=Mc({f0:s,f90:i,dotVH:m});if(vi(a)&&(f=Tr.mix(f,n)),vi(o)){const t=Ar.dot(e),s=Ar.dot(Th),i=Ar.dot(u),r=Vr.dot(e),n=Vr.dot(Th),a=Vr.dot(u);g=zc({alphaT:_r,alphaB:l,dotTV:s,dotBV:n,dotTL:t,dotBL:r,dotNV:d,dotNL:c}),y=Ec({alphaT:_r,alphaB:l,dotNH:p,dotTH:i,dotBH:a})}else g=Vc({alpha:l,dotNL:c,dotNV:d}),y=Cc({alpha:l,dotNH:p});return f.mul(g).mul(y)}),Oc=Vi(({roughness:t,dotNV:e})=>{const s=Gi(-1,-.0275,-.572,.022),i=Gi(1,.0425,1.04,-.04),r=t.mul(s).add(i),n=r.x.mul(r.x).min(e.mul(-9.28).exp2()).mul(r.x).add(r.y);return Pi(-1.04,1.04).mul(n).add(r.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),Lc=Vi(({f:t,f90:e,dotVH:s})=>{const i=s.oneMinus().saturate(),r=i.mul(i),n=i.mul(r,r).clamp(0,.9999);return t.sub(Wi(e).mul(n)).div(n.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),Bc=1/6,Fc=t=>Yr(Bc,Yr(t,Yr(t,t.negate().add(3)).sub(3)).add(1)),Pc=t=>Yr(Bc,Yr(t,Yr(t,Yr(3,t).sub(6))).add(4)),Dc=t=>Yr(Bc,Yr(t,Yr(t,Yr(-3,t).add(3)).add(3)).add(1)),kc=t=>Yr(Bc,ua(t,3)),Uc=t=>Fc(t).add(Pc(t)),Wc=t=>Dc(t).add(kc(t)),jc=t=>Xr(-1,Pc(t).div(Fc(t).add(Pc(t)))),qc=t=>Xr(1,kc(t).div(Dc(t).add(kc(t)))),Hc=(t,e,s)=>{const i=t.uvNode,r=Yr(i,e.zw).add(.5),n=Rn(r),a=On(r),o=Uc(a.x),h=Wc(a.x),l=jc(a.x),u=qc(a.x),c=jc(a.y),d=qc(a.y),p=Pi(n.x.add(l),n.y.add(c)).sub(.5).mul(e.xy),m=Pi(n.x.add(u),n.y.add(c)).sub(.5).mul(e.xy),g=Pi(n.x.add(l),n.y.add(d)).sub(.5).mul(e.xy),y=Pi(n.x.add(u),n.y.add(d)).sub(.5).mul(e.xy),f=Uc(a.y).mul(Xr(o.mul(t.sample(p).level(s)),h.mul(t.sample(m).level(s)))),x=Wc(a.y).mul(Xr(o.mul(t.sample(g).level(s)),h.mul(t.sample(y).level(s))));return f.add(x)},Gc=Vi(([t,e=Oi(3)])=>{const s=Pi(t.size(Li(e))),i=Pi(t.size(Li(e.add(1)))),r=Zr(1,s),n=Zr(1,i),a=Hc(t,Gi(r,s),Rn(e)),o=Hc(t,Gi(n,i),En(e));return On(e).mix(a,o)});Wi(.04),Oi(1);const Xc=Oi(1),$c=Oi(-2),Yc=Oi(.8),Zc=Oi(-1),Jc=Oi(.4),Qc=Oi(2),Kc=Oi(.305),td=Oi(3),ed=Oi(.21),sd=Oi(4),id=Oi(4),rd=Oi(16),nd=Vi(([t])=>{const e=Wi(Un(t)).toVar(),s=Oi(-1).toVar();return Ri(e.x.greaterThan(e.z),()=>{Ri(e.x.greaterThan(e.y),()=>{s.assign(Ca(t.x.greaterThan(0),0,3))}).Else(()=>{s.assign(Ca(t.y.greaterThan(0),1,4))})}).Else(()=>{Ri(e.z.greaterThan(e.y),()=>{s.assign(Ca(t.z.greaterThan(0),2,5))}).Else(()=>{s.assign(Ca(t.y.greaterThan(0),1,4))})}),s}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),ad=Vi(([t,e])=>{const s=Pi().toVar();return Ri(e.equal(0),()=>{s.assign(Pi(t.z,t.y).div(Un(t.x)))}).ElseIf(e.equal(1),()=>{s.assign(Pi(t.x.negate(),t.z.negate()).div(Un(t.y)))}).ElseIf(e.equal(2),()=>{s.assign(Pi(t.x.negate(),t.y).div(Un(t.z)))}).ElseIf(e.equal(3),()=>{s.assign(Pi(t.z.negate(),t.y).div(Un(t.x)))}).ElseIf(e.equal(4),()=>{s.assign(Pi(t.x.negate(),t.z).div(Un(t.y)))}).Else(()=>{s.assign(Pi(t.x,t.y).div(Un(t.z)))}),Yr(.5,s.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),od=Vi(([t])=>{const e=Oi(0).toVar();return Ri(t.greaterThanEqual(Yc),()=>{e.assign(Xc.sub(t).mul(Zc.sub($c)).div(Xc.sub(Yc)).add($c))}).ElseIf(t.greaterThanEqual(Jc),()=>{e.assign(Yc.sub(t).mul(Qc.sub(Zc)).div(Yc.sub(Jc)).add(Zc))}).ElseIf(t.greaterThanEqual(Kc),()=>{e.assign(Jc.sub(t).mul(td.sub(Qc)).div(Jc.sub(Kc)).add(Qc))}).ElseIf(t.greaterThanEqual(ed),()=>{e.assign(Kc.sub(t).mul(sd.sub(td)).div(Kc.sub(ed)).add(td))}).Else(()=>{e.assign(Oi(-2).mul(Vn(Yr(1.16,t))))}),e}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]}),hd=Vi(([t,e])=>{const s=t.toVar();s.assign(Yr(2,s).sub(1));const i=Wi(s,1).toVar();return Ri(e.equal(0),()=>{i.assign(i.zyx)}).ElseIf(e.equal(1),()=>{i.assign(i.xzy),i.xz.mulAssign(-1)}).ElseIf(e.equal(2),()=>{i.x.mulAssign(-1)}).ElseIf(e.equal(3),()=>{i.assign(i.zyx),i.xz.mulAssign(-1)}).ElseIf(e.equal(4),()=>{i.assign(i.xzy),i.xy.mulAssign(-1)}).ElseIf(e.equal(5),()=>{i.z.mulAssign(-1)}),i}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]}),ld=Vi(([t,e,s,i,r,n])=>{const a=Oi(s),o=Wi(e),h=xa(od(a),$c,n),l=On(h),u=Rn(h),c=Wi(ud(t,o,u,i,r,n)).toVar();return Ri(l.notEqual(0),()=>{const e=Wi(ud(t,o,u.add(1),i,r,n)).toVar();c.assign(fa(c,e,l))}),c}),ud=Vi(([t,e,s,i,r,n])=>{const a=Oi(s).toVar(),o=Wi(e),h=Oi(nd(o)).toVar(),l=Oi(sa(id.sub(a),0)).toVar();a.assign(sa(a,id));const u=Oi(Sn(a)).toVar(),c=Pi(ad(o,h).mul(u.sub(2)).add(1)).toVar();return Ri(h.greaterThan(2),()=>{c.y.addAssign(u),h.subAssign(3)}),c.x.addAssign(h.mul(u)),c.x.addAssign(l.mul(Yr(3,rd))),c.y.addAssign(Yr(4,Sn(n).sub(u))),c.x.mulAssign(i),c.y.mulAssign(r),t.sample(c).grad(Pi(),Pi())}),cd=Vi(({envMap:t,mipInt:e,outputDirection:s,theta:i,axis:r,CUBEUV_TEXEL_WIDTH:n,CUBEUV_TEXEL_HEIGHT:a,CUBEUV_MAX_MIP:o})=>{const h=Bn(i),l=s.mul(h).add(r.cross(s).mul(Ln(i))).add(r.mul(r.dot(s).mul(h.oneMinus())));return ud(t,l,e,n,a,o)}),dd=Vi(({n:t,latitudinal:e,poleAxis:s,outputDirection:i,weights:r,samples:n,dTheta:a,mipInt:o,envMap:h,CUBEUV_TEXEL_WIDTH:l,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c})=>{const d=Wi(Ca(e,s,la(s,i))).toVar();Ri(wn(d.equals(Wi(0))),()=>{d.assign(Wi(i.z,0,i.x.negate()))}),d.assign(In(d));const p=Wi().toVar();return p.addAssign(r.element(0).mul(cd({theta:0,axis:d,outputDirection:i,mipInt:o,envMap:h,CUBEUV_TEXEL_WIDTH:l,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c}))),Su({start:Li(1),end:t},({i:t})=>{Ri(t.greaterThanEqual(n),()=>{Au()});const e=Oi(a.mul(Oi(t))).toVar();p.addAssign(r.element(t).mul(cd({theta:e.mul(-1),axis:d,outputDirection:i,mipInt:o,envMap:h,CUBEUV_TEXEL_WIDTH:l,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c}))),p.addAssign(r.element(t).mul(cd({theta:e,axis:d,outputDirection:i,mipInt:o,envMap:h,CUBEUV_TEXEL_WIDTH:l,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c})))}),Gi(p,1)}),pd=[.125,.215,.35,.446,.526,.582],md=20,gd=new ls(-1,1,1,-1,0,1),yd=new Ke(90,1),fd=new ge;let xd=null,bd=0,vd=0;const wd=(1+Math.sqrt(5))/2,Td=1/wd,Nd=[new X(-wd,Td,0),new X(wd,Td,0),new X(-Td,0,wd),new X(Td,0,wd),new X(0,wd,-Td),new X(0,wd,Td),new X(-1,1,-1),new X(1,1,-1),new X(-1,1,1),new X(1,1,1)],Md=new X,_d=new WeakMap,Sd=[3,1,5,0,4,2],Ad=hd(Ao(),So("faceIndex")).normalize(),Vd=Wi(Ad.x,Ad.y,Ad.z);class zd{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}get _hasInitialized(){return this._renderer.hasInitialized()}fromScene(t,e=0,s=.1,i=100,r={}){const{size:n=256,position:a=Md,renderTarget:o=null}=r;if(this._setSize(n),!1===this._hasInitialized){console.warn("THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.");const n=o||this._allocateTargets();return r.renderTarget=n,this.fromSceneAsync(t,e,s,i,r),n}xd=this._renderer.getRenderTarget(),bd=this._renderer.getActiveCubeFace(),vd=this._renderer.getActiveMipmapLevel();const h=o||this._allocateTargets();return h.depthBuffer=!0,this._sceneToCubeUV(t,s,i,h,a),e>0&&this._blur(h,0,0,e),this._applyPMREM(h),this._cleanup(h),h}async fromSceneAsync(t,e=0,s=.1,i=100,r={}){return!1===this._hasInitialized&&await this._renderer.init(),this.fromScene(t,e,s,i,r)}fromEquirectangular(t,e=null){if(!1===this._hasInitialized){console.warn("THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."),this._setSizeFromTexture(t);const s=e||this._allocateTargets();return this.fromEquirectangularAsync(t,s),s}return this._fromTexture(t,e)}async fromEquirectangularAsync(t,e=null){return!1===this._hasInitialized&&await this._renderer.init(),this._fromTexture(t,e)}fromCubemap(t,e=null){if(!1===this._hasInitialized){console.warn("THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."),this._setSizeFromTexture(t);const s=e||this._allocateTargets();return this.fromCubemapAsync(t,e),s}return this._fromTexture(t,e)}async fromCubemapAsync(t,e=null){return!1===this._hasInitialized&&await this._renderer.init(),this._fromTexture(t,e)}async compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=Id(),await this._compileMaterial(this._cubemapMaterial))}async compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Od(),await this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSizeFromTexture(t){301===t.mapping||302===t.mapping?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4)}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(xd,bd,vd),t.scissorTest=!1,Rd(t,0,0,t.width,t.height)}_fromTexture(t,e){this._setSizeFromTexture(t),xd=this._renderer.getRenderTarget(),bd=this._renderer.getActiveCubeFace(),vd=this._renderer.getActiveMipmapLevel();const s=e||this._allocateTargets();return this._textureToCubeUV(t,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,r={magFilter:s,minFilter:s,generateMipmaps:!1,type:i,format:1023,colorSpace:a},n=Cd(t,e,r);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Cd(t,e,r);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas,lodMeshes:this._lodMeshes}=function(t){const e=[],s=[],i=[],r=[];let n=t;const a=t-4+1+pd.length;for(let o=0;o<a;o++){const a=Math.pow(2,n);s.push(a);let h=1/a;o>t-4?h=pd[o-t+4-1]:0===o&&(h=0),i.push(h);const l=1/(a-2),u=-l,c=1+l,d=[u,u,c,u,c,c,u,u,c,c,u,c],p=6,m=6,g=3,y=2,f=1,x=new Float32Array(g*m*p),b=new Float32Array(y*m*p),v=new Float32Array(f*m*p);for(let t=0;t<p;t++){const e=t%3*2/3-1,s=t>2?0:-1,i=[e,s,0,e+2/3,s,0,e+2/3,s+1,0,e,s,0,e+2/3,s+1,0,e,s+1,0],r=Sd[t];x.set(i,g*m*r),b.set(d,y*m*r);const n=[r,r,r,r,r,r];v.set(n,f*m*r)}const w=new Oe;w.setAttribute("position",new Ne(x,g)),w.setAttribute("uv",new Ne(b,y)),w.setAttribute("faceIndex",new Ne(v,f)),e.push(w),r.push(new Ge(w,null)),n>4&&n--}return{lodPlanes:e,sizeLods:s,sigmas:i,lodMeshes:r}}(s)),this._blurMaterial=function(t,e,s){const i=Do(new Array(md).fill(0)),r=ur(new X(0,1,0)),n=ur(0),a=Oi(md),o=ur(0),h=ur(1),l=Io(null),u=ur(0),c=Oi(1/e),d=Oi(1/s),p=Oi(t),m={n:a,latitudinal:o,weights:i,poleAxis:r,outputDirection:Vd,dTheta:n,samples:h,envMap:l,mipInt:u,CUBEUV_TEXEL_WIDTH:c,CUBEUV_TEXEL_HEIGHT:d,CUBEUV_MAX_MIP:p},g=Ed("blur");return g.fragmentNode=dd({...m,latitudinal:o.equal(1)}),_d.set(g,m),g}(s,t,e)}return n}async _compileMaterial(t){const e=new Ge(this._lodPlanes[0],t);await this._renderer.compile(e,gd)}_sceneToCubeUV(t,e,s,i,r){const n=yd;n.near=e,n.far=s;const a=[1,1,1,1,-1,1],o=[1,-1,1,-1,1,-1],h=this._renderer,l=h.autoClear;h.getClearColor(fd),h.autoClear=!1;let u=this._backgroundBox;if(null===u){const t=new be({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1});u=new Ge(new $e,t)}let c=!1;const d=t.background;d?d.isColor&&(u.material.color.copy(d),t.background=null,c=!0):(u.material.color.copy(fd),c=!0),h.setRenderTarget(i),h.clear(),c&&h.render(u,n);for(let e=0;e<6;e++){const s=e%3;0===s?(n.up.set(0,a[e],0),n.position.set(r.x,r.y,r.z),n.lookAt(r.x+o[e],r.y,r.z)):1===s?(n.up.set(0,0,a[e]),n.position.set(r.x,r.y,r.z),n.lookAt(r.x,r.y+o[e],r.z)):(n.up.set(0,a[e],0),n.position.set(r.x,r.y,r.z),n.lookAt(r.x,r.y,r.z+o[e]));const l=this._cubeSize;Rd(i,s*l,e>2?l:0,l,l),h.render(t,n)}h.autoClear=l,t.background=d}_textureToCubeUV(t,e){const s=this._renderer,i=301===t.mapping||302===t.mapping;i?null===this._cubemapMaterial&&(this._cubemapMaterial=Id(t)):null===this._equirectMaterial&&(this._equirectMaterial=Od(t));const r=i?this._cubemapMaterial:this._equirectMaterial;r.fragmentNode.value=t;const n=this._lodMeshes[0];n.material=r;const a=this._cubeSize;Rd(e,0,0,3*a,2*a),s.setRenderTarget(e),s.render(n,gd)}_applyPMREM(t){const e=this._renderer,s=e.autoClear;e.autoClear=!1;const i=this._lodPlanes.length;for(let e=1;e<i;e++){const s=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),r=Nd[(i-e-1)%Nd.length];this._blur(t,e-1,e,s,r)}e.autoClear=s}_blur(t,e,s,i,r){const n=this._pingPongRenderTarget;this._halfBlur(t,n,e,s,i,"latitudinal",r),this._halfBlur(n,t,s,s,i,"longitudinal",r)}_halfBlur(t,e,s,i,r,n,a){const o=this._renderer,h=this._blurMaterial;"latitudinal"!==n&&"longitudinal"!==n&&console.error("blur direction must be either latitudinal or longitudinal!");const l=this._lodMeshes[i];l.material=h;const u=_d.get(h),c=this._sizeLods[s]-1,d=isFinite(r)?Math.PI/(2*c):2*Math.PI/39,p=r/d,m=isFinite(r)?1+Math.floor(3*p):md;m>md&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);const g=[];let y=0;for(let t=0;t<md;++t){const e=t/p,s=Math.exp(-e*e/2);g.push(s),0===t?y+=s:t<m&&(y+=2*s)}for(let t=0;t<g.length;t++)g[t]=g[t]/y;t.texture.frame=(t.texture.frame||0)+1,u.envMap.value=t.texture,u.samples.value=m,u.weights.array=g,u.latitudinal.value="latitudinal"===n?1:0,a&&(u.poleAxis.value=a);const{_lodMax:f}=this;u.dTheta.value=d,u.mipInt.value=f-s;const x=this._sizeLods[i];Rd(e,3*x*(i>f-4?i-f+4:0),4*(this._cubeSize-x),3*x,2*x),o.setRenderTarget(e),o.render(l,gd)}}function Cd(t,e,s){const i=new q(t,e,s);return i.texture.mapping=306,i.texture.name="PMREM.cubeUv",i.texture.isPMREMTexture=!0,i.scissorTest=!0,i}function Rd(t,e,s,i,r){t.viewport.set(e,s,i,r),t.scissor.set(e,s,i,r)}function Ed(t){const e=new xc;return e.depthTest=!1,e.depthWrite=!1,e.blending=0,e.name=`PMREM_${t}`,e}function Id(t){const e=Ed("cubemap");return e.fragmentNode=Gh(t,Vd),e}function Od(t){const e=Ed("equirect");return e.fragmentNode=Io(t,Nc(Vd),0),e}const Ld=new WeakMap;function Bd(t,e,s){const i=function(t){let e=Ld.get(t);void 0===e&&(e=new WeakMap,Ld.set(t,e));return e}(e);let r=i.get(t);if((void 0!==r?r.pmremVersion:-1)!==t.pmremVersion){const e=t.image;if(t.isCubeTexture){if(!function(t){if(null==t)return!1;let e=0;const s=6;for(let i=0;i<s;i++)void 0!==t[i]&&e++;return e===s}(e))return null;r=s.fromCubemap(t,r)}else{if(!function(t){return null!=t&&t.height>0}(e))return null;r=s.fromEquirectangular(t,r)}r.pmremVersion=t.pmremVersion,i.set(t,r)}return r.texture}class Fd extends Ps{static get type(){return"PMREMNode"}constructor(t,e=null,s=null){super("vec3"),this._value=t,this._pmrem=null,this.uvNode=e,this.levelNode=s,this._generator=null;const i=new W;i.isRenderTargetTexture=!0,this._texture=Io(i),this._width=ur(0),this._height=ur(0),this._maxMip=ur(0),this.updateBeforeType=zs.RENDER}set value(t){this._value=t,this._pmrem=null}get value(){return this._value}updateFromTexture(t){const e=function(t){const e=Math.log2(t)-2,s=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:s,maxMip:e}}(t.image.height);this._texture.value=t,this._width.value=e.texelWidth,this._height.value=e.texelHeight,this._maxMip.value=e.maxMip}updateBefore(t){let e=this._pmrem;const s=e?e.pmremVersion:-1,i=this._value;s!==i.pmremVersion&&(e=!0===i.isPMREMTexture?i:Bd(i,t.renderer,this._generator),null!==e&&(this._pmrem=e,this.updateFromTexture(e)))}setup(t){null===this._generator&&(this._generator=new zd(t.renderer)),this.updateBefore(t);let e=this.uvNode;null===e&&t.context.getUV&&(e=t.context.getUV(this)),e=kh.mul(Wi(e.x,e.y.negate(),e.z));let s=this.levelNode;return null===s&&t.context.getTextureLevel&&(s=t.context.getTextureLevel(this)),ld(this._texture,e,s,this._width,this._height,this._maxMip)}dispose(){super.dispose(),null!==this._generator&&this._generator.dispose()}}const Pd=Si(Fd);class Dd extends Ps{static get type(){return"MatcapUVNode"}constructor(){super("vec2")}setup(){const t=Wi(Th.z,0,Th.x.negate()).normalize(),e=Th.cross(t);return Pi(t.dot(Rh),e.dot(Rh)).mul(.495).add(.5)}}const kd=Ai(Dd);class Ud extends Ps{static get type(){return"RotateNode"}constructor(t,e){super(),this.positionNode=t,this.rotationNode=e}getNodeType(t){return this.positionNode.getNodeType(t)}setup(t){const{rotationNode:e,positionNode:s}=this;if("vec2"===this.getNodeType(t)){const t=e.cos(),i=e.sin();return Zi(t,i,i.negate(),t).mul(s)}{const t=e,i=Qi(Gi(1,0,0,0),Gi(0,Bn(t.x),Ln(t.x).negate(),0),Gi(0,Ln(t.x),Bn(t.x),0),Gi(0,0,0,1)),r=Qi(Gi(Bn(t.y),0,Ln(t.y),0),Gi(0,1,0,0),Gi(Ln(t.y).negate(),0,Bn(t.y),0),Gi(0,0,0,1)),n=Qi(Gi(Bn(t.z),Ln(t.z).negate(),0,0),Gi(Ln(t.z),Bn(t.z),0,0),Gi(0,0,1,0),Gi(0,0,0,1));return i.mul(r).mul(n).mul(Gi(s,1)).xyz}}}const Wd=Si(Ud);dr("vec3"),dr("vec3"),dr("vec3");class jd extends cr{static get type(){return"ParameterNode"}constructor(t,e=null){super(t,e),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}class qd extends Ls{static get type(){return"StackNode"}constructor(t=null){super(),this.nodes=[],this.outputNode=null,this.parent=t,this._currentCond=null,this.isStackNode=!0}getNodeType(t){return this.outputNode?this.outputNode.getNodeType(t):"void"}getMemberType(t,e){return this.outputNode?this.outputNode.getMemberType(t,e):"void"}add(t){return this.nodes.push(t),this}If(t,e){const s=new Ti(e);return this._currentCond=Ca(t,s),this.add(this._currentCond)}ElseIf(t,e){const s=new Ti(e),i=Ca(t,s);return this._currentCond.elseNode=i,this._currentCond=i,this}Else(t){return this._currentCond.elseNode=new Ti(t),this}build(t,...e){const s=Ci();zi(this);for(const e of this.nodes)e.build(t,"void");return zi(s),this.outputNode?this.outputNode.build(t,...e):super.build(t,...e)}else(...t){return console.warn("TSL.StackNode: .else() has been renamed to .Else()."),this.Else(...t)}elseif(...t){return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."),this.ElseIf(...t)}}const Hd=Si(qd);class Gd extends Ls{static get type(){return"StructTypeNode"}constructor(t,e=null){var s;super("struct"),this.membersLayout=(s=t,Object.entries(s).map(([t,e])=>"string"==typeof e?{name:t,type:e,atomic:!1}:{name:t,type:e.type,atomic:e.atomic||!1})),this.name=e,this.isStructLayoutNode=!0}getLength(){let t=0;for(const e of this.membersLayout)t+=Ts(e.type);return t}getMemberType(t,e){const s=this.membersLayout.find(t=>t.name===e);return s?s.type:"void"}getNodeType(t){return t.getStructTypeFromNode(this,this.membersLayout,this.name).name}setup(t){t.addInclude(this)}generate(t){return this.getNodeType(t)}}class Xd extends Ls{static get type(){return"StructNode"}constructor(t,e){super("vec3"),this.structLayoutNode=t,this.values=e,this.isStructNode=!0}getNodeType(t){return this.structLayoutNode.getNodeType(t)}getMemberType(t,e){return this.structLayoutNode.getMemberType(t,e)}generate(t){const e=t.getVarFromNode(this),s=e.type,i=t.getPropertyName(e);return t.addLineFlowCode(`${i} = ${t.generateStruct(s,this.structLayoutNode.membersLayout,this.values)}`,this),e.name}}class $d extends Ls{static get type(){return"OutputStructNode"}constructor(...t){super(),this.members=t,this.isOutputStructNode=!0}getNodeType(t){const e=t.getNodeProperties(this);if(void 0===e.membersLayout){const s=this.members,i=[];for(let e=0;e<s.length;e++){const r="m"+e,n=s[e].getNodeType(t);i.push({name:r,type:n,index:e})}e.membersLayout=i,e.structType=t.getOutputStructTypeFromNode(this,e.membersLayout)}return e.structType.name}generate(t){const e=t.getOutputStructName(),s=this.members,i=""!==e?e+".":"";for(let e=0;e<s.length;e++){const r=s[e].build(t);t.addLineFlowCode(`${i}m${e} = ${r}`,this)}return e}}const Yd=Si($d);function Zd(t,e){for(let s=0;s<t.length;s++)if(t[s].name===e)return s;return-1}class Jd extends $d{static get type(){return"MRTNode"}constructor(t){super(),this.outputNodes=t,this.isMRTNode=!0}has(t){return void 0!==this.outputNodes[t]}get(t){return this.outputNodes[t]}merge(t){const e={...this.outputNodes,...t.outputNodes};return Qd(e)}setup(t){const e=this.outputNodes,s=[],i=t.renderer.getRenderTarget().textures;for(const t in e){s[Zd(i,t)]=Gi(e[t])}return this.members=s,super.setup(t)}}const Qd=Si(Jd),Kd=Vi(([t])=>{const e=t.toUint().mul(747796405).add(2891336453),s=e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);return s.shiftRight(22).bitXor(s).toFloat().mul(1/2**32)}),tp=(t,e)=>ua(Yr(4,t.mul($r(1,t))),e),ep=Vi(([t])=>t.fract().sub(.5).abs()).setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]}),sp=Vi(([t])=>Wi(ep(t.z.add(ep(t.y.mul(1)))),ep(t.z.add(ep(t.x.mul(1)))),ep(t.y.add(ep(t.x.mul(1)))))).setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),ip=Vi(([t,e,s])=>{const i=Wi(t).toVar(),r=Oi(1.4).toVar(),n=Oi(0).toVar(),a=Wi(i).toVar();return Su({start:Oi(0),end:Oi(3),type:"float",condition:"<="},()=>{const t=Wi(sp(a.mul(2))).toVar();i.addAssign(t.add(s.mul(Oi(.1).mul(e)))),a.mulAssign(1.8),r.mulAssign(1.5),i.mulAssign(1.2);const o=Oi(ep(i.z.add(ep(i.x.add(ep(i.y)))))).toVar();n.addAssign(o.div(r)),a.addAssign(.14)}),n}).setLayout({name:"triNoise3D",type:"float",inputs:[{name:"position",type:"vec3"},{name:"speed",type:"float"},{name:"time",type:"float"}]});class rp extends Ls{static get type(){return"FunctionOverloadingNode"}constructor(t=[],...e){super(),this.functionNodes=t,this.parametersNodes=e,this._candidateFnCall=null,this.global=!0}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(t){const e=this.parametersNodes;let s=this._candidateFnCall;if(null===s){let i=null,r=-1;for(const s of this.functionNodes){const n=s.shaderNode.layout;if(null===n)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const a=n.inputs;if(e.length===a.length){let n=0;for(let s=0;s<e.length;s++){const i=e[s],r=a[s];i.getNodeType(t)===r.type?n++:n=0}n>r&&(i=s,r=n)}}this._candidateFnCall=s=i(...e)}return s}}const np=Si(rp),ap=t=>(...e)=>np(t,...e),op=ur(0).setGroup(or).onRenderUpdate(t=>t.time),hp=ur(0).setGroup(or).onRenderUpdate(t=>t.deltaTime),lp=ur(0,"uint").setGroup(or).onRenderUpdate(t=>t.frameId),up=Vi(([t,e,s=Pi(.5)])=>Wd(t.sub(s),e).add(s)),cp=Vi(([t,e,s=Pi(.5)])=>{const i=t.sub(s),r=i.dot(i),n=r.mul(r).mul(e);return t.add(i.mul(n))}),dp=Vi(({position:t=null,horizontal:e=!0,vertical:s=!1})=>{let i;null!==t?(i=nh.toVar(),i[3][0]=t.x,i[3][1]=t.y,i[3][2]=t.z):i=nh;const r=Ho.mul(i);return vi(e)&&(r[0][0]=nh[0].length(),r[0][1]=0,r[0][2]=0),vi(s)&&(r[1][0]=0,r[1][1]=nh[1].length(),r[1][2]=0),r[2][0]=0,r[2][1]=0,r[2][2]=1,jo.mul(r).mul(fh)}),pp=Vi(([t=null])=>{const e=cc();return cc(ic(t)).sub(e).lessThan(0).select(Uu,t)});class mp extends Ls{static get type(){return"SpriteSheetUVNode"}constructor(t,e=Ao(),s=Oi(0)){super("vec2"),this.countNode=t,this.uvNode=e,this.frameNode=s}setup(){const{frameNode:t,uvNode:e,countNode:s}=this,{width:i,height:r}=s,n=t.mod(i.mul(r)).floor(),a=n.mod(i),o=r.sub(n.add(1).div(i).ceil()),h=s.reciprocal(),l=Pi(a,o);return e.add(l).mul(h)}}const gp=Si(mp);class yp extends Ls{static get type(){return"TriplanarTexturesNode"}constructor(t,e=null,s=null,i=Oi(1),r=fh,n=Ah){super("vec4"),this.textureXNode=t,this.textureYNode=e,this.textureZNode=s,this.scaleNode=i,this.positionNode=r,this.normalNode=n}setup(){const{textureXNode:t,textureYNode:e,textureZNode:s,scaleNode:i,positionNode:r,normalNode:n}=this;let a=n.abs().normalize();a=a.div(a.dot(Wi(1)));const o=r.yz.mul(i),h=r.zx.mul(i),l=r.xy.mul(i),u=t.value,c=null!==e?e.value:u,d=null!==s?s.value:u,p=Io(u,o).mul(a.x),m=Io(c,h).mul(a.y),g=Io(d,l).mul(a.z);return Xr(p,m,g)}}const fp=Si(yp),xp=new class{constructor(t=new X(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,i){return this.normal.set(t,e,s),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const i=rs.subVectors(s,e).cross(ns.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const s=t.delta(rs),i=this.normal.dot(s);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(t.start).addScaledVector(s,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||as.getNormalMatrix(t),i=this.coplanarPoint(rs).applyMatrix4(t),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}},bp=new X,vp=new X,wp=new X,Tp=new Nt,Np=new X(0,0,-1),Mp=new j,_p=new X,Sp=new X,Ap=new j,Vp=new S,zp=new q,Cp=Uu.flipX();zp.depthTexture=new hs(1,1);let Rp=!1;class Ep extends Eo{static get type(){return"ReflectorNode"}constructor(t={}){super(t.defaultTexture||zp.texture,Cp),this._reflectorBaseNode=t.reflector||new Ip(this,t),this._depthNode=null,this.setUpdateMatrix(!1)}get reflector(){return this._reflectorBaseNode}get target(){return this._reflectorBaseNode.target}getDepthNode(){if(null===this._depthNode){if(!0!==this._reflectorBaseNode.depth)throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");this._depthNode=Ni(new Ep({defaultTexture:zp.depthTexture,reflector:this._reflectorBaseNode}))}return this._depthNode}setup(t){return t.object.isQuadMesh||this._reflectorBaseNode.build(t),super.setup(t)}clone(){const t=new this.constructor(this.reflectorNode);return t._reflectorBaseNode=this._reflectorBaseNode,t}}class Ip extends Ls{static get type(){return"ReflectorBaseNode"}constructor(t,e={}){super();const{target:s=new Zt,resolution:i=1,generateMipmaps:r=!1,bounces:n=!0,depth:a=!1}=e;this.textureNode=t,this.target=s,this.resolution=i,this.generateMipmaps=r,this.bounces=n,this.depth=a,this.updateBeforeType=n?zs.RENDER:zs.FRAME,this.virtualCameras=new WeakMap,this.renderTargets=new WeakMap,this.forceUpdate=!1}_updateResolution(t,e){const s=this.resolution;e.getDrawingBufferSize(Vp),t.setSize(Math.round(Vp.width*s),Math.round(Vp.height*s))}setup(t){return this._updateResolution(zp,t.renderer),super.setup(t)}getVirtualCamera(t){let e=this.virtualCameras.get(t);return void 0===e&&(e=t.clone(),this.virtualCameras.set(t,e)),e}getRenderTarget(t){let e=this.renderTargets.get(t);return void 0===e&&(e=new q(0,0,{type:i}),!0===this.generateMipmaps&&(e.texture.minFilter=1008,e.texture.generateMipmaps=!0),!0===this.depth&&(e.depthTexture=new hs),this.renderTargets.set(t,e)),e}updateBefore(t){if(!1===this.bounces&&Rp)return!1;Rp=!0;const{scene:e,camera:s,renderer:i,material:r}=t,{target:n}=this,a=this.getVirtualCamera(s),o=this.getRenderTarget(a);i.getDrawingBufferSize(Vp),this._updateResolution(o,i),vp.setFromMatrixPosition(n.matrixWorld),wp.setFromMatrixPosition(s.matrixWorld),Tp.extractRotation(n.matrixWorld),bp.set(0,0,1),bp.applyMatrix4(Tp),_p.subVectors(vp,wp);if(!0===_p.dot(bp)>0&&!1===this.forceUpdate)return;_p.reflect(bp).negate(),_p.add(vp),Tp.extractRotation(s.matrixWorld),Np.set(0,0,-1),Np.applyMatrix4(Tp),Np.add(wp),Sp.subVectors(vp,Np),Sp.reflect(bp).negate(),Sp.add(vp),a.coordinateSystem=s.coordinateSystem,a.position.copy(_p),a.up.set(0,1,0),a.up.applyMatrix4(Tp),a.up.reflect(bp),a.lookAt(Sp),a.near=s.near,a.far=s.far,a.updateMatrixWorld(),a.projectionMatrix.copy(s.projectionMatrix),xp.setFromNormalAndCoplanarPoint(bp,vp),xp.applyMatrix4(a.matrixWorldInverse),Mp.set(xp.normal.x,xp.normal.y,xp.normal.z,xp.constant);const h=a.projectionMatrix;Ap.x=(Math.sign(Mp.x)+h.elements[8])/h.elements[0],Ap.y=(Math.sign(Mp.y)+h.elements[9])/h.elements[5],Ap.z=-1,Ap.w=(1+h.elements[10])/h.elements[14],Mp.multiplyScalar(1/Mp.dot(Ap));h.elements[2]=Mp.x,h.elements[6]=Mp.y,h.elements[10]=i.coordinateSystem===p?Mp.z-0:Mp.z+1-0,h.elements[14]=Mp.w,this.textureNode.value=o.texture,!0===this.depth&&(this.textureNode.getDepthNode().value=o.depthTexture),r.visible=!1;const l=i.getRenderTarget(),u=i.getMRT(),c=i.autoClear;i.setMRT(null),i.setRenderTarget(o),i.autoClear=!0,i.render(e,a),i.setMRT(u),i.setRenderTarget(l),i.autoClear=c,r.visible=!0,Rp=!1,this.forceUpdate=!1}}const Op=new ls(-1,1,1,-1,0,1);class Lp extends Oe{constructor(t=!1){super();const e=!1===t?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new Se([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Se(e,2))}}const Bp=new Lp;class Fp extends Ge{constructor(t=null){super(Bp,t),this.camera=Op,this.isQuadMesh=!0}async renderAsync(t){return t.renderAsync(this,Op)}render(t){t.render(this,Op)}}const Pp=new S;class Dp extends Eo{static get type(){return"RTTNode"}constructor(t,e=null,s=null,r={type:i}){const n=new q(e,s,r);super(n.texture,Ao()),this.node=t,this.width=e,this.height=s,this.pixelRatio=1,this.renderTarget=n,this.textureNeedsUpdate=!0,this.autoUpdate=!0,this._rttNode=null,this._quadMesh=new Fp(new xc),this.updateBeforeType=zs.RENDER}get autoSize(){return null===this.width}setup(t){return this._rttNode=this.node.context(t.getSharedContext()),this._quadMesh.material.name="RTT",this._quadMesh.material.needsUpdate=!0,super.setup(t)}setSize(t,e){this.width=t,this.height=e;const s=t*this.pixelRatio,i=e*this.pixelRatio;this.renderTarget.setSize(s,i),this.textureNeedsUpdate=!0}setPixelRatio(t){this.pixelRatio=t,this.setSize(this.width,this.height)}updateBefore({renderer:t}){if(!1===this.textureNeedsUpdate&&!1===this.autoUpdate)return;if(this.textureNeedsUpdate=!1,!0===this.autoSize){this.pixelRatio=t.getPixelRatio();const e=t.getSize(Pp);this.setSize(e.width,e.height)}this._quadMesh.material.fragmentNode=this._rttNode;const e=t.getRenderTarget();t.setRenderTarget(this.renderTarget),this._quadMesh.render(t),t.setRenderTarget(e)}clone(){const t=new Eo(this.value,this.uvNode,this.levelNode);return t.sampler=this.sampler,t.referenceNode=this,t}}const kp=(t,...e)=>Ni(new Dp(Ni(t),...e)),Up=Vi(([t,e,s],i)=>{let r;i.renderer.coordinateSystem===p?(t=Pi(t.x,t.y.oneMinus()).mul(2).sub(1),r=Gi(Wi(t,e),1)):r=Gi(Wi(t.x,t.y.oneMinus(),e).mul(2).sub(1),1);const n=Gi(s.mul(r));return n.xyz.div(n.w)}),Wp=Vi(([t,e])=>{const s=e.mul(Gi(t,1)),i=s.xy.div(s.w).mul(.5).add(.5).toVar();return Pi(i.x,i.y.oneMinus())}),jp=Vi(([t,e,s])=>{const i=zo(Oo(e)),r=Di(t.mul(i)).toVar(),n=Oo(e,r).toVar(),a=Oo(e,r.sub(Di(2,0))).toVar(),o=Oo(e,r.sub(Di(1,0))).toVar(),h=Oo(e,r.add(Di(1,0))).toVar(),l=Oo(e,r.add(Di(2,0))).toVar(),u=Oo(e,r.add(Di(0,2))).toVar(),c=Oo(e,r.add(Di(0,1))).toVar(),d=Oo(e,r.sub(Di(0,1))).toVar(),p=Oo(e,r.sub(Di(0,2))).toVar(),m=Un($r(Oi(2).mul(o).sub(a),n)).toVar(),g=Un($r(Oi(2).mul(h).sub(l),n)).toVar(),y=Un($r(Oi(2).mul(c).sub(u),n)).toVar(),f=Un($r(Oi(2).mul(d).sub(p),n)).toVar(),x=Up(t,n,s).toVar(),b=m.lessThan(g).select(x.sub(Up(t.sub(Pi(Oi(1).div(i.x),0)),o,s)),x.negate().add(Up(t.add(Pi(Oi(1).div(i.x),0)),h,s))),v=y.lessThan(f).select(x.sub(Up(t.add(Pi(0,Oi(1).div(i.y))),c,s)),x.negate().add(Up(t.sub(Pi(0,Oi(1).div(i.y))),d,s)));return In(la(b,v))});class qp extends is{constructor(t,e,s=Float32Array){super(ArrayBuffer.isView(t)?t:new s(t*e),e),this.isStorageInstancedBufferAttribute=!0}}class Hp extends Ne{constructor(t,e,s=Float32Array){super(ArrayBuffer.isView(t)?t:new s(t*e),e),this.isStorageBufferAttribute=!0}}class Gp extends Bs{static get type(){return"StorageArrayElementNode"}constructor(t,e){super(t,e),this.isStorageArrayElementNode=!0}set storageBufferNode(t){this.node=t}get storageBufferNode(){return this.node}getMemberType(t,e){const s=this.storageBufferNode.structTypeNode;return s?s.getMemberType(t,e):"void"}setup(t){return!1===t.isAvailable("storageBuffer")&&!0===this.node.isPBO&&t.setupPBO(this.node),super.setup(t)}generate(t,e){let s;const i=t.context.assign;if(s=!1===t.isAvailable("storageBuffer")?!0!==this.node.isPBO||!0===i||!this.node.value.isInstancedBufferAttribute&&"compute"===t.shaderStage?this.node.build(t):t.generatePBO(this):super.generate(t),!0!==i){const i=this.getNodeType(t);s=t.format(s,i,e)}return s}}const Xp=Si(Gp);class $p extends Lo{static get type(){return"StorageBufferNode"}constructor(t,e=null,s=0){let i,r=null;e&&e.isStruct?(i="struct",r=e.layout):null===e&&(t.isStorageBufferAttribute||t.isStorageInstancedBufferAttribute)?(i=function(t){return bs.get(t)}(t.itemSize),s=t.count):i=e,super(t,i,s),this.isStorageBufferNode=!0,this.structTypeNode=r,this.access=Cs.READ_WRITE,this.isAtomic=!1,this.isPBO=!1,this._attribute=null,this._varying=null,this.global=!0,!0!==t.isStorageBufferAttribute&&!0!==t.isStorageInstancedBufferAttribute&&(t.isInstancedBufferAttribute?t.isStorageInstancedBufferAttribute=!0:t.isStorageBufferAttribute=!0)}getHash(t){if(0===this.bufferCount){let e=t.globalCache.getData(this.value);return void 0===e&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getInputType(){return this.value.isIndirectStorageBufferAttribute?"indirectStorageBuffer":"storageBuffer"}element(t){return Xp(this,t)}setPBO(t){return this.isPBO=t,this}getPBO(){return this.isPBO}setAccess(t){return this.access=t,this}toReadOnly(){return this.setAccess(Cs.READ_ONLY)}setAtomic(t){return this.isAtomic=t,this}toAtomic(){return this.setAtomic(!0)}getAttributeData(){return null===this._attribute&&(this._attribute=ao(this.value),this._varying=Ua(this._attribute)),{attribute:this._attribute,varying:this._varying}}getNodeType(t){if(null!==this.structTypeNode)return this.structTypeNode.getNodeType(t);if(t.isAvailable("storageBuffer")||t.isAvailable("indirectStorageBuffer"))return super.getNodeType(t);const{attribute:e}=this.getAttributeData();return e.getNodeType(t)}generate(t){if(null!==this.structTypeNode&&this.structTypeNode.build(t),t.isAvailable("storageBuffer")||t.isAvailable("indirectStorageBuffer"))return super.generate(t);const{attribute:e,varying:s}=this.getAttributeData(),i=s.build(t);return t.registerTransform(i,e),i}}const Yp=(t,e=null,s=0)=>Ni(new $p(t,e,s));class Zp extends _o{static get type(){return"VertexColorNode"}constructor(t=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=t}getAttributeName(){const t=this.index;return"color"+(t>0?t:"")}generate(t){const e=this.getAttributeName(t);let s;return s=!0===t.hasGeometryAttribute(e)?super.generate(t):t.generateConst(this.nodeType,new j(1,1,1,1)),s}serialize(t){super.serialize(t),t.index=this.index}deserialize(t){super.deserialize(t),this.index=t.index}}class Jp extends Ls{static get type(){return"PointUVNode"}constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}const Qp=Ai(Jp),Kp=new It,tm=new Nt;class em extends Ls{static get type(){return"SceneNode"}constructor(t=em.BACKGROUND_BLURRINESS,e=null){super(),this.scope=t,this.scene=e}setup(t){const e=this.scope,s=null!==this.scene?this.scene:t.scene;let i;return e===em.BACKGROUND_BLURRINESS?i=Yh("backgroundBlurriness","float",s):e===em.BACKGROUND_INTENSITY?i=Yh("backgroundIntensity","float",s):e===em.BACKGROUND_ROTATION?i=ur("mat4").label("backgroundRotation").setGroup(or).onRenderUpdate(()=>{const t=s.background;return null!==t&&t.isTexture&&300!==t.mapping?(Kp.copy(s.backgroundRotation),Kp.x*=-1,Kp.y*=-1,Kp.z*=-1,tm.makeRotationFromEuler(Kp)):tm.identity(),tm}):console.error("THREE.SceneNode: Unknown scope:",e),i}}em.BACKGROUND_BLURRINESS="backgroundBlurriness",em.BACKGROUND_INTENSITY="backgroundIntensity",em.BACKGROUND_ROTATION="backgroundRotation";const sm=Ai(em,em.BACKGROUND_BLURRINESS),im=Ai(em,em.BACKGROUND_INTENSITY),rm=Ai(em,em.BACKGROUND_ROTATION);class nm extends Eo{static get type(){return"StorageTextureNode"}constructor(t,e,s=null){super(t,e),this.storeNode=s,this.isStorageTextureNode=!0,this.access=Cs.WRITE_ONLY}getInputType(){return"storageTexture"}setup(t){super.setup(t);t.getNodeProperties(this).storeNode=this.storeNode}setAccess(t){return this.access=t,this}generate(t,e){let s;return s=null!==this.storeNode?this.generateStore(t):super.generate(t,e),s}toReadWrite(){return this.setAccess(Cs.READ_WRITE)}toReadOnly(){return this.setAccess(Cs.READ_ONLY)}toWriteOnly(){return this.setAccess(Cs.WRITE_ONLY)}generateStore(t){const e=t.getNodeProperties(this),{uvNode:s,storeNode:i}=e,r=super.generate(t,"property"),n=s.build(t,"uvec2"),a=i.build(t,"vec4"),o=t.generateTextureStore(t,r,n,a);t.addLineFlowCode(o,this)}}const am=Si(nm),om=Vi(({texture:t,uv:e})=>{const s=1e-4,i=Wi().toVar();return Ri(e.x.lessThan(s),()=>{i.assign(Wi(1,0,0))}).ElseIf(e.y.lessThan(s),()=>{i.assign(Wi(0,1,0))}).ElseIf(e.z.lessThan(s),()=>{i.assign(Wi(0,0,1))}).ElseIf(e.x.greaterThan(.9999),()=>{i.assign(Wi(-1,0,0))}).ElseIf(e.y.greaterThan(.9999),()=>{i.assign(Wi(0,-1,0))}).ElseIf(e.z.greaterThan(.9999),()=>{i.assign(Wi(0,0,-1))}).Else(()=>{const s=.01,r=t.sample(e.add(Wi(-.01,0,0))).r.sub(t.sample(e.add(Wi(s,0,0))).r),n=t.sample(e.add(Wi(0,-.01,0))).r.sub(t.sample(e.add(Wi(0,s,0))).r),a=t.sample(e.add(Wi(0,0,-.01))).r.sub(t.sample(e.add(Wi(0,0,s))).r);i.assign(Wi(r,n,a))}),i.normalize()});class hm extends Eo{static get type(){return"Texture3DNode"}constructor(t,e=null,s=null){super(t,e,s),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return Wi(.5,.5,.5)}setUpdateMatrix(){}setupUV(t,e){const s=this.value;return!t.isFlipY()||!0!==s.isRenderTargetTexture&&!0!==s.isFramebufferTexture||(e=this.sampler?e.flipY():e.setY(Li(zo(this,this.levelNode).y).sub(e.y).sub(1))),e}generateUV(t,e){return e.build(t,"vec3")}normal(t){return om({texture:this,uv:t})}}const lm=Si(hm);class um extends $h{static get type(){return"UserDataNode"}constructor(t,e,s=null){super(t,e,s),this.userData=s}updateReference(t){return this.reference=null!==this.userData?this.userData:t.object.userData,this.reference}}const cm=new WeakMap;class dm extends Ps{static get type(){return"VelocityNode"}constructor(){super("vec2"),this.projectionMatrix=null,this.updateType=zs.OBJECT,this.updateAfterType=zs.OBJECT,this.previousModelWorldMatrix=ur(new Nt),this.previousProjectionMatrix=ur(new Nt).setGroup(or),this.previousCameraViewMatrix=ur(new Nt)}setProjectionMatrix(t){this.projectionMatrix=t}update({frameId:t,camera:e,object:s}){const i=mm(s);this.previousModelWorldMatrix.value.copy(i);const r=pm(e);r.frameId!==t&&(r.frameId=t,void 0===r.previousProjectionMatrix?(r.previousProjectionMatrix=new Nt,r.previousCameraViewMatrix=new Nt,r.currentProjectionMatrix=new Nt,r.currentCameraViewMatrix=new Nt,r.previousProjectionMatrix.copy(this.projectionMatrix||e.projectionMatrix),r.previousCameraViewMatrix.copy(e.matrixWorldInverse)):(r.previousProjectionMatrix.copy(r.currentProjectionMatrix),r.previousCameraViewMatrix.copy(r.currentCameraViewMatrix)),r.currentProjectionMatrix.copy(this.projectionMatrix||e.projectionMatrix),r.currentCameraViewMatrix.copy(e.matrixWorldInverse),this.previousProjectionMatrix.value.copy(r.previousProjectionMatrix),this.previousCameraViewMatrix.value.copy(r.previousCameraViewMatrix))}updateAfter({object:t}){mm(t).copy(t.matrixWorld)}setup(){const t=null===this.projectionMatrix?jo:ur(this.projectionMatrix),e=this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix),s=t.mul(dh).mul(fh),i=this.previousProjectionMatrix.mul(e).mul(xh),r=s.xy.div(s.w),n=i.xy.div(i.w);return $r(r,n)}}function pm(t){let e=cm.get(t);return void 0===e&&(e={},cm.set(t,e)),e}function mm(t,e=0){const s=pm(t);let i=s[e];return void 0===i&&(s[e]=i=new Nt),i}const gm=Ai(dm),ym=Vi(([t,e])=>ea(1,t.oneMinus().div(e)).oneMinus()).setLayout({name:"blendBurn",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),fm=Vi(([t,e])=>ea(t.div(e.oneMinus()),1)).setLayout({name:"blendDodge",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),xm=Vi(([t,e])=>t.oneMinus().mul(e.oneMinus()).oneMinus()).setLayout({name:"blendScreen",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),bm=Vi(([t,e])=>fa(t.mul(2).mul(e),t.oneMinus().mul(2).mul(e.oneMinus()).oneMinus(),ra(.5,t))).setLayout({name:"blendOverlay",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),vm=Vi(([t,e])=>{const s=e.a.add(t.a.mul(e.a.oneMinus()));return Gi(e.rgb.mul(e.a).add(t.rgb.mul(t.a).mul(e.a.oneMinus())).div(s),s)}).setLayout({name:"blendColor",type:"vec4",inputs:[{name:"base",type:"vec4"},{name:"blend",type:"vec4"}]}),wm=Vi(([t])=>_m(t.rgb)),Tm=Vi(([t,e=Oi(1)])=>e.mix(_m(t.rgb),t.rgb)),Nm=Vi(([t,e=Oi(1)])=>{const s=Xr(t.r,t.g,t.b).div(3),i=t.r.max(t.g.max(t.b)),r=i.sub(s).mul(e).mul(-3);return fa(t.rgb,i,r)}),Mm=Vi(([t,e=Oi(1)])=>{const s=Wi(.57735,.57735,.57735),i=e.cos();return Wi(t.rgb.mul(i).add(s.cross(t.rgb).mul(e.sin()).add(s.mul(ha(s,t.rgb).mul(i.oneMinus())))))}),_m=(t,e=Wi(I.getLuminanceCoefficients(new X)))=>ha(t,e),Sm=Vi(([t,e=Wi(1),s=Wi(0),i=Wi(1),r=Oi(1),n=Wi(I.getLuminanceCoefficients(new X,a))])=>{const o=t.rgb.dot(Wi(n)),h=sa(t.rgb.mul(e).add(s),0).toVar(),l=h.pow(i).toVar();return Ri(h.r.greaterThan(0),()=>{h.r.assign(l.r)}),Ri(h.g.greaterThan(0),()=>{h.g.assign(l.g)}),Ri(h.b.greaterThan(0),()=>{h.b.assign(l.b)}),h.assign(o.add(h.sub(o).mul(r))),Gi(h.rgb,t.a)});class Am extends Ps{static get type(){return"PosterizeNode"}constructor(t,e){super(),this.sourceNode=t,this.stepsNode=e}setup(){const{sourceNode:t,stepsNode:e}=this;return t.mul(e).floor().div(e)}}const Vm=Si(Am),zm=new S;class Cm extends Eo{static get type(){return"PassTextureNode"}constructor(t,e){super(e),this.passNode=t,this.setUpdateMatrix(!1)}setup(t){return t.object.isQuadMesh&&this.passNode.build(t),super.setup(t)}clone(){return new this.constructor(this.passNode,this.value)}}class Rm extends Cm{static get type(){return"PassMultipleTextureNode"}constructor(t,e,s=!1){super(t,null),this.textureName=e,this.previousTexture=s}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(t){return this.updateTexture(),super.setup(t)}clone(){return new this.constructor(this.passNode,this.textureName,this.previousTexture)}}class Em extends Ps{static get type(){return"PassNode"}constructor(t,e,s,r={}){super("vec4"),this.scope=t,this.scene=e,this.camera=s,this.options=r,this._pixelRatio=1,this._width=1,this._height=1;const n=new hs;n.isRenderTargetTexture=!0,n.name="depth";const a=new q(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:i,...r});a.texture.name="output",a.depthTexture=n,this.renderTarget=a,this._textures={output:a.texture,depth:n},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=ur(0),this._cameraFar=ur(0),this._mrt=null,this._layers=null,this._resolution=1,this.isPassNode=!0,this.updateBeforeType=zs.FRAME}setResolution(t){return this._resolution=t,this}getResolution(){return this._resolution}setLayers(t){return this._layers=t,this}getLayers(){return this._layers}setMRT(t){return this._mrt=t,this}getMRT(){return this._mrt}isGlobal(){return!0}getTexture(t){let e=this._textures[t];if(void 0===e){e=this.renderTarget.texture.clone(),e.name=t,this._textures[t]=e,this.renderTarget.textures.push(e)}return e}getPreviousTexture(t){let e=this._previousTextures[t];return void 0===e&&(e=this.getTexture(t).clone(),this._previousTextures[t]=e),e}toggleTexture(t){const e=this._previousTextures[t];if(void 0!==e){const s=this._textures[t],i=this.renderTarget.textures.indexOf(s);this.renderTarget.textures[i]=e,this._textures[t]=e,this._previousTextures[t]=s,this._textureNodes[t].updateTexture(),this._previousTextureNodes[t].updateTexture()}}getTextureNode(t="output"){let e=this._textureNodes[t];return void 0===e&&(e=Ni(new Rm(this,t)),e.updateTexture(),this._textureNodes[t]=e),e}getPreviousTextureNode(t="output"){let e=this._previousTextureNodes[t];return void 0===e&&(void 0===this._textureNodes[t]&&this.getTextureNode(t),e=Ni(new Rm(this,t,!0)),e.updateTexture(),this._previousTextureNodes[t]=e),e}getViewZNode(t="depth"){let e=this._viewZNodes[t];if(void 0===e){const s=this._cameraNear,i=this._cameraFar;this._viewZNodes[t]=e=oc(this.getTextureNode(t),s,i)}return e}getLinearDepthNode(t="depth"){let e=this._linearDepthNodes[t];if(void 0===e){const s=this._cameraNear,i=this._cameraFar,r=this.getViewZNode(t);this._linearDepthNodes[t]=e=nc(r,s,i)}return e}setup({renderer:t}){return this.renderTarget.samples=void 0===this.options.samples?t.samples:this.options.samples,!0===t.backend.isWebGLBackend&&(this.renderTarget.samples=0),this.renderTarget.texture.type=t.getColorBufferType(),this.scope===Em.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(t){const{renderer:e}=t,{scene:s}=this;let i,r;const n=e.getOutputRenderTarget();n&&!0===n.isXRRenderTarget?(r=1,i=e.xr.getCamera(),e.xr.updateCamera(i),zm.set(n.width,n.height)):(i=this.camera,r=e.getPixelRatio(),e.getSize(zm)),this._pixelRatio=r,this.setSize(zm.width,zm.height);const a=e.getRenderTarget(),o=e.getMRT(),h=i.layers.mask;this._cameraNear.value=i.near,this._cameraFar.value=i.far,null!==this._layers&&(i.layers.mask=this._layers.mask);for(const t in this._previousTextures)this.toggleTexture(t);e.setRenderTarget(this.renderTarget),e.setMRT(this._mrt),e.render(s,i),e.setRenderTarget(a),e.setMRT(o),i.layers.mask=h}setSize(t,e){this._width=t,this._height=e;const s=this._width*this._pixelRatio*this._resolution,i=this._height*this._pixelRatio*this._resolution;this.renderTarget.setSize(s,i)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}Em.COLOR="color",Em.DEPTH="depth";class Im extends Em{static get type(){return"ToonOutlinePassNode"}constructor(t,e,s,i,r){super(Em.COLOR,t,e),this.colorNode=s,this.thicknessNode=i,this.alphaNode=r,this._materialCache=new WeakMap}updateBefore(t){const{renderer:e}=t,s=e.getRenderObjectFunction();e.setRenderObjectFunction((t,s,i,r,n,a,o,h)=>{if((n.isMeshToonMaterial||n.isMeshToonNodeMaterial)&&!1===n.wireframe){const l=this._getOutlineMaterial(n);e.renderObject(t,s,i,r,l,a,o,h)}e.renderObject(t,s,i,r,n,a,o,h)}),super.updateBefore(t),e.setRenderObjectFunction(s)}_createMaterial(){const t=new xc;t.isMeshToonOutlineMaterial=!0,t.name="Toon_Outline",t.side=1;const e=Ah.negate(),s=jo.mul(dh),i=Oi(1),r=s.mul(Gi(fh,1)),n=s.mul(Gi(fh.add(e),1)),a=In(r.sub(n));return t.vertexNode=r.add(a.mul(this.thicknessNode).mul(r.w).mul(i)),t.colorNode=Gi(this.colorNode,this.alphaNode),t}_getOutlineMaterial(t){let e=this._materialCache.get(t);return void 0===e&&(e=this._createMaterial(),this._materialCache.set(t,e)),e}}const Om=Vi(([t,e])=>t.mul(e).clamp()).setLayout({name:"linearToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Lm=Vi(([t,e])=>(t=t.mul(e)).div(t.add(1)).clamp()).setLayout({name:"reinhardToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Bm=Vi(([t,e])=>{const s=(t=(t=t.mul(e)).sub(.004).max(0)).mul(t.mul(6.2).add(.5)),i=t.mul(t.mul(6.2).add(1.7)).add(.06);return s.div(i).pow(2.2)}).setLayout({name:"cineonToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Fm=Vi(([t])=>{const e=t.mul(t.add(.0245786)).sub(90537e-9),s=t.mul(t.add(.432951).mul(.983729)).add(.238081);return e.div(s)}),Pm=Vi(([t,e])=>{const s=Ji(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),i=Ji(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return t=t.mul(e).div(.6),t=s.mul(t),t=Fm(t),(t=i.mul(t)).clamp()}).setLayout({name:"acesFilmicToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Dm=Ji(Wi(1.6605,-.1246,-.0182),Wi(-.5876,1.1329,-.1006),Wi(-.0728,-.0083,1.1187)),km=Ji(Wi(.6274,.0691,.0164),Wi(.3293,.9195,.088),Wi(.0433,.0113,.8956)),Um=Vi(([t])=>{const e=Wi(t).toVar(),s=Wi(e.mul(e)).toVar(),i=Wi(s.mul(s)).toVar();return Oi(15.5).mul(i.mul(s)).sub(Yr(40.14,i.mul(e))).add(Yr(31.96,i).sub(Yr(6.868,s.mul(e))).add(Yr(.4298,s).add(Yr(.1191,e).sub(.00232))))}),Wm=Vi(([t,e])=>{const s=Wi(t).toVar(),i=Ji(Wi(.856627153315983,.137318972929847,.11189821299995),Wi(.0951212405381588,.761241990602591,.0767994186031903),Wi(.0482516061458583,.101439036467562,.811302368396859)),r=Ji(Wi(1.1271005818144368,-.1413297634984383,-.14132976349843826),Wi(-.11060664309660323,1.157823702216272,-.11060664309660294),Wi(-.016493938717834573,-.016493938717834257,1.2519364065950405)),n=Oi(-12.47393),a=Oi(4.026069);return s.mulAssign(e),s.assign(km.mul(s)),s.assign(i.mul(s)),s.assign(sa(s,1e-10)),s.assign(Vn(s)),s.assign(s.sub(n).div(a.sub(n))),s.assign(xa(s,0,1)),s.assign(Um(s)),s.assign(r.mul(s)),s.assign(ua(sa(Wi(0),s),Wi(2.2))),s.assign(Dm.mul(s)),s.assign(xa(s,0,1)),s}).setLayout({name:"agxToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),jm=Vi(([t,e])=>{const s=Oi(.76),i=Oi(.15);t=t.mul(e);const r=ea(t.r,ea(t.g,t.b)),n=Ca(r.lessThan(.08),r.sub(Yr(6.25,r.mul(r))),.04);t.subAssign(n);const a=sa(t.r,sa(t.g,t.b));Ri(a.lessThan(s),()=>t);const o=$r(1,s),h=$r(1,o.mul(o).div(a.add(o.sub(s))));t.mulAssign(h.div(a));const l=$r(1,Zr(1,i.mul(a.sub(h)).add(1)));return fa(t,Wi(h),l)}).setLayout({name:"neutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]});class qm extends Ls{static get type(){return"CodeNode"}constructor(t="",e=[],s=""){super("code"),this.isCodeNode=!0,this.code=t,this.includes=e,this.language=s}isGlobal(){return!0}setIncludes(t){return this.includes=t,this}getIncludes(){return this.includes}generate(t){const e=this.getIncludes(t);for(const s of e)s.build(t);const s=t.getCodeFromNode(this,this.getNodeType(t));return s.code=this.code,s.code}serialize(t){super.serialize(t),t.code=this.code,t.language=this.language}deserialize(t){super.deserialize(t),this.code=t.code,this.language=t.language}}const Hm=Si(qm);class Gm extends qm{static get type(){return"FunctionNode"}constructor(t="",e=[],s=""){super(t,e,s)}getNodeType(t){return this.getNodeFunction(t).type}getInputs(t){return this.getNodeFunction(t).inputs}getNodeFunction(t){const e=t.getDataFromNode(this);let s=e.nodeFunction;return void 0===s&&(s=t.parser.parseFunction(this.code),e.nodeFunction=s),s}generate(t,e){super.generate(t);const s=this.getNodeFunction(t),i=s.name,r=s.type,n=t.getCodeFromNode(this,r);""!==i&&(n.name=i);const a=t.getPropertyName(n),o=this.getNodeFunction(t).getCode(a);return n.code=o+"\n","property"===e?a:t.format(`${a}()`,r,e)}}const Xm=(t,e=[],s="")=>{for(let t=0;t<e.length;t++){const s=e[t];"function"==typeof s&&(e[t]=s.functionNode)}const i=Ni(new Gm(t,e,s)),r=(...t)=>i.call(...t);return r.functionNode=i,r};class $m extends Ls{static get type(){return"ScriptableValueNode"}constructor(t=null){super(),this._value=t,this._cache=null,this.inputType=null,this.outputType=null,this.events=new m,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return null!==this.outputType}set value(t){this._value!==t&&(this._cache&&"URL"===this.inputType&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=t,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const t=this.value;if(t&&null===this._cache&&"URL"===this.inputType&&t.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([t.value]));else if(t&&null!==t.value&&void 0!==t.value&&(("URL"===this.inputType||"String"===this.inputType)&&"string"==typeof t.value||"Number"===this.inputType&&"number"==typeof t.value||"Vector2"===this.inputType&&t.value.isVector2||"Vector3"===this.inputType&&t.value.isVector3||"Vector4"===this.inputType&&t.value.isVector4||"Color"===this.inputType&&t.value.isColor||"Matrix3"===this.inputType&&t.value.isMatrix3||"Matrix4"===this.inputType&&t.value.isMatrix4))return t.value;return this._cache||t}getNodeType(t){return this.value&&this.value.isNode?this.value.getNodeType(t):"float"}setup(){return this.value&&this.value.isNode?this.value:Oi()}serialize(t){super.serialize(t),null!==this.value?"ArrayBuffer"===this.inputType?t.value=Ss(this.value):t.value=this.value?this.value.toJSON(t.meta).uuid:null:t.value=null,t.inputType=this.inputType,t.outputType=this.outputType}deserialize(t){super.deserialize(t);let e=null;null!==t.value&&(e="ArrayBuffer"===t.inputType?As(t.value):"Texture"===t.inputType?t.meta.textures[t.value]:t.meta.nodes[t.value]||null),this.value=e,this.inputType=t.inputType,this.outputType=t.outputType}}const Ym=Si($m);class Zm extends Map{get(t,e=null,...s){if(this.has(t))return super.get(t);if(null!==e){const i=e(...s);return this.set(t,i),i}}}class Jm{constructor(t){this.scriptableNode=t}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(t){return this.scriptableNode.getInputLayout(t)}get(t){const e=this.parameters[t];return e?e.getValue():null}}const Qm=new Zm;class Km extends Ls{static get type(){return"ScriptableNode"}constructor(t=null,e={}){super(),this.codeNode=t,this.parameters=e,this._local=new Zm,this._output=Ym(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(t,e){return this._local.set(t,e)}getLocal(t){return this._local.get(t)}onRefresh(){this._refresh()}getInputLayout(t){for(const e of this.getLayout())if(e.inputType&&(e.id===t||e.name===t))return e}getOutputLayout(t){for(const e of this.getLayout())if(e.outputType&&(e.id===t||e.name===t))return e}setOutput(t,e){const s=this._outputs;return void 0===s[t]?s[t]=Ym(e):s[t].value=e,this}getOutput(t){return this._outputs[t]}getParameter(t){return this.parameters[t]}setParameter(t,e){const s=this.parameters;return e&&e.isScriptableNode?(this.deleteParameter(t),s[t]=e,s[t].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):e&&e.isScriptableValueNode?(this.deleteParameter(t),s[t]=e,s[t].events.addEventListener("refresh",this.onRefresh)):void 0===s[t]?(s[t]=Ym(e),s[t].events.addEventListener("refresh",this.onRefresh)):s[t].value=e,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(t){let e=this.parameters[t];return e&&(e.isScriptableNode&&(e=e.getDefaultOutput()),e.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const t of Object.keys(this.parameters))this.deleteParameter(t);return this.needsUpdate=!0,this}call(t,...e){const s=this.getObject()[t];if("function"==typeof s)return s(...e)}async callAsync(t,...e){const s=this.getObject()[t];if("function"==typeof s)return"AsyncFunction"===s.constructor.name?await s(...e):s(...e)}getNodeType(t){return this.getDefaultOutputNode().getNodeType(t)}refresh(t=null){null!==t?this.getOutput(t).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),null!==this._object)return this._object;const t=new Jm(this),e=Qm.get("THREE"),s=Qm.get("TSL"),i=this.getMethod(),r=[t,this._local,Qm,()=>this.refresh(),(t,e)=>this.setOutput(t,e),e,s];this._object=i(...r);const n=this._object.layout;if(n&&(!1===n.cache&&this._local.clear(),this._output.outputType=n.outputType||null,Array.isArray(n.elements)))for(const t of n.elements){const e=t.id||t.name;t.inputType&&(void 0===this.getParameter(e)&&this.setParameter(e,null),this.getParameter(e).inputType=t.inputType),t.outputType&&(void 0===this.getOutput(e)&&this.setOutput(e,null),this.getOutput(e).outputType=t.outputType)}return this._object}deserialize(t){super.deserialize(t);for(const t in this.parameters){let e=this.parameters[t];e.isScriptableNode&&(e=e.getDefaultOutput()),e.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const t=this.getDefaultOutput().value;return t&&t.isNode?t:Oi()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),null!==this._method)return this._method;const t=["layout","init","main","dispose"].join(", "),e="\nreturn { ...output, "+t+" };",s="var "+t+"; var output = {};\n"+this.codeNode.code+e;return this._method=new Function(...["parameters","local","global","refresh","setOutput","THREE","TSL"],s),this._method}dispose(){null!==this._method&&(this._object&&"function"==typeof this._object.dispose&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}getCacheKey(t){const e=[(s=this.source,ms(s)),this.getDefaultOutputNode().getCacheKey(t)];var s;for(const s in this.parameters)e.push(this.parameters[s].getCacheKey(t));return gs(e)}set needsUpdate(t){!0===t&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return null===this.codeNode||(!0===this._needsOutputUpdate&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value),this}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const tg=Si(Km);function eg(t){let e;const s=t.context.getViewZ;return void 0!==s&&(e=s(this)),(e||wh.z).negate()}const sg=Vi(([t,e],s)=>{const i=eg(s);return wa(t,e,i)}),ig=Vi(([t],e)=>{const s=eg(e);return t.mul(t,s,s).negate().exp().oneMinus()}),rg=Vi(([t,e])=>Gi(e.toFloat().mix(Er.rgb,t.toVec3()),Er.a));let ng=null,ag=null;class og extends Ls{static get type(){return"RangeNode"}constructor(t=Oi(),e=Oi()){super(),this.minNode=t,this.maxNode=e}getVectorLength(t){const e=t.getTypeLength(Ns(this.minNode.value)),s=t.getTypeLength(Ns(this.maxNode.value));return e>s?e:s}getNodeType(t){return t.object.count>1?t.getTypeFromLength(this.getVectorLength(t)):"float"}setup(t){const e=t.object;let s=null;if(e.count>1){const i=this.minNode.value,r=this.maxNode.value,n=t.getTypeLength(Ns(i)),a=t.getTypeLength(Ns(r));ng=ng||new j,ag=ag||new j,ng.setScalar(0),ag.setScalar(0),1===n?ng.setScalar(i):i.isColor?ng.set(i.r,i.g,i.b,1):ng.set(i.x,i.y,i.z||0,i.w||0),1===a?ag.setScalar(r):r.isColor?ag.set(r.r,r.g,r.b,1):ag.set(r.x,r.y,r.z||0,r.w||0);const o=4,h=o*e.count,l=new Float32Array(h);for(let t=0;t<h;t++){const e=t%o,s=ng.getComponent(e),i=ag.getComponent(e);l[t]=_.lerp(s,i,Math.random())}const u=this.getNodeType(t);if(e.count<=4096)s=Bo(l,"vec4",e.count).element(cu).convert(u);else{const e=new is(l,4);t.geometry.setAttribute("__range"+this.id,e),s=ho(e).convert(u)}}else s=Oi(0);return s}}const hg=Si(og);class lg extends Ls{static get type(){return"ComputeBuiltinNode"}constructor(t,e){super(e),this._builtinName=t}getHash(t){return this.getBuiltinName(t)}getNodeType(){return this.nodeType}setBuiltinName(t){return this._builtinName=t,this}getBuiltinName(){return this._builtinName}hasBuiltin(t){return t.hasBuiltin(this._builtinName)}generate(t,e){const s=this.getBuiltinName(t),i=this.getNodeType(t);return"compute"===t.shaderStage?t.format(s,i,e):(console.warn(`ComputeBuiltinNode: Compute built-in value ${s} can not be accessed in the ${t.shaderStage} stage`),t.generateConst(i))}serialize(t){super.serialize(t),t.global=this.global,t._builtinName=this._builtinName}deserialize(t){super.deserialize(t),this.global=t.global,this._builtinName=t._builtinName}}const ug=(t,e)=>Ni(new lg(t,e)),cg=ug("numWorkgroups","uvec3"),dg=ug("workgroupId","uvec3"),pg=ug("globalId","uvec3"),mg=ug("localId","uvec3"),gg=ug("subgroupSize","uint");const yg=Si(class extends Ls{constructor(t){super(),this.scope=t}generate(t){const{scope:e}=this,{renderer:s}=t;!0===s.backend.isWebGLBackend?t.addFlowCode(`\t// ${e}Barrier \n`):t.addLineFlowCode(`${e}Barrier()`,this)}});class fg extends Bs{constructor(t,e){super(t,e),this.isWorkgroupInfoElementNode=!0}generate(t,e){let s;const i=t.context.assign;if(s=super.generate(t),!0!==i){const i=this.getNodeType(t);s=t.format(s,i,e)}return s}}class xg extends Ls{constructor(t,e,s=0){super(e),this.bufferType=e,this.bufferCount=s,this.isWorkgroupInfoNode=!0,this.elementType=e,this.scope=t}label(t){return this.name=t,this}setScope(t){return this.scope=t,this}getElementType(){return this.elementType}getInputType(){return`${this.scope}Array`}element(t){return Ni(new fg(this,t))}generate(t){return t.getScopedArray(this.name||`${this.scope}Array_${this.id}`,this.scope.toLowerCase(),this.bufferType,this.bufferCount)}}class bg extends Ps{static get type(){return"AtomicFunctionNode"}constructor(t,e,s,i=null){super("uint"),this.method=t,this.pointerNode=e,this.valueNode=s,this.storeNode=i}getInputType(t){return this.pointerNode.getNodeType(t)}getNodeType(t){return this.getInputType(t)}generate(t){const e=this.method,s=this.getNodeType(t),i=this.getInputType(t),r=this.pointerNode,n=this.valueNode,a=[];a.push(`&${r.build(t,i)}`),null!==n&&a.push(n.build(t,i));const o=`${t.getMethod(e,s)}( ${a.join(", ")} )`;if(null!==this.storeNode){const e=this.storeNode.build(t,i);t.addLineFlowCode(`${e} = ${o}`,this)}else t.addLineFlowCode(o,this)}}bg.ATOMIC_LOAD="atomicLoad",bg.ATOMIC_STORE="atomicStore",bg.ATOMIC_ADD="atomicAdd",bg.ATOMIC_SUB="atomicSub",bg.ATOMIC_MAX="atomicMax",bg.ATOMIC_MIN="atomicMin",bg.ATOMIC_AND="atomicAnd",bg.ATOMIC_OR="atomicOr",bg.ATOMIC_XOR="atomicXor";const vg=Si(bg),wg=(t,e,s,i=null)=>{const r=vg(t,e,s,i);return r.append(),r};let Tg;function Ng(t){Tg=Tg||new WeakMap;let e=Tg.get(t);return void 0===e&&Tg.set(t,e={}),e}function Mg(t){const e=Ng(t);return e.shadowMatrix||(e.shadowMatrix=ur("mat4").setGroup(or).onRenderUpdate(()=>(!0!==t.castShadow&&t.shadow.updateMatrices(t),t.shadow.matrix)))}function _g(t){const e=Ng(t);return e.position||(e.position=ur(new X).setGroup(or).onRenderUpdate((e,s)=>s.value.setFromMatrixPosition(t.matrixWorld)))}function Sg(t){const e=Ng(t);return e.targetPosition||(e.targetPosition=ur(new X).setGroup(or).onRenderUpdate((e,s)=>s.value.setFromMatrixPosition(t.target.matrixWorld)))}const Ag=(t,e)=>{for(const s of e)if(s.isAnalyticLightNode&&s.light.id===t)return s;return null},Vg=new WeakMap;class zg extends Ls{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=Wi().toVar("totalDiffuse"),this.totalSpecularNode=Wi().toVar("totalSpecular"),this.outgoingLightNode=Wi().toVar("outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}customCacheKey(){const t=[],e=this._lights;for(let s=0;s<e.length;s++)t.push(e[s].id);return gs(t)}getHash(t){if(null===this._lightNodesHash){null===this._lightNodes&&this.setupLightsNode(t);const e=[];for(const t of this._lightNodes)e.push(t.getSelf().getHash());this._lightNodesHash="lights-"+e.join(",")}return this._lightNodesHash}analyze(t){const e=t.getDataFromNode(this);for(const s of e.nodes)s.build(t)}setupLightsNode(t){const e=[],s=this._lightNodes,i=(t=>t.sort((t,e)=>t.id-e.id))(this._lights),r=t.renderer.library;for(const t of i)if(t.isNode)e.push(Ni(t));else{let i=null;if(null!==s&&(i=Ag(t.id,s)),null===i){const s=r.getLightNodeClass(t.constructor);if(null===s){console.warn(`LightsNode.setupNodeLights: Light node not found for ${t.constructor.name}`);continue}let i=null;Vg.has(t)?i=Vg.get(t):(i=Ni(new s(t)),Vg.set(t,i)),e.push(i)}}this._lightNodes=e}setupDirectLight(t,e,s){const{lightingModel:i,reflectedLight:r}=t.context;i.direct({...s,lightNode:e,reflectedLight:r},t)}setupDirectRectAreaLight(t,e,s){const{lightingModel:i,reflectedLight:r}=t.context;i.directRectArea({...s,lightNode:e,reflectedLight:r},t)}setupLights(t,e){for(const s of e)s.build(t)}getLightNodes(t){return null===this._lightNodes&&this.setupLightsNode(t),this._lightNodes}setup(t){const e=t.lightsNode;t.lightsNode=this;let s=this.outgoingLightNode;const i=t.context,r=i.lightingModel,n=t.getDataFromNode(this);if(r){const{totalDiffuseNode:e,totalSpecularNode:a}=this;i.outgoingLight=s;const o=t.addStack();n.nodes=o.nodes,r.start(t);const{backdrop:h,backdropAlpha:l}=i,{directDiffuse:u,directSpecular:c,indirectDiffuse:d,indirectSpecular:p}=i.reflectedLight;let m=u.add(d);null!==h&&(m=Wi(null!==l?l.mix(m,h):h),i.material.transparent=!0),e.assign(m),a.assign(c.add(p)),s.assign(e.add(a)),r.finish(t),s=s.bypass(t.removeStack())}else n.nodes=[];return t.lightsNode=e,s}setLights(t){return this._lights=t,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}class Cg extends Ls{static get type(){return"ShadowBaseNode"}constructor(t){super(),this.light=t,this.updateBeforeType=zs.RENDER,this.isShadowBaseNode=!0}setupShadowPosition({context:t,material:e}){Rg.assign(e.shadowPositionNode||t.shadowPositionWorld||bh)}dispose(){this.updateBeforeType=zs.NONE}}const Rg=dr("vec3","shadowPositionWorld");function Eg(t,e={}){return e.toneMapping=t.toneMapping,e.toneMappingExposure=t.toneMappingExposure,e.outputColorSpace=t.outputColorSpace,e.renderTarget=t.getRenderTarget(),e.activeCubeFace=t.getActiveCubeFace(),e.activeMipmapLevel=t.getActiveMipmapLevel(),e.renderObjectFunction=t.getRenderObjectFunction(),e.pixelRatio=t.getPixelRatio(),e.mrt=t.getMRT(),e.clearColor=t.getClearColor(e.clearColor||new ge),e.clearAlpha=t.getClearAlpha(),e.autoClear=t.autoClear,e.scissorTest=t.getScissorTest(),e}function Ig(t,e){return e=Eg(t,e),t.setMRT(null),t.setRenderObjectFunction(null),t.setClearColor(0,1),t.autoClear=!0,e}function Og(t,e){t.toneMapping=e.toneMapping,t.toneMappingExposure=e.toneMappingExposure,t.outputColorSpace=e.outputColorSpace,t.setRenderTarget(e.renderTarget,e.activeCubeFace,e.activeMipmapLevel),t.setRenderObjectFunction(e.renderObjectFunction),t.setPixelRatio(e.pixelRatio),t.setMRT(e.mrt),t.setClearColor(e.clearColor,e.clearAlpha),t.autoClear=e.autoClear,t.setScissorTest(e.scissorTest)}function Lg(t,e={}){return e.background=t.background,e.backgroundNode=t.backgroundNode,e.overrideMaterial=t.overrideMaterial,e}function Bg(t,e){return e=Lg(t,e),t.background=null,t.backgroundNode=null,t.overrideMaterial=null,e}function Fg(t,e){t.background=e.background,t.backgroundNode=e.backgroundNode,t.overrideMaterial=e.overrideMaterial}function Pg(t,e,s){return s=Bg(e,s=Ig(t,s))}function Dg(t,e,s){Og(t,s),Fg(e,s)}var kg=Object.freeze({__proto__:null,resetRendererAndSceneState:Pg,resetRendererState:Ig,resetSceneState:Bg,restoreRendererAndSceneState:Dg,restoreRendererState:Og,restoreSceneState:Fg,saveRendererAndSceneState:function(t,e,s={}){return s=Lg(e,s=Eg(t,s))},saveRendererState:Eg,saveSceneState:Lg});const Ug=new WeakMap,Wg=Vi(([t,e,s])=>{let i=bh.sub(t).length();return i=i.sub(e).div(s.sub(e)),i=i.saturate(),i}),jg=t=>{let e=Ug.get(t);if(void 0===e){const s=t.isPointLight?(t=>{const e=t.shadow.camera,s=Yh("near","float",e).setGroup(or),i=Yh("far","float",e).setGroup(or),r=Ko(t);return Wg(r,s,i)})(t):null;e=new xc,e.colorNode=Gi(0,0,0,1),e.depthNode=s,e.isShadowPassMaterial=!0,e.name="ShadowMaterial",e.fog=!1,Ug.set(t,e)}return e},qg=Vi(({depthTexture:t,shadowCoord:e})=>Io(t,e.xy).compare(e.z)),Hg=Vi(({depthTexture:t,shadowCoord:e,shadow:s})=>{const i=(e,s)=>Io(t,e).compare(s),r=Yh("mapSize","vec2",s).setGroup(or),n=Yh("radius","float",s).setGroup(or),a=Pi(1).div(r),o=a.x.negate().mul(n),h=a.y.negate().mul(n),l=a.x.mul(n),u=a.y.mul(n),c=o.div(2),d=h.div(2),p=l.div(2),m=u.div(2);return Xr(i(e.xy.add(Pi(o,h)),e.z),i(e.xy.add(Pi(0,h)),e.z),i(e.xy.add(Pi(l,h)),e.z),i(e.xy.add(Pi(c,d)),e.z),i(e.xy.add(Pi(0,d)),e.z),i(e.xy.add(Pi(p,d)),e.z),i(e.xy.add(Pi(o,0)),e.z),i(e.xy.add(Pi(c,0)),e.z),i(e.xy,e.z),i(e.xy.add(Pi(p,0)),e.z),i(e.xy.add(Pi(l,0)),e.z),i(e.xy.add(Pi(c,m)),e.z),i(e.xy.add(Pi(0,m)),e.z),i(e.xy.add(Pi(p,m)),e.z),i(e.xy.add(Pi(o,u)),e.z),i(e.xy.add(Pi(0,u)),e.z),i(e.xy.add(Pi(l,u)),e.z)).mul(1/17)}),Gg=Vi(({depthTexture:t,shadowCoord:e,shadow:s})=>{const i=(e,s)=>Io(t,e).compare(s),r=Yh("mapSize","vec2",s).setGroup(or),n=Pi(1).div(r),a=n.x,o=n.y,h=e.xy,l=On(h.mul(r).add(.5));return h.subAssign(l.mul(n)),Xr(i(h,e.z),i(h.add(Pi(a,0)),e.z),i(h.add(Pi(0,o)),e.z),i(h.add(n),e.z),fa(i(h.add(Pi(a.negate(),0)),e.z),i(h.add(Pi(a.mul(2),0)),e.z),l.x),fa(i(h.add(Pi(a.negate(),o)),e.z),i(h.add(Pi(a.mul(2),o)),e.z),l.x),fa(i(h.add(Pi(0,o.negate())),e.z),i(h.add(Pi(0,o.mul(2))),e.z),l.y),fa(i(h.add(Pi(a,o.negate())),e.z),i(h.add(Pi(a,o.mul(2))),e.z),l.y),fa(fa(i(h.add(Pi(a.negate(),o.negate())),e.z),i(h.add(Pi(a.mul(2),o.negate())),e.z),l.x),fa(i(h.add(Pi(a.negate(),o.mul(2))),e.z),i(h.add(Pi(a.mul(2),o.mul(2))),e.z),l.x),l.y)).mul(1/9)}),Xg=Vi(({depthTexture:t,shadowCoord:e})=>{const s=Oi(1).toVar(),i=Io(t).sample(e.xy).rg,r=ra(e.z,i.x);return Ri(r.notEqual(Oi(1)),()=>{const t=e.z.sub(i.x),n=sa(0,i.y.mul(i.y));let a=n.div(n.add(t.mul(t)));a=xa($r(a,.3).div(.95-.3)),s.assign(xa(sa(r,a)))}),s}),$g=Vi(({samples:t,radius:e,size:s,shadowPass:i})=>{const r=Oi(0).toVar(),n=Oi(0).toVar(),a=t.lessThanEqual(Oi(1)).select(Oi(0),Oi(2).div(t.sub(1))),o=t.lessThanEqual(Oi(1)).select(Oi(0),Oi(-1));Su({start:Li(0),end:Li(t),type:"int",condition:"<"},({i:t})=>{const h=o.add(Oi(t).mul(a)),l=i.sample(Xr(ju.xy,Pi(0,h).mul(e)).div(s)).x;r.addAssign(l),n.addAssign(l.mul(l))}),r.divAssign(t),n.divAssign(t);const h=zn(n.sub(r.mul(r)));return Pi(r,h)}),Yg=Vi(({samples:t,radius:e,size:s,shadowPass:i})=>{const r=Oi(0).toVar(),n=Oi(0).toVar(),a=t.lessThanEqual(Oi(1)).select(Oi(0),Oi(2).div(t.sub(1))),o=t.lessThanEqual(Oi(1)).select(Oi(0),Oi(-1));Su({start:Li(0),end:Li(t),type:"int",condition:"<"},({i:t})=>{const h=o.add(Oi(t).mul(a)),l=i.sample(Xr(ju.xy,Pi(h,0).mul(e)).div(s));r.addAssign(l.x),n.addAssign(Xr(l.y.mul(l.y),l.x.mul(l.x)))}),r.divAssign(t),n.divAssign(t);const h=zn(n.sub(r.mul(r)));return Pi(r,h)}),Zg=[qg,Hg,Gg,Xg];let Jg;const Qg=new Fp;class Kg extends Cg{static get type(){return"ShadowNode"}constructor(t,e=null){super(t),this.shadow=e||t.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this._node=null,this._cameraFrameId=new WeakMap,this.isShadowNode=!0}setupShadowFilter(t,{filterFn:e,depthTexture:s,shadowCoord:i,shadow:r}){const n=i.x.greaterThanEqual(0).and(i.x.lessThanEqual(1)).and(i.y.greaterThanEqual(0)).and(i.y.lessThanEqual(1)).and(i.z.lessThanEqual(1)),a=e({depthTexture:s,shadowCoord:i,shadow:r});return n.select(a,Oi(1))}setupShadowCoord(t,e){const{shadow:s}=this,{renderer:i}=t,r=Yh("bias","float",s).setGroup(or);let n,a=e;if(s.camera.isOrthographicCamera||!0!==i.logarithmicDepthBuffer)a=a.xyz.div(a.w),n=a.z,i.coordinateSystem===p&&(n=n.mul(2).sub(1));else{const t=a.w;a=a.xy.div(t);const e=Yh("near","float",s.camera).setGroup(or),i=Yh("far","float",s.camera).setGroup(or);n=hc(t.negate(),e,i)}return a=Wi(a.x,a.y.oneMinus(),n.add(r)),a}getShadowFilterFn(t){return Zg[t]}setupShadow(t){const{renderer:e}=t,{light:s,shadow:r}=this,n=e.shadowMap.type,a=new hs(r.mapSize.width,r.mapSize.height);a.compareFunction=513;const o=t.createRenderTarget(r.mapSize.width,r.mapSize.height);if(o.depthTexture=a,r.camera.updateProjectionMatrix(),3===n){a.compareFunction=null,this.vsmShadowMapVertical=t.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:1030,type:i}),this.vsmShadowMapHorizontal=t.createRenderTarget(r.mapSize.width,r.mapSize.height,{format:1030,type:i});const e=Io(a),s=Io(this.vsmShadowMapVertical.texture),n=Yh("blurSamples","float",r).setGroup(or),o=Yh("radius","float",r).setGroup(or),h=Yh("mapSize","vec2",r).setGroup(or);let l=this.vsmMaterialVertical||(this.vsmMaterialVertical=new xc);l.fragmentNode=$g({samples:n,radius:o,size:h,shadowPass:e}).context(t.getSharedContext()),l.name="VSMVertical",l=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new xc),l.fragmentNode=Yg({samples:n,radius:o,size:h,shadowPass:s}).context(t.getSharedContext()),l.name="VSMHorizontal"}const h=Yh("intensity","float",r).setGroup(or),l=Yh("normalBias","float",r).setGroup(or),u=Mg(s).mul(Rg.add(Eh.mul(l))),c=this.setupShadowCoord(t,u),d=r.filterNode||this.getShadowFilterFn(e.shadowMap.type)||null;if(null===d)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const p=3===n?this.vsmShadowMapHorizontal.texture:a,m=this.setupShadowFilter(t,{filterFn:d,shadowTexture:o.texture,depthTexture:p,shadowCoord:c,shadow:r}),g=Io(o.texture,c),y=fa(1,m.rgb.mix(g,1),h.mul(g.a)).toVar();return this.shadowMap=o,this.shadow.map=o,y}setup(t){if(!1!==t.renderer.shadowMap.enabled)return Vi(()=>{let e=this._node;return this.setupShadowPosition(t),null===e&&(this._node=e=this.setupShadow(t)),t.material.shadowNode&&console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'),t.material.receivedShadowNode&&(e=t.material.receivedShadowNode(e)),e})()}renderShadow(t){const{shadow:e,shadowMap:s,light:i}=this,{renderer:r,scene:n}=t;e.updateMatrices(i),s.setSize(e.mapSize.width,e.mapSize.height),r.render(n,e.camera)}updateShadow(t){const{shadowMap:e,light:s,shadow:i}=this,{renderer:r,scene:n,camera:a}=t,o=r.shadowMap.type,h=e.depthTexture.version;this._depthVersionCached=h,i.camera.layers.mask=a.layers.mask;const l=r.getRenderObjectFunction(),u=r.getMRT(),c=!!u&&u.has("velocity");Jg=Pg(r,n,Jg),n.overrideMaterial=jg(s),r.setRenderObjectFunction((t,e,s,n,h,l,...u)=>{(!0===t.castShadow||t.receiveShadow&&3===o)&&(c&&(_s(t).useVelocity=!0),t.onBeforeShadow(r,t,a,i.camera,n,e.overrideMaterial,l),r.renderObject(t,e,s,n,h,l,...u),t.onAfterShadow(r,t,a,i.camera,n,e.overrideMaterial,l))}),r.setRenderTarget(e),this.renderShadow(t),r.setRenderObjectFunction(l),!0!==s.isPointLight&&3===o&&this.vsmPass(r),Dg(r,n,Jg)}vsmPass(t){const{shadow:e}=this;this.vsmShadowMapVertical.setSize(e.mapSize.width,e.mapSize.height),this.vsmShadowMapHorizontal.setSize(e.mapSize.width,e.mapSize.height),t.setRenderTarget(this.vsmShadowMapVertical),Qg.material=this.vsmMaterialVertical,Qg.render(t),t.setRenderTarget(this.vsmShadowMapHorizontal),Qg.material=this.vsmMaterialHorizontal,Qg.render(t)}dispose(){this.shadowMap.dispose(),this.shadowMap=null,null!==this.vsmShadowMapVertical&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),null!==this.vsmShadowMapHorizontal&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null),super.dispose()}updateBefore(t){const{shadow:e}=this;let s=e.needsUpdate||e.autoUpdate;s&&(this._cameraFrameId[t.camera]===t.frameId&&(s=!1),this._cameraFrameId[t.camera]=t.frameId),s&&(this.updateShadow(t),this.shadowMap.depthTexture.version===this._depthVersionCached&&(e.needsUpdate=!1))}}const ty=new ge,ey=Vi(([t,e])=>{const s=t.toVar(),i=Un(s),r=Zr(1,sa(i.x,sa(i.y,i.z)));i.mulAssign(r),s.mulAssign(r.mul(e.mul(2).oneMinus()));const n=Pi(s.xy).toVar(),a=e.mul(1.5).oneMinus();return Ri(i.z.greaterThanEqual(a),()=>{Ri(s.z.greaterThan(0),()=>{n.x.assign($r(4,s.x))})}).ElseIf(i.x.greaterThanEqual(a),()=>{const t=Wn(s.x);n.x.assign(s.z.mul(t).add(t.mul(2)))}).ElseIf(i.y.greaterThanEqual(a),()=>{const t=Wn(s.y);n.x.assign(s.x.add(t.mul(2)).add(2)),n.y.assign(s.z.mul(t).sub(2))}),Pi(.125,.25).mul(n).add(Pi(.375,.75)).flipY()}).setLayout({name:"cubeToUV",type:"vec2",inputs:[{name:"pos",type:"vec3"},{name:"texelSizeY",type:"float"}]}),sy=Vi(({depthTexture:t,bd3D:e,dp:s,texelSize:i})=>Io(t,ey(e,i.y)).compare(s)),iy=Vi(({depthTexture:t,bd3D:e,dp:s,texelSize:i,shadow:r})=>{const n=Yh("radius","float",r).setGroup(or),a=Pi(-1,1).mul(n).mul(i.y);return Io(t,ey(e.add(a.xyy),i.y)).compare(s).add(Io(t,ey(e.add(a.yyy),i.y)).compare(s)).add(Io(t,ey(e.add(a.xyx),i.y)).compare(s)).add(Io(t,ey(e.add(a.yyx),i.y)).compare(s)).add(Io(t,ey(e,i.y)).compare(s)).add(Io(t,ey(e.add(a.xxy),i.y)).compare(s)).add(Io(t,ey(e.add(a.yxy),i.y)).compare(s)).add(Io(t,ey(e.add(a.xxx),i.y)).compare(s)).add(Io(t,ey(e.add(a.yxx),i.y)).compare(s)).mul(1/9)}),ry=Vi(({filterFn:t,depthTexture:e,shadowCoord:s,shadow:i})=>{const r=s.xyz.toVar(),n=r.length(),a=ur("float").setGroup(or).onRenderUpdate(()=>i.camera.near),o=ur("float").setGroup(or).onRenderUpdate(()=>i.camera.far),h=Yh("bias","float",i).setGroup(or),l=ur(i.mapSize).setGroup(or),u=Oi(1).toVar();return Ri(n.sub(o).lessThanEqual(0).and(n.sub(a).greaterThanEqual(0)),()=>{const s=n.sub(a).div(o.sub(a)).toVar();s.addAssign(h);const c=r.normalize(),d=Pi(1).div(l.mul(Pi(4,2)));u.assign(t({depthTexture:e,bd3D:c,dp:s,texelSize:d,shadow:i}))}),u}),ny=new j,ay=new S,oy=new S;class hy extends Kg{static get type(){return"PointShadowNode"}constructor(t,e=null){super(t,e)}getShadowFilterFn(t){return 0===t?sy:iy}setupShadowCoord(t,e){return e}setupShadowFilter(t,{filterFn:e,shadowTexture:s,depthTexture:i,shadowCoord:r,shadow:n}){return ry({filterFn:e,shadowTexture:s,depthTexture:i,shadowCoord:r,shadow:n})}renderShadow(t){const{shadow:e,shadowMap:s,light:i}=this,{renderer:r,scene:n}=t,a=e.getFrameExtents();oy.copy(e.mapSize),oy.multiply(a),s.setSize(oy.width,oy.height),ay.copy(e.mapSize);const o=r.autoClear,h=r.getClearColor(ty),l=r.getClearAlpha();r.autoClear=!1,r.setClearColor(e.clearColor,e.clearAlpha),r.clear();const u=e.getViewportCount();for(let t=0;t<u;t++){const a=e.getViewport(t),o=ay.x*a.x,h=oy.y-ay.y-ay.y*a.y;ny.set(o,h,ay.x*a.z,ay.y*a.w),s.viewport.copy(ny),e.updateMatrices(i,t),r.render(n,e.camera)}r.autoClear=o,r.setClearColor(h,l)}}const ly=Vi(({lightDistance:t,cutoffDistance:e,decayExponent:s})=>{const i=t.pow(s).max(.01).reciprocal();return e.greaterThan(0).select(i.mul(t.div(e).pow4().oneMinus().clamp().pow2()),i)}),uy=Vi(([t=Ao()])=>{const e=t.mul(2),s=e.x.floor(),i=e.y.floor();return s.add(i).mod(2).sign()}),cy=Vi(([t=Ao()],{renderer:e,material:s})=>{const i=Oi(1).toVar(),r=ya(t.mul(2).sub(1));if(s.alphaToCoverage&&e.samples>1){const t=Oi(r.fwidth()).toVar();i.assign(wa(t.oneMinus(),t.add(1),r).oneMinus())}else r.greaterThan(1).discard();return i}),dy=Vi(([t,e,s])=>{const i=Oi(s).toVar(),r=Oi(e).toVar(),n=Fi(t).toVar();return Ca(n,r,i)}).setLayout({name:"mx_select",type:"float",inputs:[{name:"b",type:"bool"},{name:"t",type:"float"},{name:"f",type:"float"}]}),py=Vi(([t,e])=>{const s=Fi(e).toVar(),i=Oi(t).toVar();return Ca(s,i.negate(),i)}).setLayout({name:"mx_negate_if",type:"float",inputs:[{name:"val",type:"float"},{name:"b",type:"bool"}]}),my=Vi(([t])=>{const e=Oi(t).toVar();return Li(Rn(e))}).setLayout({name:"mx_floor",type:"int",inputs:[{name:"x",type:"float"}]}),gy=Vi(([t,e])=>{const s=Oi(t).toVar();return e.assign(my(s)),s.sub(Oi(e))}),yy=ap([Vi(([t,e,s,i,r,n])=>{const a=Oi(n).toVar(),o=Oi(r).toVar(),h=Oi(i).toVar(),l=Oi(s).toVar(),u=Oi(e).toVar(),c=Oi(t).toVar(),d=Oi($r(1,o)).toVar();return $r(1,a).mul(c.mul(d).add(u.mul(o))).add(a.mul(l.mul(d).add(h.mul(o))))}).setLayout({name:"mx_bilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"}]}),Vi(([t,e,s,i,r,n])=>{const a=Oi(n).toVar(),o=Oi(r).toVar(),h=Wi(i).toVar(),l=Wi(s).toVar(),u=Wi(e).toVar(),c=Wi(t).toVar(),d=Oi($r(1,o)).toVar();return $r(1,a).mul(c.mul(d).add(u.mul(o))).add(a.mul(l.mul(d).add(h.mul(o))))}).setLayout({name:"mx_bilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"}]})]),fy=ap([Vi(([t,e,s,i,r,n,a,o,h,l,u])=>{const c=Oi(u).toVar(),d=Oi(l).toVar(),p=Oi(h).toVar(),m=Oi(o).toVar(),g=Oi(a).toVar(),y=Oi(n).toVar(),f=Oi(r).toVar(),x=Oi(i).toVar(),b=Oi(s).toVar(),v=Oi(e).toVar(),w=Oi(t).toVar(),T=Oi($r(1,p)).toVar(),N=Oi($r(1,d)).toVar();return Oi($r(1,c)).toVar().mul(N.mul(w.mul(T).add(v.mul(p))).add(d.mul(b.mul(T).add(x.mul(p))))).add(c.mul(N.mul(f.mul(T).add(y.mul(p))).add(d.mul(g.mul(T).add(m.mul(p))))))}).setLayout({name:"mx_trilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"v4",type:"float"},{name:"v5",type:"float"},{name:"v6",type:"float"},{name:"v7",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),Vi(([t,e,s,i,r,n,a,o,h,l,u])=>{const c=Oi(u).toVar(),d=Oi(l).toVar(),p=Oi(h).toVar(),m=Wi(o).toVar(),g=Wi(a).toVar(),y=Wi(n).toVar(),f=Wi(r).toVar(),x=Wi(i).toVar(),b=Wi(s).toVar(),v=Wi(e).toVar(),w=Wi(t).toVar(),T=Oi($r(1,p)).toVar(),N=Oi($r(1,d)).toVar();return Oi($r(1,c)).toVar().mul(N.mul(w.mul(T).add(v.mul(p))).add(d.mul(b.mul(T).add(x.mul(p))))).add(c.mul(N.mul(f.mul(T).add(y.mul(p))).add(d.mul(g.mul(T).add(m.mul(p))))))}).setLayout({name:"mx_trilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"v4",type:"vec3"},{name:"v5",type:"vec3"},{name:"v6",type:"vec3"},{name:"v7",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]})]),xy=Vi(([t,e,s])=>{const i=Oi(s).toVar(),r=Oi(e).toVar(),n=Bi(t).toVar(),a=Bi(n.bitAnd(Bi(7))).toVar(),o=Oi(dy(a.lessThan(Bi(4)),r,i)).toVar(),h=Oi(Yr(2,dy(a.lessThan(Bi(4)),i,r))).toVar();return py(o,Fi(a.bitAnd(Bi(1)))).add(py(h,Fi(a.bitAnd(Bi(2)))))}).setLayout({name:"mx_gradient_float_0",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"}]}),by=Vi(([t,e,s,i])=>{const r=Oi(i).toVar(),n=Oi(s).toVar(),a=Oi(e).toVar(),o=Bi(t).toVar(),h=Bi(o.bitAnd(Bi(15))).toVar(),l=Oi(dy(h.lessThan(Bi(8)),a,n)).toVar(),u=Oi(dy(h.lessThan(Bi(4)),n,dy(h.equal(Bi(12)).or(h.equal(Bi(14))),a,r))).toVar();return py(l,Fi(h.bitAnd(Bi(1)))).add(py(u,Fi(h.bitAnd(Bi(2)))))}).setLayout({name:"mx_gradient_float_1",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),vy=ap([xy,by]),wy=Vi(([t,e,s])=>{const i=Oi(s).toVar(),r=Oi(e).toVar(),n=qi(t).toVar();return Wi(vy(n.x,r,i),vy(n.y,r,i),vy(n.z,r,i))}).setLayout({name:"mx_gradient_vec3_0",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"}]}),Ty=Vi(([t,e,s,i])=>{const r=Oi(i).toVar(),n=Oi(s).toVar(),a=Oi(e).toVar(),o=qi(t).toVar();return Wi(vy(o.x,a,n,r),vy(o.y,a,n,r),vy(o.z,a,n,r))}).setLayout({name:"mx_gradient_vec3_1",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),Ny=ap([wy,Ty]),My=Vi(([t])=>{const e=Oi(t).toVar();return Yr(.6616,e)}).setLayout({name:"mx_gradient_scale2d_0",type:"float",inputs:[{name:"v",type:"float"}]}),_y=Vi(([t])=>{const e=Oi(t).toVar();return Yr(.982,e)}).setLayout({name:"mx_gradient_scale3d_0",type:"float",inputs:[{name:"v",type:"float"}]}),Sy=ap([My,Vi(([t])=>{const e=Wi(t).toVar();return Yr(.6616,e)}).setLayout({name:"mx_gradient_scale2d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]})]),Ay=ap([_y,Vi(([t])=>{const e=Wi(t).toVar();return Yr(.982,e)}).setLayout({name:"mx_gradient_scale3d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]})]),Vy=Vi(([t,e])=>{const s=Li(e).toVar(),i=Bi(t).toVar();return i.shiftLeft(s).bitOr(i.shiftRight(Li(32).sub(s)))}).setLayout({name:"mx_rotl32",type:"uint",inputs:[{name:"x",type:"uint"},{name:"k",type:"int"}]}),zy=Vi(([t,e,s])=>{t.subAssign(s),t.bitXorAssign(Vy(s,Li(4))),s.addAssign(e),e.subAssign(t),e.bitXorAssign(Vy(t,Li(6))),t.addAssign(s),s.subAssign(e),s.bitXorAssign(Vy(e,Li(8))),e.addAssign(t),t.subAssign(s),t.bitXorAssign(Vy(s,Li(16))),s.addAssign(e),e.subAssign(t),e.bitXorAssign(Vy(t,Li(19))),t.addAssign(s),s.subAssign(e),s.bitXorAssign(Vy(e,Li(4))),e.addAssign(t)}),Cy=Vi(([t,e,s])=>{const i=Bi(s).toVar(),r=Bi(e).toVar(),n=Bi(t).toVar();return i.bitXorAssign(r),i.subAssign(Vy(r,Li(14))),n.bitXorAssign(i),n.subAssign(Vy(i,Li(11))),r.bitXorAssign(n),r.subAssign(Vy(n,Li(25))),i.bitXorAssign(r),i.subAssign(Vy(r,Li(16))),n.bitXorAssign(i),n.subAssign(Vy(i,Li(4))),r.bitXorAssign(n),r.subAssign(Vy(n,Li(14))),i.bitXorAssign(r),i.subAssign(Vy(r,Li(24))),i}).setLayout({name:"mx_bjfinal",type:"uint",inputs:[{name:"a",type:"uint"},{name:"b",type:"uint"},{name:"c",type:"uint"}]}),Ry=Vi(([t])=>{const e=Bi(t).toVar();return Oi(e).div(Oi(Bi(Li(4294967295))))}).setLayout({name:"mx_bits_to_01",type:"float",inputs:[{name:"bits",type:"uint"}]}),Ey=Vi(([t])=>{const e=Oi(t).toVar();return e.mul(e).mul(e).mul(e.mul(e.mul(6).sub(15)).add(10))}).setLayout({name:"mx_fade",type:"float",inputs:[{name:"t",type:"float"}]}),Iy=ap([Vi(([t])=>{const e=Li(t).toVar(),s=Bi(Bi(1)).toVar(),i=Bi(Bi(Li(3735928559)).add(s.shiftLeft(Bi(2))).add(Bi(13))).toVar();return Cy(i.add(Bi(e)),i,i)}).setLayout({name:"mx_hash_int_0",type:"uint",inputs:[{name:"x",type:"int"}]}),Vi(([t,e])=>{const s=Li(e).toVar(),i=Li(t).toVar(),r=Bi(Bi(2)).toVar(),n=Bi().toVar(),a=Bi().toVar(),o=Bi().toVar();return n.assign(a.assign(o.assign(Bi(Li(3735928559)).add(r.shiftLeft(Bi(2))).add(Bi(13))))),n.addAssign(Bi(i)),a.addAssign(Bi(s)),Cy(n,a,o)}).setLayout({name:"mx_hash_int_1",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Li(e).toVar(),n=Li(t).toVar(),a=Bi(Bi(3)).toVar(),o=Bi().toVar(),h=Bi().toVar(),l=Bi().toVar();return o.assign(h.assign(l.assign(Bi(Li(3735928559)).add(a.shiftLeft(Bi(2))).add(Bi(13))))),o.addAssign(Bi(n)),h.addAssign(Bi(r)),l.addAssign(Bi(i)),Cy(o,h,l)}).setLayout({name:"mx_hash_int_2",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),Vi(([t,e,s,i])=>{const r=Li(i).toVar(),n=Li(s).toVar(),a=Li(e).toVar(),o=Li(t).toVar(),h=Bi(Bi(4)).toVar(),l=Bi().toVar(),u=Bi().toVar(),c=Bi().toVar();return l.assign(u.assign(c.assign(Bi(Li(3735928559)).add(h.shiftLeft(Bi(2))).add(Bi(13))))),l.addAssign(Bi(o)),u.addAssign(Bi(a)),c.addAssign(Bi(n)),zy(l,u,c),l.addAssign(Bi(r)),Cy(l,u,c)}).setLayout({name:"mx_hash_int_3",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"}]}),Vi(([t,e,s,i,r])=>{const n=Li(r).toVar(),a=Li(i).toVar(),o=Li(s).toVar(),h=Li(e).toVar(),l=Li(t).toVar(),u=Bi(Bi(5)).toVar(),c=Bi().toVar(),d=Bi().toVar(),p=Bi().toVar();return c.assign(d.assign(p.assign(Bi(Li(3735928559)).add(u.shiftLeft(Bi(2))).add(Bi(13))))),c.addAssign(Bi(l)),d.addAssign(Bi(h)),p.addAssign(Bi(o)),zy(c,d,p),c.addAssign(Bi(a)),d.addAssign(Bi(n)),Cy(c,d,p)}).setLayout({name:"mx_hash_int_4",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"},{name:"yy",type:"int"}]})]),Oy=ap([Vi(([t,e])=>{const s=Li(e).toVar(),i=Li(t).toVar(),r=Bi(Iy(i,s)).toVar(),n=qi().toVar();return n.x.assign(r.bitAnd(Li(255))),n.y.assign(r.shiftRight(Li(8)).bitAnd(Li(255))),n.z.assign(r.shiftRight(Li(16)).bitAnd(Li(255))),n}).setLayout({name:"mx_hash_vec3_0",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Li(e).toVar(),n=Li(t).toVar(),a=Bi(Iy(n,r,i)).toVar(),o=qi().toVar();return o.x.assign(a.bitAnd(Li(255))),o.y.assign(a.shiftRight(Li(8)).bitAnd(Li(255))),o.z.assign(a.shiftRight(Li(16)).bitAnd(Li(255))),o}).setLayout({name:"mx_hash_vec3_1",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]})]),Ly=ap([Vi(([t])=>{const e=Pi(t).toVar(),s=Li().toVar(),i=Li().toVar(),r=Oi(gy(e.x,s)).toVar(),n=Oi(gy(e.y,i)).toVar(),a=Oi(Ey(r)).toVar(),o=Oi(Ey(n)).toVar(),h=Oi(yy(vy(Iy(s,i),r,n),vy(Iy(s.add(Li(1)),i),r.sub(1),n),vy(Iy(s,i.add(Li(1))),r,n.sub(1)),vy(Iy(s.add(Li(1)),i.add(Li(1))),r.sub(1),n.sub(1)),a,o)).toVar();return Sy(h)}).setLayout({name:"mx_perlin_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"}]}),Vi(([t])=>{const e=Wi(t).toVar(),s=Li().toVar(),i=Li().toVar(),r=Li().toVar(),n=Oi(gy(e.x,s)).toVar(),a=Oi(gy(e.y,i)).toVar(),o=Oi(gy(e.z,r)).toVar(),h=Oi(Ey(n)).toVar(),l=Oi(Ey(a)).toVar(),u=Oi(Ey(o)).toVar(),c=Oi(fy(vy(Iy(s,i,r),n,a,o),vy(Iy(s.add(Li(1)),i,r),n.sub(1),a,o),vy(Iy(s,i.add(Li(1)),r),n,a.sub(1),o),vy(Iy(s.add(Li(1)),i.add(Li(1)),r),n.sub(1),a.sub(1),o),vy(Iy(s,i,r.add(Li(1))),n,a,o.sub(1)),vy(Iy(s.add(Li(1)),i,r.add(Li(1))),n.sub(1),a,o.sub(1)),vy(Iy(s,i.add(Li(1)),r.add(Li(1))),n,a.sub(1),o.sub(1)),vy(Iy(s.add(Li(1)),i.add(Li(1)),r.add(Li(1))),n.sub(1),a.sub(1),o.sub(1)),h,l,u)).toVar();return Ay(c)}).setLayout({name:"mx_perlin_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"}]})]),By=ap([Vi(([t])=>{const e=Pi(t).toVar(),s=Li().toVar(),i=Li().toVar(),r=Oi(gy(e.x,s)).toVar(),n=Oi(gy(e.y,i)).toVar(),a=Oi(Ey(r)).toVar(),o=Oi(Ey(n)).toVar(),h=Wi(yy(Ny(Oy(s,i),r,n),Ny(Oy(s.add(Li(1)),i),r.sub(1),n),Ny(Oy(s,i.add(Li(1))),r,n.sub(1)),Ny(Oy(s.add(Li(1)),i.add(Li(1))),r.sub(1),n.sub(1)),a,o)).toVar();return Sy(h)}).setLayout({name:"mx_perlin_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),Vi(([t])=>{const e=Wi(t).toVar(),s=Li().toVar(),i=Li().toVar(),r=Li().toVar(),n=Oi(gy(e.x,s)).toVar(),a=Oi(gy(e.y,i)).toVar(),o=Oi(gy(e.z,r)).toVar(),h=Oi(Ey(n)).toVar(),l=Oi(Ey(a)).toVar(),u=Oi(Ey(o)).toVar(),c=Wi(fy(Ny(Oy(s,i,r),n,a,o),Ny(Oy(s.add(Li(1)),i,r),n.sub(1),a,o),Ny(Oy(s,i.add(Li(1)),r),n,a.sub(1),o),Ny(Oy(s.add(Li(1)),i.add(Li(1)),r),n.sub(1),a.sub(1),o),Ny(Oy(s,i,r.add(Li(1))),n,a,o.sub(1)),Ny(Oy(s.add(Li(1)),i,r.add(Li(1))),n.sub(1),a,o.sub(1)),Ny(Oy(s,i.add(Li(1)),r.add(Li(1))),n,a.sub(1),o.sub(1)),Ny(Oy(s.add(Li(1)),i.add(Li(1)),r.add(Li(1))),n.sub(1),a.sub(1),o.sub(1)),h,l,u)).toVar();return Ay(c)}).setLayout({name:"mx_perlin_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"}]})]),Fy=ap([Vi(([t])=>{const e=Oi(t).toVar(),s=Li(my(e)).toVar();return Ry(Iy(s))}).setLayout({name:"mx_cell_noise_float_0",type:"float",inputs:[{name:"p",type:"float"}]}),Vi(([t])=>{const e=Pi(t).toVar(),s=Li(my(e.x)).toVar(),i=Li(my(e.y)).toVar();return Ry(Iy(s,i))}).setLayout({name:"mx_cell_noise_float_1",type:"float",inputs:[{name:"p",type:"vec2"}]}),Vi(([t])=>{const e=Wi(t).toVar(),s=Li(my(e.x)).toVar(),i=Li(my(e.y)).toVar(),r=Li(my(e.z)).toVar();return Ry(Iy(s,i,r))}).setLayout({name:"mx_cell_noise_float_2",type:"float",inputs:[{name:"p",type:"vec3"}]}),Vi(([t])=>{const e=Gi(t).toVar(),s=Li(my(e.x)).toVar(),i=Li(my(e.y)).toVar(),r=Li(my(e.z)).toVar(),n=Li(my(e.w)).toVar();return Ry(Iy(s,i,r,n))}).setLayout({name:"mx_cell_noise_float_3",type:"float",inputs:[{name:"p",type:"vec4"}]})]),Py=ap([Vi(([t])=>{const e=Oi(t).toVar(),s=Li(my(e)).toVar();return Wi(Ry(Iy(s,Li(0))),Ry(Iy(s,Li(1))),Ry(Iy(s,Li(2))))}).setLayout({name:"mx_cell_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"float"}]}),Vi(([t])=>{const e=Pi(t).toVar(),s=Li(my(e.x)).toVar(),i=Li(my(e.y)).toVar();return Wi(Ry(Iy(s,i,Li(0))),Ry(Iy(s,i,Li(1))),Ry(Iy(s,i,Li(2))))}).setLayout({name:"mx_cell_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),Vi(([t])=>{const e=Wi(t).toVar(),s=Li(my(e.x)).toVar(),i=Li(my(e.y)).toVar(),r=Li(my(e.z)).toVar();return Wi(Ry(Iy(s,i,r,Li(0))),Ry(Iy(s,i,r,Li(1))),Ry(Iy(s,i,r,Li(2))))}).setLayout({name:"mx_cell_noise_vec3_2",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),Vi(([t])=>{const e=Gi(t).toVar(),s=Li(my(e.x)).toVar(),i=Li(my(e.y)).toVar(),r=Li(my(e.z)).toVar(),n=Li(my(e.w)).toVar();return Wi(Ry(Iy(s,i,r,n,Li(0))),Ry(Iy(s,i,r,n,Li(1))),Ry(Iy(s,i,r,n,Li(2))))}).setLayout({name:"mx_cell_noise_vec3_3",type:"vec3",inputs:[{name:"p",type:"vec4"}]})]),Dy=Vi(([t,e,s,i])=>{const r=Oi(i).toVar(),n=Oi(s).toVar(),a=Li(e).toVar(),o=Wi(t).toVar(),h=Oi(0).toVar(),l=Oi(1).toVar();return Su(a,()=>{h.addAssign(l.mul(Ly(o))),l.mulAssign(r),o.mulAssign(n)}),h}).setLayout({name:"mx_fractal_noise_float",type:"float",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),ky=Vi(([t,e,s,i])=>{const r=Oi(i).toVar(),n=Oi(s).toVar(),a=Li(e).toVar(),o=Wi(t).toVar(),h=Wi(0).toVar(),l=Oi(1).toVar();return Su(a,()=>{h.addAssign(l.mul(By(o))),l.mulAssign(r),o.mulAssign(n)}),h}).setLayout({name:"mx_fractal_noise_vec3",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),Uy=Vi(([t,e,s,i])=>{const r=Oi(i).toVar(),n=Oi(s).toVar(),a=Li(e).toVar(),o=Wi(t).toVar();return Pi(Dy(o,a,n,r),Dy(o.add(Wi(Li(19),Li(193),Li(17))),a,n,r))}).setLayout({name:"mx_fractal_noise_vec2",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),Wy=Vi(([t,e,s,i])=>{const r=Oi(i).toVar(),n=Oi(s).toVar(),a=Li(e).toVar(),o=Wi(t).toVar(),h=Wi(ky(o,a,n,r)).toVar(),l=Oi(Dy(o.add(Wi(Li(19),Li(193),Li(17))),a,n,r)).toVar();return Gi(h,l)}).setLayout({name:"mx_fractal_noise_vec4",type:"vec4",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),jy=ap([Vi(([t,e,s,i,r,n,a])=>{const o=Li(a).toVar(),h=Oi(n).toVar(),l=Li(r).toVar(),u=Li(i).toVar(),c=Li(s).toVar(),d=Li(e).toVar(),p=Pi(t).toVar(),m=Wi(Py(Pi(d.add(u),c.add(l)))).toVar(),g=Pi(m.x,m.y).toVar();g.subAssign(.5),g.mulAssign(h),g.addAssign(.5);const y=Pi(Pi(Oi(d),Oi(c)).add(g)).toVar(),f=Pi(y.sub(p)).toVar();return Ri(o.equal(Li(2)),()=>Un(f.x).add(Un(f.y))),Ri(o.equal(Li(3)),()=>sa(Un(f.x),Un(f.y))),ha(f,f)}).setLayout({name:"mx_worley_distance_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),Vi(([t,e,s,i,r,n,a,o,h])=>{const l=Li(h).toVar(),u=Oi(o).toVar(),c=Li(a).toVar(),d=Li(n).toVar(),p=Li(r).toVar(),m=Li(i).toVar(),g=Li(s).toVar(),y=Li(e).toVar(),f=Wi(t).toVar(),x=Wi(Py(Wi(y.add(p),g.add(d),m.add(c)))).toVar();x.subAssign(.5),x.mulAssign(u),x.addAssign(.5);const b=Wi(Wi(Oi(y),Oi(g),Oi(m)).add(x)).toVar(),v=Wi(b.sub(f)).toVar();return Ri(l.equal(Li(2)),()=>Un(v.x).add(Un(v.y)).add(Un(v.z))),Ri(l.equal(Li(3)),()=>sa(sa(Un(v.x),Un(v.y)),Un(v.z))),ha(v,v)}).setLayout({name:"mx_worley_distance_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"zoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]})]),qy=Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Oi(e).toVar(),n=Pi(t).toVar(),a=Li().toVar(),o=Li().toVar(),h=Pi(gy(n.x,a),gy(n.y,o)).toVar(),l=Oi(1e6).toVar();return Su({start:-1,end:Li(1),name:"x",condition:"<="},({x:t})=>{Su({start:-1,end:Li(1),name:"y",condition:"<="},({y:e})=>{const s=Oi(jy(h,t,e,a,o,r,i)).toVar();l.assign(ea(l,s))})}),Ri(i.equal(Li(0)),()=>{l.assign(zn(l))}),l}).setLayout({name:"mx_worley_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),Hy=Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Oi(e).toVar(),n=Pi(t).toVar(),a=Li().toVar(),o=Li().toVar(),h=Pi(gy(n.x,a),gy(n.y,o)).toVar(),l=Pi(1e6,1e6).toVar();return Su({start:-1,end:Li(1),name:"x",condition:"<="},({x:t})=>{Su({start:-1,end:Li(1),name:"y",condition:"<="},({y:e})=>{const s=Oi(jy(h,t,e,a,o,r,i)).toVar();Ri(s.lessThan(l.x),()=>{l.y.assign(l.x),l.x.assign(s)}).ElseIf(s.lessThan(l.y),()=>{l.y.assign(s)})})}),Ri(i.equal(Li(0)),()=>{l.assign(zn(l))}),l}).setLayout({name:"mx_worley_noise_vec2_0",type:"vec2",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),Gy=Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Oi(e).toVar(),n=Pi(t).toVar(),a=Li().toVar(),o=Li().toVar(),h=Pi(gy(n.x,a),gy(n.y,o)).toVar(),l=Wi(1e6,1e6,1e6).toVar();return Su({start:-1,end:Li(1),name:"x",condition:"<="},({x:t})=>{Su({start:-1,end:Li(1),name:"y",condition:"<="},({y:e})=>{const s=Oi(jy(h,t,e,a,o,r,i)).toVar();Ri(s.lessThan(l.x),()=>{l.z.assign(l.y),l.y.assign(l.x),l.x.assign(s)}).ElseIf(s.lessThan(l.y),()=>{l.z.assign(l.y),l.y.assign(s)}).ElseIf(s.lessThan(l.z),()=>{l.z.assign(s)})})}),Ri(i.equal(Li(0)),()=>{l.assign(zn(l))}),l}).setLayout({name:"mx_worley_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),Xy=ap([qy,Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Oi(e).toVar(),n=Wi(t).toVar(),a=Li().toVar(),o=Li().toVar(),h=Li().toVar(),l=Wi(gy(n.x,a),gy(n.y,o),gy(n.z,h)).toVar(),u=Oi(1e6).toVar();return Su({start:-1,end:Li(1),name:"x",condition:"<="},({x:t})=>{Su({start:-1,end:Li(1),name:"y",condition:"<="},({y:e})=>{Su({start:-1,end:Li(1),name:"z",condition:"<="},({z:s})=>{const n=Oi(jy(l,t,e,s,a,o,h,r,i)).toVar();u.assign(ea(u,n))})})}),Ri(i.equal(Li(0)),()=>{u.assign(zn(u))}),u}).setLayout({name:"mx_worley_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]})]),$y=ap([Hy,Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Oi(e).toVar(),n=Wi(t).toVar(),a=Li().toVar(),o=Li().toVar(),h=Li().toVar(),l=Wi(gy(n.x,a),gy(n.y,o),gy(n.z,h)).toVar(),u=Pi(1e6,1e6).toVar();return Su({start:-1,end:Li(1),name:"x",condition:"<="},({x:t})=>{Su({start:-1,end:Li(1),name:"y",condition:"<="},({y:e})=>{Su({start:-1,end:Li(1),name:"z",condition:"<="},({z:s})=>{const n=Oi(jy(l,t,e,s,a,o,h,r,i)).toVar();Ri(n.lessThan(u.x),()=>{u.y.assign(u.x),u.x.assign(n)}).ElseIf(n.lessThan(u.y),()=>{u.y.assign(n)})})})}),Ri(i.equal(Li(0)),()=>{u.assign(zn(u))}),u}).setLayout({name:"mx_worley_noise_vec2_1",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]})]),Yy=ap([Gy,Vi(([t,e,s])=>{const i=Li(s).toVar(),r=Oi(e).toVar(),n=Wi(t).toVar(),a=Li().toVar(),o=Li().toVar(),h=Li().toVar(),l=Wi(gy(n.x,a),gy(n.y,o),gy(n.z,h)).toVar(),u=Wi(1e6,1e6,1e6).toVar();return Su({start:-1,end:Li(1),name:"x",condition:"<="},({x:t})=>{Su({start:-1,end:Li(1),name:"y",condition:"<="},({y:e})=>{Su({start:-1,end:Li(1),name:"z",condition:"<="},({z:s})=>{const n=Oi(jy(l,t,e,s,a,o,h,r,i)).toVar();Ri(n.lessThan(u.x),()=>{u.z.assign(u.y),u.y.assign(u.x),u.x.assign(n)}).ElseIf(n.lessThan(u.y),()=>{u.z.assign(u.y),u.y.assign(n)}).ElseIf(n.lessThan(u.z),()=>{u.z.assign(n)})})})}),Ri(i.equal(Li(0)),()=>{u.assign(zn(u))}),u}).setLayout({name:"mx_worley_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]})]),Zy=Vi(([t])=>{const e=t.y,s=t.z,i=Wi().toVar();return Ri(e.lessThan(1e-4),()=>{i.assign(Wi(s,s,s))}).Else(()=>{let r=t.x;r=r.sub(Rn(r)).mul(6).toVar();const n=Li(Zn(r)),a=r.sub(Oi(n)),o=s.mul(e.oneMinus()),h=s.mul(e.mul(a).oneMinus()),l=s.mul(e.mul(a.oneMinus()).oneMinus());Ri(n.equal(Li(0)),()=>{i.assign(Wi(s,l,o))}).ElseIf(n.equal(Li(1)),()=>{i.assign(Wi(h,s,o))}).ElseIf(n.equal(Li(2)),()=>{i.assign(Wi(o,s,l))}).ElseIf(n.equal(Li(3)),()=>{i.assign(Wi(o,h,s))}).ElseIf(n.equal(Li(4)),()=>{i.assign(Wi(l,o,s))}).Else(()=>{i.assign(Wi(s,o,h))})}),i}).setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]}),Jy=Vi(([t])=>{const e=Wi(t).toVar(),s=Oi(e.x).toVar(),i=Oi(e.y).toVar(),r=Oi(e.z).toVar(),n=Oi(ea(s,ea(i,r))).toVar(),a=Oi(sa(s,sa(i,r))).toVar(),o=Oi(a.sub(n)).toVar(),h=Oi().toVar(),l=Oi().toVar(),u=Oi().toVar();return u.assign(a),Ri(a.greaterThan(0),()=>{l.assign(o.div(a))}).Else(()=>{l.assign(0)}),Ri(l.lessThanEqual(0),()=>{h.assign(0)}).Else(()=>{Ri(s.greaterThanEqual(a),()=>{h.assign(i.sub(r).div(o))}).ElseIf(i.greaterThanEqual(a),()=>{h.assign(Xr(2,r.sub(s).div(o)))}).Else(()=>{h.assign(Xr(4,s.sub(i).div(o)))}),h.mulAssign(1/6),Ri(h.lessThan(0),()=>{h.addAssign(1)})}),Wi(h,l,u)}).setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]}),Qy=Vi(([t])=>{const e=Wi(t).toVar(),s=Hi(en(e,Wi(.04045))).toVar(),i=Wi(e.div(12.92)).toVar(),r=Wi(ua(sa(e.add(Wi(.055)),Wi(0)).div(1.055),Wi(2.4))).toVar();return fa(i,r,s)}).setLayout({name:"mx_srgb_texture_to_lin_rec709",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),Ky=(t,e)=>{t=Oi(t),e=Oi(e);const s=Pi(e.dFdx(),e.dFdy()).length().mul(.7071067811865476);return wa(t.sub(s),t.add(s),e)},tf=(t,e,s,i)=>fa(t,e,s[i].clamp()),ef=(t,e,s,i,r)=>fa(t,e,Ky(s,i[r])),sf=Vi(([t,e,s])=>{const i=In(t).toVar("nDir"),r=$r(Oi(.5).mul(e.sub(s)),bh).div(i).toVar("rbmax"),n=$r(Oi(-.5).mul(e.sub(s)),bh).div(i).toVar("rbmin"),a=Wi().toVar("rbminmax");a.x=i.x.greaterThan(Oi(0)).select(r.x,n.x),a.y=i.y.greaterThan(Oi(0)).select(r.y,n.y),a.z=i.z.greaterThan(Oi(0)).select(r.z,n.z);const o=ea(ea(a.x,a.y),a.z).toVar("correction");return bh.add(i.mul(o)).toVar("boxIntersection").sub(s)}),rf=Vi(([t,e])=>{const s=t.x,i=t.y,r=t.z;let n=e.element(0).mul(.886227);return n=n.add(e.element(1).mul(1.023328).mul(i)),n=n.add(e.element(2).mul(1.023328).mul(r)),n=n.add(e.element(3).mul(1.023328).mul(s)),n=n.add(e.element(4).mul(.858086).mul(s).mul(i)),n=n.add(e.element(5).mul(.858086).mul(i).mul(r)),n=n.add(e.element(6).mul(r.mul(r).mul(.743125).sub(.247708))),n=n.add(e.element(7).mul(.858086).mul(s).mul(r)),n=n.add(e.element(8).mul(.429043).mul(Yr(s,s).sub(Yr(i,i)))),n});var nf=Object.freeze({__proto__:null,BRDF_GGX:Ic,BRDF_Lambert:_c,BasicPointShadowFilter:sy,BasicShadowFilter:qg,Break:Au,Const:Pa,Continue:()=>wo("continue").append(),DFGApprox:Oc,D_GGX:Cc,Discard:To,EPSILON:fn,F_Schlick:Mc,Fn:Vi,INFINITY:xn,If:Ri,Loop:Su,NodeAccess:Cs,NodeShaderStage:Vs,NodeType:{BOOLEAN:"bool",INTEGER:"int",FLOAT:"float",VECTOR2:"vec2",VECTOR3:"vec3",VECTOR4:"vec4",MATRIX2:"mat2",MATRIX3:"mat3",MATRIX4:"mat4"},NodeUpdateType:zs,PCFShadowFilter:Hg,PCFSoftShadowFilter:Gg,PI:bn,PI2:vn,PointShadowFilter:iy,Return:()=>wo("return").append(),Schlick_to_F0:Lc,ScriptableNodeResources:Qm,ShaderNode:Ti,TBNViewMatrix:dl,VSMShadowFilter:Xg,V_GGX_SmithCorrelated:Vc,Var:Fa,abs:Un,acesFilmicToneMapping:Pm,acos:Dn,add:Xr,addMethodChaining:Zs,addNodeElement:function(t){console.warn("THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add",t)},agxToneMapping:Wm,all:wn,alphaT:_r,and:nn,anisotropy:Sr,anisotropyB:Vr,anisotropyT:Ar,any:Tn,append:Ei,array:sr,arrayBuffer:t=>Ni(new Gs(t,"ArrayBuffer")),asin:Pn,assign:jr,atan:kn,atan2:Sa,atomicAdd:(t,e,s=null)=>wg(bg.ATOMIC_ADD,t,e,s),atomicAnd:(t,e,s=null)=>wg(bg.ATOMIC_AND,t,e,s),atomicFunc:wg,atomicLoad:(t,e=null)=>wg(bg.ATOMIC_LOAD,t,null,e),atomicMax:(t,e,s=null)=>wg(bg.ATOMIC_MAX,t,e,s),atomicMin:(t,e,s=null)=>wg(bg.ATOMIC_MIN,t,e,s),atomicOr:(t,e,s=null)=>wg(bg.ATOMIC_OR,t,e,s),atomicStore:(t,e,s=null)=>wg(bg.ATOMIC_STORE,t,e,s),atomicSub:(t,e,s=null)=>wg(bg.ATOMIC_SUB,t,e,s),atomicXor:(t,e,s=null)=>wg(bg.ATOMIC_XOR,t,e,s),attenuationColor:kr,attenuationDistance:Dr,attribute:So,attributeArray:(t,e="float")=>{let s,i;!0===e.isStruct?(s=e.layout.getLength(),i=ws("float")):(s=Ts(e),i=ws(e));const r=new Hp(t,s,i);return Yp(r,e,t)},backgroundBlurriness:sm,backgroundIntensity:im,backgroundRotation:rm,batch:wu,billboarding:dp,bitAnd:ln,bitNot:un,bitOr:cn,bitXor:dn,bitangentGeometry:al,bitangentLocal:ol,bitangentView:hl,bitangentWorld:ll,bitcast:Kn,blendBurn:ym,blendColor:vm,blendDodge:fm,blendOverlay:bm,blendScreen:xm,blur:dd,bool:Fi,buffer:Bo,bufferAttribute:ao,bumpMap:wl,burn:(...t)=>(console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.'),ym(t)),bvec2:Ui,bvec3:Hi,bvec4:Yi,bypass:yo,cache:mo,call:Hr,cameraFar:Wo,cameraIndex:ko,cameraNear:Uo,cameraNormalMatrix:Xo,cameraPosition:$o,cameraProjectionMatrix:jo,cameraProjectionMatrixInverse:qo,cameraViewMatrix:Ho,cameraWorldMatrix:Go,cbrt:ga,cdl:Sm,ceil:En,checker:uy,cineonToneMapping:Bm,clamp:xa,clearcoat:xr,clearcoatRoughness:br,code:Hm,color:Ii,colorSpaceToWorking:Ja,colorToDirection:t=>Ni(t).mul(2).sub(1),compute:co,cond:Ra,context:Ia,convert:tr,convertColorSpace:(t,e,s)=>Ni(new Xa(Ni(t),e,s)),convertToTexture:(t,...e)=>t.isTextureNode?t:t.isPassNode?t.getTextureNode():kp(t,...e),cos:Bn,cross:la,cubeTexture:Gh,cubeToUV:ey,dFdx:Gn,dFdy:Xn,dashSize:Ir,defaultBuildStages:["setup","analyze","generate"],defaultShaderStages:Rs,defined:vi,degrees:Mn,deltaTime:hp,densityFog:function(t,e){return console.warn('THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.'),rg(t,ig(e))},densityFogFactor:ig,depth:uc,depthPass:(t,e,s)=>Ni(new Em(Em.DEPTH,t,e,s)),difference:oa,diffuseColor:mr,directPointLight:({color:t,lightVector:e,cutoffDistance:s,decayExponent:i})=>{const r=e.normalize(),n=e.length(),a=ly({lightDistance:n,cutoffDistance:s,decayExponent:i});return{lightDirection:r,lightColor:t.mul(a)}},directionToColor:t=>Ni(t).mul(.5).add(.5),dispersion:Ur,distance:aa,div:Zr,dodge:(...t)=>(console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.'),fm(t)),dot:ha,drawIndex:gu,dynamicBufferAttribute:oo,element:Ki,emissive:gr,equal:Qr,equals:ta,equirectUV:Nc,exp:_n,exp2:Sn,expression:wo,faceDirection:_h,faceForward:Ta,faceforward:Aa,float:Oi,floor:Rn,fog:rg,fract:On,frameGroup:ar,frameId:lp,frontFacing:Mh,fwidth:Jn,gain:(t,e)=>t.lessThan(.5)?tp(t.mul(2),e).div(2):$r(1,tp(Yr($r(1,t),2),e).div(2)),gapSize:Or,getConstNodeType:wi,getCurrentStack:Ci,getDirection:hd,getDistanceAttenuation:ly,getGeometryRoughness:Sc,getNormalFromDepth:jp,getParallaxCorrectNormal:sf,getRoughness:Ac,getScreenPosition:Wp,getShIrradianceAt:rf,getTextureIndex:Zd,getViewPosition:Up,globalId:pg,glsl:(t,e)=>Hm(t,e,"glsl"),glslFn:(t,e)=>Xm(t,e,"glsl"),grayscale:wm,greaterThan:en,greaterThanEqual:rn,hash:Kd,highpModelNormalViewMatrix:gh,highpModelViewMatrix:mh,hue:Mm,instance:fu,instanceIndex:cu,instancedArray:(t,e="float")=>{let s,i;!0===e.isStruct?(s=e.layout.getLength(),i=ws("float")):(s=Ts(e),i=ws(e));const r=new qp(t,s,i);return Yp(r,e,t)},instancedBufferAttribute:ho,instancedDynamicBufferAttribute:lo,instancedMesh:bu,int:Li,inverseSqrt:Cn,inversesqrt:Va,invocationLocalIndex:mu,invocationSubgroupIndex:pu,ior:Br,iridescence:Tr,iridescenceIOR:Nr,iridescenceThickness:Mr,ivec2:Di,ivec3:ji,ivec4:Xi,js:(t,e)=>Hm(t,e,"js"),label:Oa,length:jn,lengthSq:ya,lessThan:tn,lessThanEqual:sn,lightPosition:_g,lightProjectionUV:function(t,e=bh){const s=Mg(t).mul(e);return s.xyz.div(s.w)},lightShadowMatrix:Mg,lightTargetDirection:t=>Ho.transformDirection(_g(t).sub(Sg(t))),lightTargetPosition:Sg,lightViewPosition:function(t){const e=Ng(t);return e.viewPosition||(e.viewPosition=ur(new X).setGroup(or).onRenderUpdate(({camera:e},s)=>{s.value=s.value||new X,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(e.matrixWorldInverse)}))},lightingContext:Bu,lights:(t=[])=>Ni(new zg).setLights(t),linearDepth:cc,linearToneMapping:Om,localId:mg,log:An,log2:Vn,logarithmicDepthToViewZ:(t,e,s)=>{const i=t.mul(An(s.div(e)));return Oi(Math.E).pow(i).mul(e).negate()},loop:(...t)=>(console.warn("TSL.LoopNode: loop() has been renamed to Loop()."),Su(...t)),luminance:_m,mat2:Zi,mat3:Ji,mat4:Qi,matcapUV:kd,materialAO:au,materialAlphaTest:Ml,materialAnisotropy:jl,materialAnisotropyVector:ou,materialAttenuationColor:Jl,materialAttenuationDistance:Zl,materialClearcoat:Fl,materialClearcoatNormal:Dl,materialClearcoatRoughness:Pl,materialColor:_l,materialDispersion:ru,materialEmissive:Al,materialEnvIntensity:Dh,materialEnvRotation:kh,materialIOR:Yl,materialIridescence:ql,materialIridescenceIOR:Hl,materialIridescenceThickness:Gl,materialLightMap:nu,materialLineDashOffset:su,materialLineDashSize:Kl,materialLineGapSize:tu,materialLineScale:Ql,materialLineWidth:eu,materialMetalness:Ll,materialNormal:Bl,materialOpacity:Vl,materialPointSize:iu,materialReference:Qh,materialReflectivity:Il,materialRefractionRatio:Ph,materialRotation:kl,materialRoughness:Ol,materialSheen:Ul,materialSheenRoughness:Wl,materialShininess:Sl,materialSpecular:zl,materialSpecularColor:Rl,materialSpecularIntensity:Cl,materialSpecularStrength:El,materialThickness:$l,materialTransmission:Xl,max:sa,maxMipLevel:Ro,mediumpModelViewMatrix:ph,metalness:fr,min:ea,mix:fa,mixElement:Ma,mod:ia,modInt:Jr,modelDirection:rh,modelNormalMatrix:uh,modelPosition:ah,modelRadius:lh,modelScale:oh,modelViewMatrix:dh,modelViewPosition:hh,modelViewProjection:hu,modelWorldMatrix:nh,modelWorldMatrixInverse:ch,morphReference:Eu,mrt:Qd,mul:Yr,mx_aastep:Ky,mx_cell_noise_float:(t=Ao())=>Fy(t.convert("vec2|vec3")),mx_contrast:(t,e=1,s=.5)=>Oi(t).sub(s).mul(e).add(s),mx_fractal_noise_float:(t=Ao(),e=3,s=2,i=.5,r=1)=>Dy(t,Li(e),s,i).mul(r),mx_fractal_noise_vec2:(t=Ao(),e=3,s=2,i=.5,r=1)=>Uy(t,Li(e),s,i).mul(r),mx_fractal_noise_vec3:(t=Ao(),e=3,s=2,i=.5,r=1)=>ky(t,Li(e),s,i).mul(r),mx_fractal_noise_vec4:(t=Ao(),e=3,s=2,i=.5,r=1)=>Wy(t,Li(e),s,i).mul(r),mx_hsvtorgb:Zy,mx_noise_float:(t=Ao(),e=1,s=0)=>Ly(t.convert("vec2|vec3")).mul(e).add(s),mx_noise_vec3:(t=Ao(),e=1,s=0)=>By(t.convert("vec2|vec3")).mul(e).add(s),mx_noise_vec4:(t=Ao(),e=1,s=0)=>{t=t.convert("vec2|vec3");return Gi(By(t),Ly(t.add(Pi(19,73)))).mul(e).add(s)},mx_ramplr:(t,e,s=Ao())=>tf(t,e,s,"x"),mx_ramptb:(t,e,s=Ao())=>tf(t,e,s,"y"),mx_rgbtohsv:Jy,mx_safepower:(t,e=1)=>(t=Oi(t)).abs().pow(e).mul(t.sign()),mx_splitlr:(t,e,s,i=Ao())=>ef(t,e,s,i,"x"),mx_splittb:(t,e,s,i=Ao())=>ef(t,e,s,i,"y"),mx_srgb_texture_to_lin_rec709:Qy,mx_transform_uv:(t=1,e=0,s=Ao())=>s.mul(t).add(e),mx_worley_noise_float:(t=Ao(),e=1)=>Xy(t.convert("vec2|vec3"),e,Li(1)),mx_worley_noise_vec2:(t=Ao(),e=1)=>$y(t.convert("vec2|vec3"),e,Li(1)),mx_worley_noise_vec3:(t=Ao(),e=1)=>Yy(t.convert("vec2|vec3"),e,Li(1)),negate:qn,neutralToneMapping:jm,nodeArray:_i,nodeImmutable:Ai,nodeObject:Ni,nodeObjects:Mi,nodeProxy:Si,normalFlat:Vh,normalGeometry:Sh,normalLocal:Ah,normalMap:fl,normalView:zh,normalWorld:Ch,normalize:In,not:on,notEqual:Kr,numWorkgroups:cg,objectDirection:Jo,objectGroup:hr,objectPosition:Ko,objectRadius:sh,objectScale:th,objectViewPosition:eh,objectWorldMatrix:Qo,oneMinus:Hn,or:an,orthographicDepthToViewZ:(t,e,s)=>e.sub(s).mul(t).sub(e),oscSawtooth:(t=op)=>t.fract(),oscSine:(t=op)=>t.add(.75).mul(2*Math.PI).sin().mul(.5).add(.5),oscSquare:(t=op)=>t.fract().round(),oscTriangle:(t=op)=>t.add(.5).fract().mul(2).sub(1).abs(),output:Er,outputStruct:Yd,overlay:(...t)=>(console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.'),bm(t)),overloadingFn:ap,parabola:tp,parallaxDirection:pl,parallaxUV:(t,e)=>t.sub(pl.mul(e)),parameter:(t,e)=>Ni(new jd(t,e)),pass:(t,e,s)=>Ni(new Em(Em.COLOR,t,e,s)),passTexture:(t,e)=>Ni(new Cm(t,e)),pcurve:(t,e,s)=>ua(Zr(ua(t,e),Xr(ua(t,e),ua($r(1,t),s))),1/e),perspectiveDepthToViewZ:oc,pmremTexture:Pd,pointShadow:(t,e)=>Ni(new hy(t,e)),pointUV:Qp,pointWidth:Lr,positionGeometry:yh,positionLocal:fh,positionPrevious:xh,positionView:wh,positionViewDirection:Th,positionWorld:bh,positionWorldDirection:vh,posterize:Vm,pow:ua,pow2:ca,pow3:da,pow4:pa,property:dr,radians:Nn,rand:Na,range:hg,rangeFog:function(t,e,s){return console.warn('THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.'),rg(t,sg(e,s))},rangeFogFactor:sg,reciprocal:Yn,reference:Yh,referenceBuffer:Zh,reflect:na,reflectVector:jh,reflectView:Uh,reflector:t=>Ni(new Ep(t)),refract:va,refractVector:qh,refractView:Wh,reinhardToneMapping:Lm,remainder:gn,remap:xo,remapClamp:bo,renderGroup:or,renderOutput:Mo,rendererReference:eo,rotate:Wd,rotateUV:up,roughness:yr,round:$n,rtt:kp,sRGBTransferEOTF:ja,sRGBTransferOETF:qa,sampler:t=>(!0===t.isNode?t:Io(t)).convert("sampler"),saturate:ba,saturation:Tm,screen:(...t)=>(console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.'),xm(t)),screenCoordinate:ju,screenSize:Wu,screenUV:Uu,scriptable:tg,scriptableValue:Ym,select:Ca,setCurrentStack:zi,shaderStages:Es,shadow:(t,e)=>Ni(new Kg(t,e)),shadowPositionWorld:Rg,shapeCircle:cy,sharedUniformGroup:nr,sheen:vr,sheenRoughness:wr,shiftLeft:pn,shiftRight:mn,shininess:Rr,sign:Wn,sin:Ln,sinc:(t,e)=>Ln(bn.mul(e.mul(t).sub(1))).div(bn.mul(e.mul(t).sub(1))),skinning:t=>Ni(new Nu(t)),skinningReference:Mu,smoothstep:wa,smoothstepElement:_a,specularColor:zr,specularF90:Cr,spherizeUV:cp,split:(t,e)=>Ni(new Us(Ni(t),e)),spritesheetUV:gp,sqrt:zn,stack:Hd,step:ra,storage:Yp,storageBarrier:()=>yg("storage").append(),storageObject:(t,e,s)=>(console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'),Yp(t,e,s).setPBO(!0)),storageTexture:am,string:(t="")=>Ni(new Gs(t,"string")),struct:(t,e=null)=>{const s=new Gd(t,e),i=(...e)=>{let i=null;if(e.length>0)if(e[0].isNode){i={};const s=Object.keys(t);for(let t=0;t<e.length;t++)i[s[t]]=e[t]}else i=e[0];return Ni(new Xd(s,i))};return i.layout=s,i.isStruct=!0,i},sub:$r,subgroupIndex:du,subgroupSize:gg,tan:Fn,tangentGeometry:Kh,tangentLocal:tl,tangentView:el,tangentWorld:sl,temp:Da,texture:Io,texture3D:lm,textureBarrier:()=>yg("texture").append(),textureBicubic:Gc,textureCubeUV:ld,textureLoad:Oo,textureSize:zo,textureStore:(t,e,s)=>{const i=am(t,e,s);return null!==s&&i.append(),i},thickness:Pr,time:op,timerDelta:(t=1)=>(console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.'),hp.mul(t)),timerGlobal:(t=1)=>(console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.'),op.mul(t)),timerLocal:(t=1)=>(console.warn('TSL: timerLocal() is deprecated. Use "time" instead.'),op.mul(t)),toOutputColorSpace:$a,toWorkingColorSpace:Ya,toneMapping:io,toneMappingExposure:ro,toonOutlinePass:(t,e,s=new ge(0,0,0),i=.003,r=1)=>Ni(new Im(t,e,Ni(s),Ni(i),Ni(r))),transformDirection:ma,transformNormal:Oh,transformNormalToView:Lh,transformedBentNormalView:ml,transformedBitangentView:ul,transformedBitangentWorld:cl,transformedClearcoatNormalView:Ih,transformedNormalView:Rh,transformedNormalWorld:Eh,transformedTangentView:il,transformedTangentWorld:rl,transmission:Fr,transpose:Qn,triNoise3D:ip,triplanarTexture:(...t)=>fp(...t),triplanarTextures:fp,trunc:Zn,tslFn:(...t)=>(console.warn("TSL.ShaderNode: tslFn() has been renamed to Fn()."),Vi(...t)),uint:Bi,uniform:ur,uniformArray:Do,uniformGroup:rr,uniforms:(t,e)=>(console.warn("TSL.UniformArrayNode: uniforms() has been renamed to uniformArray()."),Ni(new Po(t,e))),userData:(t,e,s)=>Ni(new um(t,e,s)),uv:Ao,uvec2:ki,uvec3:qi,uvec4:$i,varying:Ua,varyingProperty:pr,vec2:Pi,vec3:Wi,vec4:Gi,vectorComponents:Is,velocity:gm,vertexColor:t=>Ni(new Zp(t)),vertexIndex:uu,vertexStage:Wa,vibrance:Nm,viewZToLogarithmicDepth:hc,viewZToOrthographicDepth:nc,viewZToPerspectiveDepth:ac,viewport:qu,viewportBottomLeft:Zu,viewportCoordinate:Gu,viewportDepthTexture:ic,viewportLinearDepth:dc,viewportMipTexture:tc,viewportResolution:$u,viewportSafeUV:pp,viewportSharedTexture:wc,viewportSize:Hu,viewportTexture:Ku,viewportTopLeft:Yu,viewportUV:Xu,wgsl:(t,e)=>Hm(t,e,"wgsl"),wgslFn:(t,e)=>Xm(t,e,"wgsl"),workgroupArray:(t,e)=>Ni(new xg("Workgroup",t,e)),workgroupBarrier:()=>yg("workgroup").append(),workgroupId:dg,workingToColorSpace:Za,xor:hn});const af="undefined"!=typeof self?self.GPUShaderStage:{VERTEX:1,FRAGMENT:2,COMPUTE:4};af&&af.VERTEX,af&&af.FRAGMENT,af&&af.COMPUTE;const of={tsl_xor:new qm("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new qm("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new qm("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new qm("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new qm("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new qm("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new qm("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new qm("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new qm("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping_float:new qm("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),mirrorWrapping_float:new qm("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),clampWrapping_float:new qm("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),biquadraticTexture:new qm("\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n")};"undefined"!=typeof navigator&&/Windows/g.test(navigator.userAgent)&&(of.pow_float=new qm("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"),of.pow_vec2=new qm("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",[of.pow_float]),of.pow_vec3=new qm("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",[of.pow_float]),of.pow_vec4=new qm("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",[of.pow_float])),
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
nf.BRDF_GGX,nf.BRDF_Lambert,nf.BasicShadowFilter,nf.Break,nf.Continue,nf.DFGApprox,nf.D_GGX,nf.Discard,nf.EPSILON,nf.F_Schlick;const hf=nf.Fn;nf.INFINITY,nf.If;const lf=nf.Loop;nf.NodeShaderStage,nf.NodeType,nf.NodeUpdateType,nf.NodeAccess,nf.PCFShadowFilter,nf.PCFSoftShadowFilter,nf.PI,nf.PI2,nf.Return,nf.Schlick_to_F0,nf.ScriptableNodeResources;const uf=nf.ShaderNode;nf.TBNViewMatrix,nf.VSMShadowFilter,nf.V_GGX_SmithCorrelated;const cf=nf.abs;nf.acesFilmicToneMapping,nf.acos;const df=nf.add;nf.addNodeElement,nf.agxToneMapping,nf.all,nf.alphaT,nf.and,nf.anisotropy,nf.anisotropyB,nf.anisotropyT,nf.any,nf.append,nf.array,nf.arrayBuffer,nf.asin,nf.assign,nf.atan,nf.atan2,nf.atomicAdd,nf.atomicAnd,nf.atomicFunc,nf.atomicMax,nf.atomicMin,nf.atomicOr,nf.atomicStore,nf.atomicSub,nf.atomicXor,nf.atomicLoad,nf.attenuationColor,nf.attenuationDistance,nf.attribute,nf.attributeArray,nf.backgroundBlurriness,nf.backgroundIntensity,nf.backgroundRotation,nf.batch,nf.billboarding,nf.bitAnd,nf.bitNot,nf.bitOr,nf.bitXor,nf.bitangentGeometry,nf.bitangentLocal,nf.bitangentView,nf.bitangentWorld,nf.bitcast,nf.blendBurn,nf.blendColor,nf.blendDodge,nf.blendOverlay;const pf=nf.blendScreen;nf.blur,nf.bool,nf.buffer,nf.bufferAttribute,nf.bumpMap,nf.burn,nf.bvec2,nf.bvec3,nf.bvec4,nf.bypass,nf.cache,nf.call,nf.cameraFar,nf.cameraIndex,nf.cameraNear,nf.cameraNormalMatrix,nf.cameraPosition,nf.cameraProjectionMatrix,nf.cameraProjectionMatrixInverse,nf.cameraViewMatrix,nf.cameraWorldMatrix,nf.cbrt,nf.cdl,nf.ceil,nf.checker,nf.cineonToneMapping,nf.clamp,nf.clearcoat,nf.clearcoatRoughness,nf.code,nf.color,nf.colorSpaceToWorking,nf.colorToDirection,nf.compute,nf.cond,nf.Const,nf.context,nf.convert,nf.convertColorSpace,nf.convertToTexture,nf.cos,nf.cross,nf.cubeTexture,nf.dFdx,nf.dFdy,nf.dashSize,nf.defaultBuildStages,nf.defaultShaderStages,nf.defined,nf.degrees,nf.deltaTime,nf.densityFog,nf.densityFogFactor,nf.depth,nf.depthPass,nf.difference,nf.diffuseColor,nf.directPointLight,nf.directionToColor,nf.dispersion,nf.distance,nf.div,nf.dodge,nf.dot,nf.drawIndex,nf.dynamicBufferAttribute,nf.element,nf.emissive,nf.equal,nf.equals,nf.equirectUV,nf.exp,nf.exp2,nf.expression,nf.faceDirection,nf.faceForward,nf.faceforward;const mf=nf.float;nf.floor,nf.fog,nf.fract,nf.frameGroup,nf.frameId,nf.frontFacing,nf.fwidth,nf.gain,nf.gapSize,nf.getConstNodeType,nf.getCurrentStack,nf.getDirection,nf.getDistanceAttenuation,nf.getGeometryRoughness,nf.getNormalFromDepth,nf.getParallaxCorrectNormal,nf.getRoughness,nf.getScreenPosition,nf.getShIrradianceAt,nf.getTextureIndex,nf.getViewPosition,nf.glsl,nf.glslFn,nf.grayscale,nf.greaterThan,nf.greaterThanEqual,nf.hash,nf.highpModelNormalViewMatrix,nf.highpModelViewMatrix,nf.hue,nf.instance,nf.instanceIndex,nf.instancedArray,nf.instancedBufferAttribute,nf.instancedDynamicBufferAttribute,nf.instancedMesh;const gf=nf.int;nf.inverseSqrt,nf.inversesqrt,nf.invocationLocalIndex,nf.invocationSubgroupIndex,nf.ior,nf.iridescence,nf.iridescenceIOR,nf.iridescenceThickness,nf.ivec2,nf.ivec3,nf.ivec4,nf.js,nf.label,nf.length,nf.lengthSq,nf.lessThan,nf.lessThanEqual,nf.lightPosition,nf.lightTargetDirection,nf.lightTargetPosition,nf.lightViewPosition,nf.lightingContext,nf.lights,nf.linearDepth,nf.linearToneMapping,nf.localId,nf.globalId,nf.log,nf.log2,nf.logarithmicDepthToViewZ,nf.loop;const yf=nf.luminance;nf.mediumpModelViewMatrix,nf.mat2,nf.mat3,nf.mat4,nf.matcapUV,nf.materialAO,nf.materialAlphaTest,nf.materialAnisotropy,nf.materialAnisotropyVector,nf.materialAttenuationColor,nf.materialAttenuationDistance,nf.materialClearcoat,nf.materialClearcoatNormal,nf.materialClearcoatRoughness,nf.materialColor,nf.materialDispersion,nf.materialEmissive,nf.materialIOR,nf.materialIridescence,nf.materialIridescenceIOR,nf.materialIridescenceThickness,nf.materialLightMap,nf.materialLineDashOffset,nf.materialLineDashSize,nf.materialLineGapSize,nf.materialLineScale,nf.materialLineWidth,nf.materialMetalness,nf.materialNormal,nf.materialOpacity,nf.materialPointSize,nf.materialReference,nf.materialReflectivity,nf.materialRefractionRatio,nf.materialRotation,nf.materialRoughness,nf.materialSheen,nf.materialSheenRoughness,nf.materialShininess,nf.materialSpecular,nf.materialSpecularColor,nf.materialSpecularIntensity,nf.materialSpecularStrength,nf.materialThickness,nf.materialTransmission;const ff=nf.max;nf.maxMipLevel,nf.metalness,nf.min;const xf=nf.mix;nf.mixElement;const bf=nf.mod;nf.modInt,nf.modelDirection,nf.modelNormalMatrix,nf.modelPosition,nf.modelRadius,nf.modelScale,nf.modelViewMatrix,nf.modelViewPosition,nf.modelViewProjection,nf.modelWorldMatrix,nf.modelWorldMatrixInverse,nf.morphReference,nf.mrt,nf.mul,nf.mx_aastep;const vf=nf.mx_cell_noise_float;nf.mx_contrast,nf.mx_fractal_noise_float,nf.mx_fractal_noise_vec2,nf.mx_fractal_noise_vec3,nf.mx_fractal_noise_vec4,nf.mx_hsvtorgb,nf.mx_noise_float,nf.mx_noise_vec3,nf.mx_noise_vec4,nf.mx_ramplr,nf.mx_ramptb,nf.mx_rgbtohsv,nf.mx_safepower,nf.mx_splitlr,nf.mx_splittb,nf.mx_srgb_texture_to_lin_rec709,nf.mx_transform_uv,nf.mx_worley_noise_float,nf.mx_worley_noise_vec2,nf.mx_worley_noise_vec3,nf.negate,nf.neutralToneMapping,nf.nodeArray,nf.nodeImmutable;const wf=nf.nodeObject;nf.nodeObjects,nf.nodeProxy,nf.normalFlat,nf.normalGeometry,nf.normalLocal,nf.normalMap,nf.normalView,nf.normalWorld,nf.normalize,nf.not,nf.notEqual,nf.numWorkgroups,nf.objectDirection,nf.objectGroup,nf.objectPosition,nf.objectRadius,nf.objectScale,nf.objectViewPosition,nf.objectWorldMatrix;const Tf=nf.oneMinus;nf.or,nf.orthographicDepthToViewZ,nf.oscSawtooth,nf.oscSine,nf.oscSquare,nf.oscTriangle,nf.output,nf.outputStruct,nf.overlay,nf.overloadingFn,nf.parabola,nf.parallaxDirection,nf.parallaxUV,nf.parameter;const Nf=nf.pass,Mf=nf.passTexture;nf.pcurve,nf.perspectiveDepthToViewZ,nf.pmremTexture,nf.pointUV,nf.pointWidth,nf.positionGeometry,nf.positionLocal,nf.positionPrevious,nf.positionView,nf.positionViewDirection,nf.positionWorld,nf.positionWorldDirection,nf.posterize,nf.pow,nf.pow2,nf.pow3,nf.pow4,nf.property,nf.radians,nf.rand,nf.range,nf.rangeFog,nf.rangeFogFactor,nf.reciprocal,nf.lightProjectionUV,nf.reference,nf.referenceBuffer,nf.reflect,nf.reflectVector,nf.reflectView,nf.reflector,nf.refract,nf.refractVector,nf.refractView,nf.reinhardToneMapping,nf.remainder,nf.remap,nf.remapClamp,nf.renderGroup,nf.renderOutput,nf.rendererReference,nf.rotate,nf.rotateUV,nf.roughness,nf.round,nf.rtt,nf.sRGBTransferEOTF,nf.sRGBTransferOETF,nf.sampler,nf.saturate,nf.saturation,nf.screen,nf.screenCoordinate,nf.screenSize,nf.screenUV,nf.scriptable,nf.scriptableValue;const _f=nf.select;nf.setCurrentStack,nf.shaderStages,nf.shadow,nf.pointShadow,nf.shadowPositionWorld,nf.sharedUniformGroup,nf.shapeCircle,nf.sheen,nf.sheenRoughness,nf.shiftLeft,nf.shiftRight,nf.shininess,nf.sign,nf.sin,nf.sinc,nf.skinning,nf.skinningReference;const Sf=nf.smoothstep;nf.smoothstepElement,nf.specularColor,nf.specularF90,nf.spherizeUV,nf.split,nf.spritesheetUV,nf.sqrt,nf.stack,nf.step,nf.storage,nf.storageBarrier,nf.storageObject,nf.storageTexture,nf.string,nf.struct;const Af=nf.sub;nf.subgroupIndex,nf.subgroupSize,nf.tan,nf.tangentGeometry,nf.tangentLocal,nf.tangentView,nf.tangentWorld,nf.temp;const Vf=nf.texture;nf.texture3D,nf.textureBarrier,nf.textureBicubic,nf.textureCubeUV,nf.textureLoad,nf.textureSize,nf.textureStore,nf.thickness,nf.threshold,nf.time,nf.timerDelta,nf.timerGlobal,nf.timerLocal,nf.toOutputColorSpace,nf.toWorkingColorSpace,nf.toneMapping,nf.toneMappingExposure,nf.toonOutlinePass,nf.transformDirection,nf.transformNormal,nf.transformNormalToView,nf.transformedBentNormalView,nf.transformedBitangentView,nf.transformedBitangentWorld,nf.transformedClearcoatNormalView,nf.transformedNormalView,nf.transformedNormalWorld,nf.transformedTangentView,nf.transformedTangentWorld,nf.transmission,nf.transpose,nf.tri,nf.tri3,nf.triNoise3D,nf.triplanarTexture,nf.triplanarTextures,nf.trunc,nf.tslFn,nf.uint;const zf=nf.uniform,Cf=nf.uniformArray;nf.uniformGroup,nf.uniforms,nf.userData;const Rf=nf.uv;nf.uvec2,nf.uvec3,nf.uvec4,nf.Var,nf.varying,nf.varyingProperty;const Ef=nf.vec2,If=nf.vec3,Of=nf.vec4;nf.vectorComponents,nf.velocity,nf.vertexColor,nf.vertexIndex,nf.vibrance,nf.viewZToLogarithmicDepth,nf.viewZToOrthographicDepth,nf.viewZToPerspectiveDepth,nf.viewport,nf.viewportBottomLeft,nf.viewportCoordinate,nf.viewportDepthTexture,nf.viewportLinearDepth,nf.viewportMipTexture,nf.viewportResolution,nf.viewportSafeUV,nf.viewportSharedTexture,nf.viewportSize,nf.viewportTexture,nf.viewportTopLeft,nf.viewportUV,nf.wgsl,nf.wgslFn,nf.workgroupArray,nf.workgroupBarrier,nf.workgroupId,nf.workingToColorSpace,nf.xor;const Lf=new Fp,Bf=new S,Ff=new S(1,0),Pf=new S(0,1);let Df;class kf extends Ps{static get type(){return"BloomNode"}constructor(t,e=1,s=0,r=0){super("vec4"),this.inputNode=t,this.strength=zf(e),this.radius=zf(s),this.threshold=zf(r),this.smoothWidth=zf(.01),this._renderTargetsHorizontal=[],this._renderTargetsVertical=[],this._nMips=5,this._renderTargetBright=new q(1,1,{depthBuffer:!1,type:i}),this._renderTargetBright.texture.name="UnrealBloomPass.bright",this._renderTargetBright.texture.generateMipmaps=!1;for(let t=0;t<this._nMips;t++){const e=new q(1,1,{depthBuffer:!1,type:i});e.texture.name="UnrealBloomPass.h"+t,e.texture.generateMipmaps=!1,this._renderTargetsHorizontal.push(e);const s=new q(1,1,{depthBuffer:!1,type:i});s.texture.name="UnrealBloomPass.v"+t,s.texture.generateMipmaps=!1,this._renderTargetsVertical.push(s)}this._compositeMaterial=null,this._highPassFilterMaterial=null,this._separableBlurMaterials=[],this._textureNodeBright=Vf(this._renderTargetBright.texture),this._textureNodeBlur0=Vf(this._renderTargetsVertical[0].texture),this._textureNodeBlur1=Vf(this._renderTargetsVertical[1].texture),this._textureNodeBlur2=Vf(this._renderTargetsVertical[2].texture),this._textureNodeBlur3=Vf(this._renderTargetsVertical[3].texture),this._textureNodeBlur4=Vf(this._renderTargetsVertical[4].texture),this._textureOutput=Mf(this,this._renderTargetsHorizontal[0].texture),this.updateBeforeType=zs.FRAME}getTextureNode(){return this._textureOutput}setSize(t,e){let s=Math.round(t/2),i=Math.round(e/2);this._renderTargetBright.setSize(s,i);for(let t=0;t<this._nMips;t++)this._renderTargetsHorizontal[t].setSize(s,i),this._renderTargetsVertical[t].setSize(s,i),this._separableBlurMaterials[t].invSize.value.set(1/s,1/i),s=Math.round(s/2),i=Math.round(i/2)}updateBefore(t){const{renderer:e}=t;Df=kg.resetRendererState(e,Df);const s=e.getDrawingBufferSize(Bf);this.setSize(s.width,s.height),e.setRenderTarget(this._renderTargetBright),Lf.material=this._highPassFilterMaterial,Lf.render(e);let i=this._renderTargetBright;for(let t=0;t<this._nMips;t++)Lf.material=this._separableBlurMaterials[t],this._separableBlurMaterials[t].colorTexture.value=i.texture,this._separableBlurMaterials[t].direction.value=Ff,e.setRenderTarget(this._renderTargetsHorizontal[t]),Lf.render(e),this._separableBlurMaterials[t].colorTexture.value=this._renderTargetsHorizontal[t].texture,this._separableBlurMaterials[t].direction.value=Pf,e.setRenderTarget(this._renderTargetsVertical[t]),Lf.render(e),i=this._renderTargetsVertical[t];e.setRenderTarget(this._renderTargetsHorizontal[0]),Lf.material=this._compositeMaterial,Lf.render(e),kg.restoreRendererState(e,Df)}setup(t){const e=hf(()=>{const t=this.inputNode,e=yf(t.rgb),s=Sf(this.threshold,this.threshold.add(this.smoothWidth),e);return xf(Of(0),t,s)});this._highPassFilterMaterial=this._highPassFilterMaterial||new xc,this._highPassFilterMaterial.fragmentNode=e().context(t.getSharedContext()),this._highPassFilterMaterial.name="Bloom_highPass",this._highPassFilterMaterial.needsUpdate=!0;const s=[3,5,7,9,11];for(let e=0;e<this._nMips;e++)this._separableBlurMaterials.push(this._getSeparableBlurMaterial(t,s[e]));const i=Cf([1,.8,.6,.4,.2]),r=Cf([new X(1,1,1),new X(1,1,1),new X(1,1,1),new X(1,1,1),new X(1,1,1)]),n=hf(([t,e])=>{const s=mf(1.2).sub(t);return xf(t,s,e)}).setLayout({name:"lerpBloomFactor",type:"float",inputs:[{name:"factor",type:"float"},{name:"radius",type:"float"}]}),a=hf(()=>{const t=n(i.element(0),this.radius).mul(Of(r.element(0),1)).mul(this._textureNodeBlur0),e=n(i.element(1),this.radius).mul(Of(r.element(1),1)).mul(this._textureNodeBlur1),s=n(i.element(2),this.radius).mul(Of(r.element(2),1)).mul(this._textureNodeBlur2),a=n(i.element(3),this.radius).mul(Of(r.element(3),1)).mul(this._textureNodeBlur3),o=n(i.element(4),this.radius).mul(Of(r.element(4),1)).mul(this._textureNodeBlur4);return t.add(e).add(s).add(a).add(o).mul(this.strength)});return this._compositeMaterial=this._compositeMaterial||new xc,this._compositeMaterial.fragmentNode=a().context(t.getSharedContext()),this._compositeMaterial.name="Bloom_comp",this._compositeMaterial.needsUpdate=!0,this._textureOutput}dispose(){for(let t=0;t<this._renderTargetsHorizontal.length;t++)this._renderTargetsHorizontal[t].dispose();for(let t=0;t<this._renderTargetsVertical.length;t++)this._renderTargetsVertical[t].dispose();this._renderTargetBright.dispose()}_getSeparableBlurMaterial(t,e){const s=[];for(let t=0;t<e;t++)s.push(.39894*Math.exp(-.5*t*t/(e*e))/e);const i=Vf(),r=Cf(s),n=zf(new S),a=zf(new S(.5,.5)),o=Rf(),h=t=>i.sample(t),l=hf(()=>{const t=r.element(0).toVar(),s=h(o).rgb.mul(t).toVar();return lf({start:gf(1),end:gf(e),type:"int",condition:"<"},({i:e})=>{const i=mf(e),l=r.element(e),u=a.mul(n).mul(i),c=h(o.add(u)).rgb,d=h(o.sub(u)).rgb;s.addAssign(df(c,d).mul(l)),t.addAssign(mf(2).mul(l))}),Of(s.div(t),1)}),u=new xc;return u.fragmentNode=l().context(t.getSharedContext()),u.name="Bloom_separable",u.needsUpdate=!0,u.colorTexture=i,u.direction=a,u.invSize=n,u}}const Uf=(t,e,s,i)=>wf(new kf(wf(t),e,s,i));export{hf as Fn,uf as ShaderNode,cf as abs,pf as blendScreen,Uf as bloom,mf as float,ff as max,bf as mod,vf as mx_cell_noise_float,Tf as oneMinus,Nf as pass,_f as select,Sf as smoothstep,Af as sub,Vf as texture,zf as uniform,Rf as uv,Ef as vec2,If as vec3};
